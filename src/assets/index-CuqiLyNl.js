const kl = (n, e, t) => { if (!e.has(n)) throw TypeError('Cannot ' + t) }; const R = (n, e, t) => (kl(n, e, 'read from private field'), t ? t.call(n) : e.get(n)); const j = (n, e, t) => { if (e.has(n)) throw TypeError('Cannot add the same private member more than once'); e instanceof WeakSet ? e.add(n) : e.set(n, t) }; const V = (n, e, t, r) => (kl(n, e, 'write to private field'), r ? r.call(n, t) : e.set(n, t), t); const Lo = (n, e, t, r) => ({ set _ (i) { V(n, e, i, t) }, get _ () { return R(n, e, r) } }); const te = (n, e, t) => (kl(n, e, 'access private method'), t); function aE (n, e) { for (let t = 0; t < e.length; t++) { const r = e[t]; if (typeof r !== 'string' && !Array.isArray(r)) { for (const i in r) if (i !== 'default' && !(i in n)) { const s = Object.getOwnPropertyDescriptor(r, i); s && Object.defineProperty(n, i, s.get ? s : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' })) }(function () { const e = document.createElement('link').relList; if (e && e.supports && e.supports('modulepreload')) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i); new MutationObserver(i => { for (const s of i) if (s.type === 'childList') for (const o of s.addedNodes)o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o) }).observe(document, { childList: !0, subtree: !0 }); function t (i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === 'use-credentials' ? s.credentials = 'include' : i.crossOrigin === 'anonymous' ? s.credentials = 'omit' : s.credentials = 'same-origin', s } function r (i) { if (i.ep) return; i.ep = !0; const s = t(i); fetch(i.href, s) } })(); const Pl = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {}; function ad (n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n } function lE (n) { if (n.__esModule) return n; const e = n.default; if (typeof e === 'function') { var t = function r () { return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; t.prototype = e.prototype } else t = {}; return Object.defineProperty(t, '__esModule', { value: !0 }), Object.keys(n).forEach(function (r) { const i = Object.getOwnPropertyDescriptor(n, r); Object.defineProperty(t, r, i.get ? i : { enumerable: !0, get: function () { return n[r] } }) }), t } const Dm = { exports: {} }; const ol = {}; const km = { exports: {} }; const ne = {}/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const mo = Symbol.for('react.element'); const uE = Symbol.for('react.portal'); const cE = Symbol.for('react.fragment'); const dE = Symbol.for('react.strict_mode'); const hE = Symbol.for('react.profiler'); const fE = Symbol.for('react.provider'); const pE = Symbol.for('react.context'); const mE = Symbol.for('react.forward_ref'); const gE = Symbol.for('react.suspense'); const yE = Symbol.for('react.memo'); const vE = Symbol.for('react.lazy'); const Nh = Symbol.iterator; function EE (n) { return n === null || typeof n !== 'object' ? null : (n = Nh && n[Nh] || n['@@iterator'], typeof n === 'function' ? n : null) } const Pm = { isMounted: function () { return !1 }, enqueueForceUpdate: function () {}, enqueueReplaceState: function () {}, enqueueSetState: function () {} }; const bm = Object.assign; const Om = {}; function Xi (n, e, t) { this.props = n, this.context = e, this.refs = Om, this.updater = t || Pm }Xi.prototype.isReactComponent = {}; Xi.prototype.setState = function (n, e) { if (typeof n !== 'object' && typeof n !== 'function' && n != null) throw Error('setState(...): takes an object of state variables to update or a function which returns an object of state variables.'); this.updater.enqueueSetState(this, n, e, 'setState') }; Xi.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, 'forceUpdate') }; function Fm () {}Fm.prototype = Xi.prototype; function ld (n, e, t) { this.props = n, this.context = e, this.refs = Om, this.updater = t || Pm } const ud = ld.prototype = new Fm(); ud.constructor = ld; bm(ud, Xi.prototype); ud.isPureReactComponent = !0; const Uh = Array.isArray; const Mm = Object.prototype.hasOwnProperty; const cd = { current: null }; const Nm = { key: !0, ref: !0, __self: !0, __source: !0 }; function Um (n, e, t) { let r; const i = {}; let s = null; let o = null; if (e != null) for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = '' + e.key), e)Mm.call(e, r) && !Nm.hasOwnProperty(r) && (i[r] = e[r]); let a = arguments.length - 2; if (a === 1)i.children = t; else if (a > 1) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } if (n && n.defaultProps) for (r in a = n.defaultProps, a)i[r] === void 0 && (i[r] = a[r]); return { $$typeof: mo, type: n, key: s, ref: o, props: i, _owner: cd.current } } function SE (n, e) { return { $$typeof: mo, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner } } function dd (n) { return typeof n === 'object' && n !== null && n.$$typeof === mo } function TE (n) { const e = { '=': '=0', ':': '=2' }; return '$' + n.replace(/[=:]/g, function (t) { return e[t] }) } const Bh = /\/+/g; function bl (n, e) { return typeof n === 'object' && n !== null && n.key != null ? TE('' + n.key) : e.toString(36) } function Zo (n, e, t, r, i) { let s = typeof n; (s === 'undefined' || s === 'boolean') && (n = null); let o = !1; if (n === null)o = !0; else switch (s) { case 'string':case 'number':o = !0; break; case 'object':switch (n.$$typeof) { case mo:case uE:o = !0 } } if (o) return o = n, i = i(o), n = r === '' ? '.' + bl(o, 0) : r, Uh(i) ? (t = '', n != null && (t = n.replace(Bh, '$&/') + '/'), Zo(i, e, t, '', function (u) { return u })) : i != null && (dd(i) && (i = SE(i, t + (!i.key || o && o.key === i.key ? '' : ('' + i.key).replace(Bh, '$&/') + '/') + n)), e.push(i)), 1; if (o = 0, r = r === '' ? '.' : r + ':', Uh(n)) for (var a = 0; a < n.length; a++) { s = n[a]; var l = r + bl(s, a); o += Zo(s, e, t, l, i) } else if (l = EE(n), typeof l === 'function') for (n = l.call(n), a = 0; !(s = n.next()).done;)s = s.value, l = r + bl(s, a++), o += Zo(s, e, t, l, i); else if (s === 'object') throw e = String(n), Error('Objects are not valid as a React child (found: ' + (e === '[object Object]' ? 'object with keys {' + Object.keys(n).join(', ') + '}' : e) + '). If you meant to render a collection of children, use an array instead.'); return o } function Ro (n, e, t) { if (n == null) return n; const r = []; let i = 0; return Zo(n, r, '', '', function (s) { return e.call(t, s, i++) }), r } function xE (n) { if (n._status === -1) { let e = n._result; e = e(), e.then(function (t) { (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t) }, function (t) { (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t) }), n._status === -1 && (n._status = 0, n._result = e) } if (n._status === 1) return n._result.default; throw n._result } const at = { current: null }; const ea = { transition: null }; const LE = { ReactCurrentDispatcher: at, ReactCurrentBatchConfig: ea, ReactCurrentOwner: cd }; function Bm () { throw Error('act(...) is not supported in production builds of React.') }ne.Children = { map: Ro, forEach: function (n, e, t) { Ro(n, function () { e.apply(this, arguments) }, t) }, count: function (n) { let e = 0; return Ro(n, function () { e++ }), e }, toArray: function (n) { return Ro(n, function (e) { return e }) || [] }, only: function (n) { if (!dd(n)) throw Error('React.Children.only expected to receive a single React element child.'); return n } }; ne.Component = Xi; ne.Fragment = cE; ne.Profiler = hE; ne.PureComponent = ld; ne.StrictMode = dE; ne.Suspense = gE; ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LE; ne.act = Bm; ne.cloneElement = function (n, e, t) { if (n == null) throw Error('React.cloneElement(...): The argument must be a React element, but you passed ' + n + '.'); const r = bm({}, n.props); let i = n.key; let s = n.ref; let o = n._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = cd.current), e.key !== void 0 && (i = '' + e.key), n.type && n.type.defaultProps) var a = n.type.defaultProps; for (l in e)Mm.call(e, l) && !Nm.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1)r.children = t; else if (l > 1) { a = Array(l); for (let u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: mo, type: n.type, key: i, ref: s, props: r, _owner: o } }; ne.createContext = function (n) { return n = { $$typeof: pE, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: fE, _context: n }, n.Consumer = n }; ne.createElement = Um; ne.createFactory = function (n) { const e = Um.bind(null, n); return e.type = n, e }; ne.createRef = function () { return { current: null } }; ne.forwardRef = function (n) { return { $$typeof: mE, render: n } }; ne.isValidElement = dd; ne.lazy = function (n) { return { $$typeof: vE, _payload: { _status: -1, _result: n }, _init: xE } }; ne.memo = function (n, e) { return { $$typeof: yE, type: n, compare: e === void 0 ? null : e } }; ne.startTransition = function (n) { const e = ea.transition; ea.transition = {}; try { n() } finally { ea.transition = e } }; ne.unstable_act = Bm; ne.useCallback = function (n, e) { return at.current.useCallback(n, e) }; ne.useContext = function (n) { return at.current.useContext(n) }; ne.useDebugValue = function () {}; ne.useDeferredValue = function (n) { return at.current.useDeferredValue(n) }; ne.useEffect = function (n, e) { return at.current.useEffect(n, e) }; ne.useId = function () { return at.current.useId() }; ne.useImperativeHandle = function (n, e, t) { return at.current.useImperativeHandle(n, e, t) }; ne.useInsertionEffect = function (n, e) { return at.current.useInsertionEffect(n, e) }; ne.useLayoutEffect = function (n, e) { return at.current.useLayoutEffect(n, e) }; ne.useMemo = function (n, e) { return at.current.useMemo(n, e) }; ne.useReducer = function (n, e, t) { return at.current.useReducer(n, e, t) }; ne.useRef = function (n) { return at.current.useRef(n) }; ne.useState = function (n) { return at.current.useState(n) }; ne.useSyncExternalStore = function (n, e, t) { return at.current.useSyncExternalStore(n, e, t) }; ne.useTransition = function () { return at.current.useTransition() }; ne.version = '18.3.1'; km.exports = ne; const k = km.exports; const $m = ad(k); const RE = aE({ __proto__: null, default: $m }, [k])/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const AE = k; const wE = Symbol.for('react.element'); const CE = Symbol.for('react.fragment'); const IE = Object.prototype.hasOwnProperty; const _E = AE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner; const DE = { key: !0, ref: !0, __self: !0, __source: !0 }; function Gm (n, e, t) { let r; const i = {}; let s = null; let o = null; t !== void 0 && (s = '' + t), e.key !== void 0 && (s = '' + e.key), e.ref !== void 0 && (o = e.ref); for (r in e)IE.call(e, r) && !DE.hasOwnProperty(r) && (i[r] = e[r]); if (n && n.defaultProps) for (r in e = n.defaultProps, e)i[r] === void 0 && (i[r] = e[r]); return { $$typeof: wE, type: n, key: s, ref: o, props: i, _owner: _E.current } }ol.Fragment = CE; ol.jsx = Gm; ol.jsxs = Gm; Dm.exports = ol; const B = Dm.exports; const bu = {}; const Vm = { exports: {} }; const It = {}; const Hm = { exports: {} }; const Km = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e (N, M) { let b = N.length; N.push(M); e:for (;b > 0;) { const q = b - 1 >>> 1; const z = N[q]; if (i(z, M) > 0)N[q] = M, N[b] = z, b = q; else break e } } function t (N) { return N.length === 0 ? null : N[0] } function r (N) { if (N.length === 0) return null; const M = N[0]; const b = N.pop(); if (b !== M) { N[0] = b; e:for (let q = 0, z = N.length, ie = z >>> 1; q < ie;) { const ue = 2 * (q + 1) - 1; const xe = N[ue]; const fe = ue + 1; const Ge = N[fe]; if (i(xe, b) < 0)fe < z && i(Ge, xe) < 0 ? (N[q] = Ge, N[fe] = b, q = fe) : (N[q] = xe, N[ue] = b, q = ue); else if (fe < z && i(Ge, b) < 0)N[q] = Ge, N[fe] = b, q = fe; else break e } } return M } function i (N, M) { const b = N.sortIndex - M.sortIndex; return b !== 0 ? b : N.id - M.id } if (typeof performance === 'object' && typeof performance.now === 'function') { const s = performance; n.unstable_now = function () { return s.now() } } else { const o = Date; const a = o.now(); n.unstable_now = function () { return o.now() - a } } const l = []; const u = []; let c = 1; let d = null; let h = 3; let f = !1; let p = !1; let m = !1; const y = typeof setTimeout === 'function' ? setTimeout : null; const g = typeof clearTimeout === 'function' ? clearTimeout : null; const v = typeof setImmediate < 'u' ? setImmediate : null; typeof navigator < 'u' && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function E (N) { for (let M = t(u); M !== null;) { if (M.callback === null)r(u); else if (M.startTime <= N)r(u), M.sortIndex = M.expirationTime, e(l, M); else break; M = t(u) } } function x (N) { if (m = !1, E(N), !p) if (t(l) !== null)p = !0, Y(T); else { const M = t(u); M !== null && re(x, M.startTime - N) } } function T (N, M) { p = !1, m && (m = !1, g(A), A = -1), f = !0; const b = h; try { for (E(M), d = t(l); d !== null && (!(d.expirationTime > M) || N && !F());) { const q = d.callback; if (typeof q === 'function') { d.callback = null, h = d.priorityLevel; const z = q(d.expirationTime <= M); M = n.unstable_now(), typeof z === 'function' ? d.callback = z : d === t(l) && r(l), E(M) } else r(l); d = t(l) } if (d !== null) var ie = !0; else { const ue = t(u); ue !== null && re(x, ue.startTime - M), ie = !1 } return ie } finally { d = null, h = b, f = !1 } } let w = !1; let L = null; var A = -1; let P = 5; let _ = -1; function F () { return !(n.unstable_now() - _ < P) } function $ () { if (L !== null) { const N = n.unstable_now(); _ = N; let M = !0; try { M = L(!0, N) } finally { M ? G() : (w = !1, L = null) } } else w = !1 } let G; if (typeof v === 'function')G = function () { v($) }; else if (typeof MessageChannel < 'u') { const W = new MessageChannel(); const Z = W.port2; W.port1.onmessage = $, G = function () { Z.postMessage(null) } } else G = function () { y($, 0) }; function Y (N) { L = N, w || (w = !0, G()) } function re (N, M) { A = y(function () { N(n.unstable_now()) }, M) }n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (N) { N.callback = null }, n.unstable_continueExecution = function () { p || f || (p = !0, Y(T)) }, n.unstable_forceFrameRate = function (N) { N < 0 || N > 125 ? console.error('forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported') : P = N > 0 ? Math.floor(1e3 / N) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return h }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (N) { switch (h) { case 1:case 2:case 3:var M = 3; break; default:M = h } const b = h; h = M; try { return N() } finally { h = b } }, n.unstable_pauseExecution = function () {}, n.unstable_requestPaint = function () {}, n.unstable_runWithPriority = function (N, M) { switch (N) { case 1:case 2:case 3:case 4:case 5:break; default:N = 3 } const b = h; h = N; try { return M() } finally { h = b } }, n.unstable_scheduleCallback = function (N, M, b) { const q = n.unstable_now(); switch (typeof b === 'object' && b !== null ? (b = b.delay, b = typeof b === 'number' && b > 0 ? q + b : q) : b = q, N) { case 1:var z = -1; break; case 2:z = 250; break; case 5:z = 1073741823; break; case 4:z = 1e4; break; default:z = 5e3 } return z = b + z, N = { id: c++, callback: M, priorityLevel: N, startTime: b, expirationTime: z, sortIndex: -1 }, b > q ? (N.sortIndex = b, e(u, N), t(l) === null && N === t(u) && (m ? (g(A), A = -1) : m = !0, re(x, b - q))) : (N.sortIndex = z, e(l, N), p || f || (p = !0, Y(T))), N }, n.unstable_shouldYield = F, n.unstable_wrapCallback = function (N) { const M = h; return function () { const b = h; h = M; try { return N.apply(this, arguments) } finally { h = b } } } })(Km); Hm.exports = Km; const kE = Hm.exports/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const PE = k; const Ct = kE; function U (n) { for (var e = 'https://reactjs.org/docs/error-decoder.html?invariant=' + n, t = 1; t < arguments.length; t++)e += '&args[]=' + encodeURIComponent(arguments[t]); return 'Minified React error #' + n + '; visit ' + e + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.' } const jm = new Set(); const ks = {}; function Gr (n, e) { Ui(n, e), Ui(n + 'Capture', e) } function Ui (n, e) { for (ks[n] = e, n = 0; n < e.length; n++)jm.add(e[n]) } const wn = !(typeof window > 'u' || typeof window.document > 'u' || typeof window.document.createElement > 'u'); const Ou = Object.prototype.hasOwnProperty; const bE = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/; const $h = {}; const Gh = {}; function OE (n) { return Ou.call(Gh, n) ? !0 : Ou.call($h, n) ? !1 : bE.test(n) ? Gh[n] = !0 : ($h[n] = !0, !1) } function FE (n, e, t, r) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case 'function':case 'symbol':return !0; case 'boolean':return r ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== 'data-' && n !== 'aria-'); default:return !1 } } function ME (n, e, t, r) { if (e === null || typeof e > 'u' || FE(n, e, t, r)) return !0; if (r) return !1; if (t !== null) switch (t.type) { case 3:return !e; case 4:return e === !1; case 5:return isNaN(e); case 6:return isNaN(e) || e < 1 } return !1 } function lt (n, e, t, r, i, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } const We = {}; 'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (n) { We[n] = new lt(n, 0, !1, n, null, !1, !1) }); [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (n) { const e = n[0]; We[e] = new lt(e, 1, !1, n[1], null, !1, !1) }); ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (n) { We[n] = new lt(n, 2, !1, n.toLowerCase(), null, !1, !1) }); ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (n) { We[n] = new lt(n, 2, !1, n, null, !1, !1) }); 'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (n) { We[n] = new lt(n, 3, !1, n.toLowerCase(), null, !1, !1) }); ['checked', 'multiple', 'muted', 'selected'].forEach(function (n) { We[n] = new lt(n, 3, !0, n, null, !1, !1) }); ['capture', 'download'].forEach(function (n) { We[n] = new lt(n, 4, !1, n, null, !1, !1) }); ['cols', 'rows', 'size', 'span'].forEach(function (n) { We[n] = new lt(n, 6, !1, n, null, !1, !1) }); ['rowSpan', 'start'].forEach(function (n) { We[n] = new lt(n, 5, !1, n.toLowerCase(), null, !1, !1) }); const hd = /[\-:]([a-z])/g; function fd (n) { return n[1].toUpperCase() }'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (n) { const e = n.replace(hd, fd); We[e] = new lt(e, 1, !1, n, null, !1, !1) }); 'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (n) { const e = n.replace(hd, fd); We[e] = new lt(e, 1, !1, n, 'http://www.w3.org/1999/xlink', !1, !1) }); ['xml:base', 'xml:lang', 'xml:space'].forEach(function (n) { const e = n.replace(hd, fd); We[e] = new lt(e, 1, !1, n, 'http://www.w3.org/XML/1998/namespace', !1, !1) }); ['tabIndex', 'crossOrigin'].forEach(function (n) { We[n] = new lt(n, 1, !1, n.toLowerCase(), null, !1, !1) }); We.xlinkHref = new lt('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1); ['src', 'href', 'action', 'formAction'].forEach(function (n) { We[n] = new lt(n, 1, !1, n.toLowerCase(), null, !0, !0) }); function pd (n, e, t, r) { let i = We.hasOwnProperty(e) ? We[e] : null; (i !== null ? i.type !== 0 : r || !(e.length > 2) || e[0] !== 'o' && e[0] !== 'O' || e[1] !== 'n' && e[1] !== 'N') && (ME(e, t, i, r) && (t = null), r || i === null ? OE(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, '' + t)) : i.mustUseProperty ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : '' : t : (e = i.attributeName, r = i.attributeNamespace, t === null ? n.removeAttribute(e) : (i = i.type, t = i === 3 || i === 4 && t === !0 ? '' : '' + t, r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t)))) } const Dn = PE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; const Ao = Symbol.for('react.element'); const ni = Symbol.for('react.portal'); const ri = Symbol.for('react.fragment'); const md = Symbol.for('react.strict_mode'); const Fu = Symbol.for('react.profiler'); const zm = Symbol.for('react.provider'); const Wm = Symbol.for('react.context'); const gd = Symbol.for('react.forward_ref'); const Mu = Symbol.for('react.suspense'); const Nu = Symbol.for('react.suspense_list'); const yd = Symbol.for('react.memo'); const Fn = Symbol.for('react.lazy'); const Ym = Symbol.for('react.offscreen'); const Vh = Symbol.iterator; function is (n) { return n === null || typeof n !== 'object' ? null : (n = Vh && n[Vh] || n['@@iterator'], typeof n === 'function' ? n : null) } const Te = Object.assign; let Ol; function ms (n) {
  if (Ol === void 0) try { throw Error() } catch (t) { const e = t.stack.trim().match(/\n( *(at )?)/); Ol = e && e[1] || '' } return `
` + Ol + n
} let Fl = !1; function Ml (n, e) {
  if (!n || Fl) return ''; Fl = !0; const t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, 'props', { set: function () { throw Error() } }), typeof Reflect === 'object' && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var r = u }Reflect.construct(n, [], e) } else { try { e.call() } catch (u) { r = u }n.call(e.prototype) } else { try { throw Error() } catch (u) { r = u }n() } } catch (u) {
    if (u && r && typeof u.stack === 'string') {
      for (var i = u.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; o >= 1 && a >= 0 && i[o] !== s[a];)a--; for (;o >= 1 && a >= 0; o--, a--) {
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1) {
            do {
              if (o--, a--, a < 0 || i[o] !== s[a]) {
                let l = `
` + i[o].replace(' at new ', ' at '); return n.displayName && l.includes('<anonymous>') && (l = l.replace('<anonymous>', n.displayName)), l
              }
            } while (o >= 1 && a >= 0)
          } break
        }
      }
    }
  } finally { Fl = !1, Error.prepareStackTrace = t } return (n = n ? n.displayName || n.name : '') ? ms(n) : ''
} function NE (n) { switch (n.tag) { case 5:return ms(n.type); case 16:return ms('Lazy'); case 13:return ms('Suspense'); case 19:return ms('SuspenseList'); case 0:case 2:case 15:return n = Ml(n.type, !1), n; case 11:return n = Ml(n.type.render, !1), n; case 1:return n = Ml(n.type, !0), n; default:return '' } } function Uu (n) { if (n == null) return null; if (typeof n === 'function') return n.displayName || n.name || null; if (typeof n === 'string') return n; switch (n) { case ri:return 'Fragment'; case ni:return 'Portal'; case Fu:return 'Profiler'; case md:return 'StrictMode'; case Mu:return 'Suspense'; case Nu:return 'SuspenseList' } if (typeof n === 'object') switch (n.$$typeof) { case Wm:return (n.displayName || 'Context') + '.Consumer'; case zm:return (n._context.displayName || 'Context') + '.Provider'; case gd:var e = n.render; return n = n.displayName, n || (n = e.displayName || e.name || '', n = n !== '' ? 'ForwardRef(' + n + ')' : 'ForwardRef'), n; case yd:return e = n.displayName || null, e !== null ? e : Uu(n.type) || 'Memo'; case Fn:e = n._payload, n = n._init; try { return Uu(n(e)) } catch {} } return null } function UE (n) { const e = n.type; switch (n.tag) { case 24:return 'Cache'; case 9:return (e.displayName || 'Context') + '.Consumer'; case 10:return (e._context.displayName || 'Context') + '.Provider'; case 18:return 'DehydratedFragment'; case 11:return n = e.render, n = n.displayName || n.name || '', e.displayName || (n !== '' ? 'ForwardRef(' + n + ')' : 'ForwardRef'); case 7:return 'Fragment'; case 5:return e; case 4:return 'Portal'; case 3:return 'Root'; case 6:return 'Text'; case 16:return Uu(e); case 8:return e === md ? 'StrictMode' : 'Mode'; case 22:return 'Offscreen'; case 12:return 'Profiler'; case 21:return 'Scope'; case 13:return 'Suspense'; case 19:return 'SuspenseList'; case 25:return 'TracingMarker'; case 1:case 0:case 17:case 2:case 14:case 15:if (typeof e === 'function') return e.displayName || e.name || null; if (typeof e === 'string') return e } return null } function or (n) { switch (typeof n) { case 'boolean':case 'number':case 'string':case 'undefined':return n; case 'object':return n; default:return '' } } function qm (n) { const e = n.type; return (n = n.nodeName) && n.toLowerCase() === 'input' && (e === 'checkbox' || e === 'radio') } function BE (n) { const e = qm(n) ? 'checked' : 'value'; const t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e); let r = '' + n[e]; if (!n.hasOwnProperty(e) && typeof t < 'u' && typeof t.get === 'function' && typeof t.set === 'function') { const i = t.get; const s = t.set; return Object.defineProperty(n, e, { configurable: !0, get: function () { return i.call(this) }, set: function (o) { r = '' + o, s.call(this, o) } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = '' + o }, stopTracking: function () { n._valueTracker = null, delete n[e] } } } } function wo (n) { n._valueTracker || (n._valueTracker = BE(n)) } function Qm (n) { if (!n) return !1; const e = n._valueTracker; if (!e) return !0; const t = e.getValue(); let r = ''; return n && (r = qm(n) ? n.checked ? 'true' : 'false' : n.value), n = r, n !== t ? (e.setValue(n), !0) : !1 } function Ta (n) { if (n = n || (typeof document < 'u' ? document : void 0), typeof n > 'u') return null; try { return n.activeElement || n.body } catch { return n.body } } function Bu (n, e) { const t = e.checked; return Te({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked }) } function Hh (n, e) { let t = e.defaultValue == null ? '' : e.defaultValue; const r = e.checked != null ? e.checked : e.defaultChecked; t = or(e.value != null ? e.value : t), n._wrapperState = { initialChecked: r, initialValue: t, controlled: e.type === 'checkbox' || e.type === 'radio' ? e.checked != null : e.value != null } } function Xm (n, e) { e = e.checked, e != null && pd(n, 'checked', e, !1) } function $u (n, e) { Xm(n, e); const t = or(e.value); const r = e.type; if (t != null)r === 'number' ? (t === 0 && n.value === '' || n.value != t) && (n.value = '' + t) : n.value !== '' + t && (n.value = '' + t); else if (r === 'submit' || r === 'reset') { n.removeAttribute('value'); return }e.hasOwnProperty('value') ? Gu(n, e.type, t) : e.hasOwnProperty('defaultValue') && Gu(n, e.type, or(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked) } function Kh (n, e, t) { if (e.hasOwnProperty('value') || e.hasOwnProperty('defaultValue')) { const r = e.type; if (!(r !== 'submit' && r !== 'reset' || e.value !== void 0 && e.value !== null)) return; e = '' + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e }t = n.name, t !== '' && (n.name = ''), n.defaultChecked = !!n._wrapperState.initialChecked, t !== '' && (n.name = t) } function Gu (n, e, t) { (e !== 'number' || Ta(n.ownerDocument) !== n) && (t == null ? n.defaultValue = '' + n._wrapperState.initialValue : n.defaultValue !== '' + t && (n.defaultValue = '' + t)) } const gs = Array.isArray; function mi (n, e, t, r) { if (n = n.options, e) { e = {}; for (var i = 0; i < t.length; i++)e['$' + t[i]] = !0; for (t = 0; t < n.length; t++)i = e.hasOwnProperty('$' + n[t].value), n[t].selected !== i && (n[t].selected = i), i && r && (n[t].defaultSelected = !0) } else { for (t = '' + or(t), e = null, i = 0; i < n.length; i++) { if (n[i].value === t) { n[i].selected = !0, r && (n[i].defaultSelected = !0); return }e !== null || n[i].disabled || (e = n[i]) }e !== null && (e.selected = !0) } } function Vu (n, e) { if (e.dangerouslySetInnerHTML != null) throw Error(U(91)); return Te({}, e, { value: void 0, defaultValue: void 0, children: '' + n._wrapperState.initialValue }) } function jh (n, e) { let t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(U(92)); if (gs(t)) { if (t.length > 1) throw Error(U(93)); t = t[0] }e = t }e == null && (e = ''), t = e }n._wrapperState = { initialValue: or(t) } } function Jm (n, e) { let t = or(e.value); const r = or(e.defaultValue); t != null && (t = '' + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), r != null && (n.defaultValue = '' + r) } function zh (n) { const e = n.textContent; e === n._wrapperState.initialValue && e !== '' && e !== null && (n.value = e) } function Zm (n) { switch (n) { case 'svg':return 'http://www.w3.org/2000/svg'; case 'math':return 'http://www.w3.org/1998/Math/MathML'; default:return 'http://www.w3.org/1999/xhtml' } } function Hu (n, e) { return n == null || n === 'http://www.w3.org/1999/xhtml' ? Zm(e) : n === 'http://www.w3.org/2000/svg' && e === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : n } let Co; const eg = (function (n) { return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction ? function (e, t, r, i) { MSApp.execUnsafeLocalFunction(function () { return n(e, t, r, i) }) } : n }(function (n, e) { if (n.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in n)n.innerHTML = e; else { for (Co = Co || document.createElement('div'), Co.innerHTML = '<svg>' + e.valueOf().toString() + '</svg>', e = Co.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (;e.firstChild;)n.appendChild(e.firstChild) } })); function Ps (n, e) { if (e) { const t = n.firstChild; if (t && t === n.lastChild && t.nodeType === 3) { t.nodeValue = e; return } }n.textContent = e } const Ts = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }; const $E = ['Webkit', 'ms', 'Moz', 'O']; Object.keys(Ts).forEach(function (n) { $E.forEach(function (e) { e = e + n.charAt(0).toUpperCase() + n.substring(1), Ts[e] = Ts[n] }) }); function tg (n, e, t) { return e == null || typeof e === 'boolean' || e === '' ? '' : t || typeof e !== 'number' || e === 0 || Ts.hasOwnProperty(n) && Ts[n] ? ('' + e).trim() : e + 'px' } function ng (n, e) { n = n.style; for (let t in e) if (e.hasOwnProperty(t)) { const r = t.indexOf('--') === 0; const i = tg(t, e[t], r); t === 'float' && (t = 'cssFloat'), r ? n.setProperty(t, i) : n[t] = i } } const GE = Te({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Ku (n, e) { if (e) { if (GE[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(U(137, n)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(U(60)); if (typeof e.dangerouslySetInnerHTML !== 'object' || !('__html' in e.dangerouslySetInnerHTML)) throw Error(U(61)) } if (e.style != null && typeof e.style !== 'object') throw Error(U(62)) } } function ju (n, e) { if (n.indexOf('-') === -1) return typeof e.is === 'string'; switch (n) { case 'annotation-xml':case 'color-profile':case 'font-face':case 'font-face-src':case 'font-face-uri':case 'font-face-format':case 'font-face-name':case 'missing-glyph':return !1; default:return !0 } } let zu = null; function vd (n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } let Wu = null; let gi = null; let yi = null; function Wh (n) { if (n = vo(n)) { if (typeof Wu !== 'function') throw Error(U(280)); let e = n.stateNode; e && (e = dl(e), Wu(n.stateNode, n.type, e)) } } function rg (n) { gi ? yi ? yi.push(n) : yi = [n] : gi = n } function ig () { if (gi) { let n = gi; const e = yi; if (yi = gi = null, Wh(n), e) for (n = 0; n < e.length; n++)Wh(e[n]) } } function sg (n, e) { return n(e) } function og () {} let Nl = !1; function ag (n, e, t) { if (Nl) return n(e, t); Nl = !0; try { return sg(n, e, t) } finally { Nl = !1, (gi !== null || yi !== null) && (og(), ig()) } } function bs (n, e) { let t = n.stateNode; if (t === null) return null; let r = dl(t); if (r === null) return null; t = r[e]; e:switch (e) { case 'onClick':case 'onClickCapture':case 'onDoubleClick':case 'onDoubleClickCapture':case 'onMouseDown':case 'onMouseDownCapture':case 'onMouseMove':case 'onMouseMoveCapture':case 'onMouseUp':case 'onMouseUpCapture':case 'onMouseEnter':(r = !r.disabled) || (n = n.type, r = !(n === 'button' || n === 'input' || n === 'select' || n === 'textarea')), n = !r; break e; default:n = !1 } if (n) return null; if (t && typeof t !== 'function') throw Error(U(231, e, typeof t)); return t } let Yu = !1; if (wn) try { const ss = {}; Object.defineProperty(ss, 'passive', { get: function () { Yu = !0 } }), window.addEventListener('test', ss, ss), window.removeEventListener('test', ss, ss) } catch { Yu = !1 } function VE (n, e, t, r, i, s, o, a, l) { const u = Array.prototype.slice.call(arguments, 3); try { e.apply(t, u) } catch (c) { this.onError(c) } } let xs = !1; let xa = null; let La = !1; let qu = null; const HE = { onError: function (n) { xs = !0, xa = n } }; function KE (n, e, t, r, i, s, o, a, l) { xs = !1, xa = null, VE.apply(HE, arguments) } function jE (n, e, t, r, i, s, o, a, l) { if (KE.apply(this, arguments), xs) { if (xs) { var u = xa; xs = !1, xa = null } else throw Error(U(198)); La || (La = !0, qu = u) } } function Vr (n) { let e = n; let t = n; if (n.alternate) for (;e.return;)e = e.return; else { n = e; do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n) } return e.tag === 3 ? t : null } function lg (n) { if (n.tag === 13) { let e = n.memoizedState; if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated } return null } function Yh (n) { if (Vr(n) !== n) throw Error(U(188)) } function zE (n) { let e = n.alternate; if (!e) { if (e = Vr(n), e === null) throw Error(U(188)); return e !== n ? null : n } for (var t = n, r = e; ;) { const i = t.return; if (i === null) break; let s = i.alternate; if (s === null) { if (r = i.return, r !== null) { t = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === t) return Yh(i), n; if (s === r) return Yh(i), e; s = s.sibling } throw Error(U(188)) } if (t.return !== r.return)t = i, r = s; else { for (var o = !1, a = i.child; a;) { if (a === t) { o = !0, t = i, r = s; break } if (a === r) { o = !0, r = i, t = s; break }a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === t) { o = !0, t = s, r = i; break } if (a === r) { o = !0, r = s, t = i; break }a = a.sibling } if (!o) throw Error(U(189)) } } if (t.alternate !== r) throw Error(U(190)) } if (t.tag !== 3) throw Error(U(188)); return t.stateNode.current === t ? n : e } function ug (n) { return n = zE(n), n !== null ? cg(n) : null } function cg (n) { if (n.tag === 5 || n.tag === 6) return n; for (n = n.child; n !== null;) { const e = cg(n); if (e !== null) return e; n = n.sibling } return null } const dg = Ct.unstable_scheduleCallback; const qh = Ct.unstable_cancelCallback; const WE = Ct.unstable_shouldYield; const YE = Ct.unstable_requestPaint; const Ce = Ct.unstable_now; const qE = Ct.unstable_getCurrentPriorityLevel; const Ed = Ct.unstable_ImmediatePriority; const hg = Ct.unstable_UserBlockingPriority; const Ra = Ct.unstable_NormalPriority; const QE = Ct.unstable_LowPriority; const fg = Ct.unstable_IdlePriority; let al = null; let dn = null; function XE (n) { if (dn && typeof dn.onCommitFiberRoot === 'function') try { dn.onCommitFiberRoot(al, n, void 0, (n.current.flags & 128) === 128) } catch {} } const qt = Math.clz32 ? Math.clz32 : eS; const JE = Math.log; const ZE = Math.LN2; function eS (n) { return n >>>= 0, n === 0 ? 32 : 31 - (JE(n) / ZE | 0) | 0 } let Io = 64; let _o = 4194304; function ys (n) { switch (n & -n) { case 1:return 1; case 2:return 2; case 4:return 4; case 8:return 8; case 16:return 16; case 32:return 32; case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n & 4194240; case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return n & 130023424; case 134217728:return 134217728; case 268435456:return 268435456; case 536870912:return 536870912; case 1073741824:return 1073741824; default:return n } } function Aa (n, e) { let t = n.pendingLanes; if (t === 0) return 0; let r = 0; let i = n.suspendedLanes; let s = n.pingedLanes; let o = t & 268435455; if (o !== 0) { const a = o & ~i; a !== 0 ? r = ys(a) : (s &= o, s !== 0 && (r = ys(s))) } else o = t & ~i, o !== 0 ? r = ys(o) : s !== 0 && (r = ys(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= t & 16), e = n.entangledLanes, e !== 0) for (n = n.entanglements, e &= r; e > 0;)t = 31 - qt(e), i = 1 << t, r |= n[t], e &= ~i; return r } function tS (n, e) { switch (n) { case 1:case 2:case 4:return e + 250; case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e + 5e3; case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return -1; case 134217728:case 268435456:case 536870912:case 1073741824:return -1; default:return -1 } } function nS (n, e) { for (let t = n.suspendedLanes, r = n.pingedLanes, i = n.expirationTimes, s = n.pendingLanes; s > 0;) { const o = 31 - qt(s); const a = 1 << o; const l = i[o]; l === -1 ? (!(a & t) || a & r) && (i[o] = tS(a, e)) : l <= e && (n.expiredLanes |= a), s &= ~a } } function Qu (n) { return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0 } function pg () { const n = Io; return Io <<= 1, !(Io & 4194240) && (Io = 64), n } function Ul (n) { for (var e = [], t = 0; t < 31; t++)e.push(n); return e } function go (n, e, t) { n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - qt(e), n[e] = t } function rS (n, e) { let t = n.pendingLanes & ~e; n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements; const r = n.eventTimes; for (n = n.expirationTimes; t > 0;) { const i = 31 - qt(t); const s = 1 << i; e[i] = 0, r[i] = -1, n[i] = -1, t &= ~s } } function Sd (n, e) { let t = n.entangledLanes |= e; for (n = n.entanglements; t;) { const r = 31 - qt(t); const i = 1 << r; i & e | n[r] & e && (n[r] |= e), t &= ~i } } let le = 0; function mg (n) { return n &= -n, n > 1 ? n > 4 ? n & 268435455 ? 16 : 536870912 : 4 : 1 } let gg; let Td; let yg; let vg; let Eg; let Xu = !1; const Do = []; let Xn = null; let Jn = null; let Zn = null; const Os = new Map(); const Fs = new Map(); const Un = []; const iS = 'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(' '); function Qh (n, e) { switch (n) { case 'focusin':case 'focusout':Xn = null; break; case 'dragenter':case 'dragleave':Jn = null; break; case 'mouseover':case 'mouseout':Zn = null; break; case 'pointerover':case 'pointerout':Os.delete(e.pointerId); break; case 'gotpointercapture':case 'lostpointercapture':Fs.delete(e.pointerId) } } function os (n, e, t, r, i, s) { return n === null || n.nativeEvent !== s ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = vo(e), e !== null && Td(e)), n) : (n.eventSystemFlags |= r, e = n.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), n) } function sS (n, e, t, r, i) { switch (e) { case 'focusin':return Xn = os(Xn, n, e, t, r, i), !0; case 'dragenter':return Jn = os(Jn, n, e, t, r, i), !0; case 'mouseover':return Zn = os(Zn, n, e, t, r, i), !0; case 'pointerover':var s = i.pointerId; return Os.set(s, os(Os.get(s) || null, n, e, t, r, i)), !0; case 'gotpointercapture':return s = i.pointerId, Fs.set(s, os(Fs.get(s) || null, n, e, t, r, i)), !0 } return !1 } function Sg (n) { let e = Er(n.target); if (e !== null) { const t = Vr(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = lg(t), e !== null) { n.blockedOn = e, Eg(n.priority, function () { yg(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } }n.blockedOn = null } function ta (n) { if (n.blockedOn !== null) return !1; for (let e = n.targetContainers; e.length > 0;) { let t = Ju(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent); if (t === null) { t = n.nativeEvent; const r = new t.constructor(t.type, t); zu = r, t.target.dispatchEvent(r), zu = null } else return e = vo(t), e !== null && Td(e), n.blockedOn = t, !1; e.shift() } return !0 } function Xh (n, e, t) { ta(n) && t.delete(e) } function oS () { Xu = !1, Xn !== null && ta(Xn) && (Xn = null), Jn !== null && ta(Jn) && (Jn = null), Zn !== null && ta(Zn) && (Zn = null), Os.forEach(Xh), Fs.forEach(Xh) } function as (n, e) { n.blockedOn === e && (n.blockedOn = null, Xu || (Xu = !0, Ct.unstable_scheduleCallback(Ct.unstable_NormalPriority, oS))) } function Ms (n) { function e (i) { return as(i, n) } if (Do.length > 0) { as(Do[0], n); for (var t = 1; t < Do.length; t++) { var r = Do[t]; r.blockedOn === n && (r.blockedOn = null) } } for (Xn !== null && as(Xn, n), Jn !== null && as(Jn, n), Zn !== null && as(Zn, n), Os.forEach(e), Fs.forEach(e), t = 0; t < Un.length; t++)r = Un[t], r.blockedOn === n && (r.blockedOn = null); for (;Un.length > 0 && (t = Un[0], t.blockedOn === null);)Sg(t), t.blockedOn === null && Un.shift() } const vi = Dn.ReactCurrentBatchConfig; let wa = !0; function aS (n, e, t, r) { const i = le; const s = vi.transition; vi.transition = null; try { le = 1, xd(n, e, t, r) } finally { le = i, vi.transition = s } } function lS (n, e, t, r) { const i = le; const s = vi.transition; vi.transition = null; try { le = 4, xd(n, e, t, r) } finally { le = i, vi.transition = s } } function xd (n, e, t, r) { if (wa) { let i = Ju(n, e, t, r); if (i === null)Yl(n, e, r, Ca, t), Qh(n, r); else if (sS(i, n, e, t, r))r.stopPropagation(); else if (Qh(n, r), e & 4 && iS.indexOf(n) > -1) { for (;i !== null;) { let s = vo(i); if (s !== null && gg(s), s = Ju(n, e, t, r), s === null && Yl(n, e, r, Ca, t), s === i) break; i = s }i !== null && r.stopPropagation() } else Yl(n, e, r, null, t) } } var Ca = null; function Ju (n, e, t, r) { if (Ca = null, n = vd(r), n = Er(n), n !== null) if (e = Vr(n), e === null)n = null; else if (t = e.tag, t === 13) { if (n = lg(e), n !== null) return n; n = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; n = null } else e !== n && (n = null); return Ca = n, null } function Tg (n) { switch (n) { case 'cancel':case 'click':case 'close':case 'contextmenu':case 'copy':case 'cut':case 'auxclick':case 'dblclick':case 'dragend':case 'dragstart':case 'drop':case 'focusin':case 'focusout':case 'input':case 'invalid':case 'keydown':case 'keypress':case 'keyup':case 'mousedown':case 'mouseup':case 'paste':case 'pause':case 'play':case 'pointercancel':case 'pointerdown':case 'pointerup':case 'ratechange':case 'reset':case 'resize':case 'seeked':case 'submit':case 'touchcancel':case 'touchend':case 'touchstart':case 'volumechange':case 'change':case 'selectionchange':case 'textInput':case 'compositionstart':case 'compositionend':case 'compositionupdate':case 'beforeblur':case 'afterblur':case 'beforeinput':case 'blur':case 'fullscreenchange':case 'focus':case 'hashchange':case 'popstate':case 'select':case 'selectstart':return 1; case 'drag':case 'dragenter':case 'dragexit':case 'dragleave':case 'dragover':case 'mousemove':case 'mouseout':case 'mouseover':case 'pointermove':case 'pointerout':case 'pointerover':case 'scroll':case 'toggle':case 'touchmove':case 'wheel':case 'mouseenter':case 'mouseleave':case 'pointerenter':case 'pointerleave':return 4; case 'message':switch (qE()) { case Ed:return 1; case hg:return 4; case Ra:case QE:return 16; case fg:return 536870912; default:return 16 } default:return 16 } } let Yn = null; let Ld = null; let na = null; function xg () { if (na) return na; let n; const e = Ld; const t = e.length; let r; const i = 'value' in Yn ? Yn.value : Yn.textContent; const s = i.length; for (n = 0; n < t && e[n] === i[n]; n++);const o = t - n; for (r = 1; r <= o && e[t - r] === i[s - r]; r++);return na = i.slice(n, r > 1 ? 1 - r : void 0) } function ra (n) { const e = n.keyCode; return 'charCode' in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), n >= 32 || n === 13 ? n : 0 } function ko () { return !0 } function Jh () { return !1 } function _t (n) { function e (t, r, i, s, o) { this._reactName = t, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (const a in n)n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ko : Jh, this.isPropagationStopped = Jh, this } return Te(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; const t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue !== 'unknown' && (t.returnValue = !1), this.isDefaultPrevented = ko) }, stopPropagation: function () { const t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble !== 'unknown' && (t.cancelBubble = !0), this.isPropagationStopped = ko) }, persist: function () {}, isPersistent: ko }), e } const Ji = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }; const Rd = _t(Ji); const yo = Te({}, Ji, { view: 0, detail: 0 }); const uS = _t(yo); let Bl; let $l; let ls; const ll = Te({}, yo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ad, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return 'movementX' in n ? n.movementX : (n !== ls && (ls && n.type === 'mousemove' ? (Bl = n.screenX - ls.screenX, $l = n.screenY - ls.screenY) : $l = Bl = 0, ls = n), Bl) }, movementY: function (n) { return 'movementY' in n ? n.movementY : $l } }); const Zh = _t(ll); const cS = Te({}, ll, { dataTransfer: 0 }); const dS = _t(cS); const hS = Te({}, yo, { relatedTarget: 0 }); const Gl = _t(hS); const fS = Te({}, Ji, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }); const pS = _t(fS); const mS = Te({}, Ji, { clipboardData: function (n) { return 'clipboardData' in n ? n.clipboardData : window.clipboardData } }); const gS = _t(mS); const yS = Te({}, Ji, { data: 0 }); const ef = _t(yS); const vS = { Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified' }; const ES = { 8: 'Backspace', 9: 'Tab', 12: 'Clear', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Escape', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NumLock', 145: 'ScrollLock', 224: 'Meta' }; const SS = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }; function TS (n) { const e = this.nativeEvent; return e.getModifierState ? e.getModifierState(n) : (n = SS[n]) ? !!e[n] : !1 } function Ad () { return TS } const xS = Te({}, yo, { key: function (n) { if (n.key) { const e = vS[n.key] || n.key; if (e !== 'Unidentified') return e } return n.type === 'keypress' ? (n = ra(n), n === 13 ? 'Enter' : String.fromCharCode(n)) : n.type === 'keydown' || n.type === 'keyup' ? ES[n.keyCode] || 'Unidentified' : '' }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ad, charCode: function (n) { return n.type === 'keypress' ? ra(n) : 0 }, keyCode: function (n) { return n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0 }, which: function (n) { return n.type === 'keypress' ? ra(n) : n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0 } }); const LS = _t(xS); const RS = Te({}, ll, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }); const tf = _t(RS); const AS = Te({}, yo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ad }); const wS = _t(AS); const CS = Te({}, Ji, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }); const IS = _t(CS); const _S = Te({}, ll, { deltaX: function (n) { return 'deltaX' in n ? n.deltaX : 'wheelDeltaX' in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return 'deltaY' in n ? n.deltaY : 'wheelDeltaY' in n ? -n.wheelDeltaY : 'wheelDelta' in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }); const DS = _t(_S); const kS = [9, 13, 27, 32]; const wd = wn && 'CompositionEvent' in window; let Ls = null; wn && 'documentMode' in document && (Ls = document.documentMode); const PS = wn && 'TextEvent' in window && !Ls; const Lg = wn && (!wd || Ls && Ls > 8 && Ls <= 11); const nf = ' '; let rf = !1; function Rg (n, e) { switch (n) { case 'keyup':return kS.indexOf(e.keyCode) !== -1; case 'keydown':return e.keyCode !== 229; case 'keypress':case 'mousedown':case 'focusout':return !0; default:return !1 } } function Ag (n) { return n = n.detail, typeof n === 'object' && 'data' in n ? n.data : null } let ii = !1; function bS (n, e) { switch (n) { case 'compositionend':return Ag(e); case 'keypress':return e.which !== 32 ? null : (rf = !0, nf); case 'textInput':return n = e.data, n === nf && rf ? null : n; default:return null } } function OS (n, e) { if (ii) return n === 'compositionend' || !wd && Rg(n, e) ? (n = xg(), na = Ld = Yn = null, ii = !1, n) : null; switch (n) { case 'paste':return null; case 'keypress':if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && e.char.length > 1) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case 'compositionend':return Lg && e.locale !== 'ko' ? null : e.data; default:return null } } const FS = { color: !0, date: !0, datetime: !0, 'datetime-local': !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function sf (n) { const e = n && n.nodeName && n.nodeName.toLowerCase(); return e === 'input' ? !!FS[n.type] : e === 'textarea' } function wg (n, e, t, r) { rg(r), e = Ia(e, 'onChange'), e.length > 0 && (t = new Rd('onChange', 'change', null, t, r), n.push({ event: t, listeners: e })) } let Rs = null; let Ns = null; function MS (n) { Ng(n, 0) } function ul (n) { const e = ai(n); if (Qm(e)) return n } function NS (n, e) { if (n === 'change') return e } let Cg = !1; if (wn) { let Vl; if (wn) { let Hl = 'oninput' in document; if (!Hl) { const of = document.createElement('div'); of.setAttribute('oninput', 'return;'), Hl = typeof of.oninput === 'function' }Vl = Hl } else Vl = !1; Cg = Vl && (!document.documentMode || document.documentMode > 9) } function af () { Rs && (Rs.detachEvent('onpropertychange', Ig), Ns = Rs = null) } function Ig (n) { if (n.propertyName === 'value' && ul(Ns)) { const e = []; wg(e, Ns, n, vd(n)), ag(MS, e) } } function US (n, e, t) { n === 'focusin' ? (af(), Rs = e, Ns = t, Rs.attachEvent('onpropertychange', Ig)) : n === 'focusout' && af() } function BS (n) { if (n === 'selectionchange' || n === 'keyup' || n === 'keydown') return ul(Ns) } function $S (n, e) { if (n === 'click') return ul(e) } function GS (n, e) { if (n === 'input' || n === 'change') return ul(e) } function VS (n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } const Xt = typeof Object.is === 'function' ? Object.is : VS; function Us (n, e) { if (Xt(n, e)) return !0; if (typeof n !== 'object' || n === null || typeof e !== 'object' || e === null) return !1; const t = Object.keys(n); let r = Object.keys(e); if (t.length !== r.length) return !1; for (r = 0; r < t.length; r++) { const i = t[r]; if (!Ou.call(e, i) || !Xt(n[i], e[i])) return !1 } return !0 } function lf (n) { for (;n && n.firstChild;)n = n.firstChild; return n } function uf (n, e) { let t = lf(n); n = 0; for (var r; t;) { if (t.nodeType === 3) { if (r = n + t.textContent.length, n <= e && r >= e) return { node: t, offset: e - n }; n = r }e: { for (;t;) { if (t.nextSibling) { t = t.nextSibling; break e }t = t.parentNode }t = void 0 }t = lf(t) } } function _g (n, e) { return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? _g(n, e.parentNode) : 'contains' in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1 } function Dg () { for (var n = window, e = Ta(); e instanceof n.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href === 'string' } catch { t = !1 } if (t)n = e.contentWindow; else break; e = Ta(n.document) } return e } function Cd (n) { const e = n && n.nodeName && n.nodeName.toLowerCase(); return e && (e === 'input' && (n.type === 'text' || n.type === 'search' || n.type === 'tel' || n.type === 'url' || n.type === 'password') || e === 'textarea' || n.contentEditable === 'true') } function HS (n) { let e = Dg(); let t = n.focusedElem; let r = n.selectionRange; if (e !== t && t && t.ownerDocument && _g(t.ownerDocument.documentElement, t)) { if (r !== null && Cd(t)) { if (e = r.start, n = r.end, n === void 0 && (n = e), 'selectionStart' in t)t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); let i = t.textContent.length; let s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !n.extend && s > r && (i = r, r = s, s = i), i = uf(t, s); const o = uf(t, r); i && o && (n.rangeCount !== 1 || n.anchorNode !== i.node || n.anchorOffset !== i.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), n.removeAllRanges(), s > r ? (n.addRange(e), n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus === 'function' && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } const KS = wn && 'documentMode' in document && document.documentMode <= 11; let si = null; let Zu = null; let As = null; let ec = !1; function cf (n, e, t) { let r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; ec || si == null || si !== Ta(r) || (r = si, 'selectionStart' in r && Cd(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), As && Us(As, r) || (As = r, r = Ia(Zu, 'onSelect'), r.length > 0 && (e = new Rd('onSelect', 'select', null, e, t), n.push({ event: e, listeners: r }), e.target = si))) } function Po (n, e) { const t = {}; return t[n.toLowerCase()] = e.toLowerCase(), t['Webkit' + n] = 'webkit' + e, t['Moz' + n] = 'moz' + e, t } const oi = { animationend: Po('Animation', 'AnimationEnd'), animationiteration: Po('Animation', 'AnimationIteration'), animationstart: Po('Animation', 'AnimationStart'), transitionend: Po('Transition', 'TransitionEnd') }; const Kl = {}; let kg = {}; wn && (kg = document.createElement('div').style, 'AnimationEvent' in window || (delete oi.animationend.animation, delete oi.animationiteration.animation, delete oi.animationstart.animation), 'TransitionEvent' in window || delete oi.transitionend.transition); function cl (n) { if (Kl[n]) return Kl[n]; if (!oi[n]) return n; const e = oi[n]; let t; for (t in e) if (e.hasOwnProperty(t) && t in kg) return Kl[n] = e[t]; return n } const Pg = cl('animationend'); const bg = cl('animationiteration'); const Og = cl('animationstart'); const Fg = cl('transitionend'); const Mg = new Map(); const df = 'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(' '); function lr (n, e) { Mg.set(n, e), Gr(e, [n]) } for (let jl = 0; jl < df.length; jl++) { const zl = df[jl]; const jS = zl.toLowerCase(); const zS = zl[0].toUpperCase() + zl.slice(1); lr(jS, 'on' + zS) }lr(Pg, 'onAnimationEnd'); lr(bg, 'onAnimationIteration'); lr(Og, 'onAnimationStart'); lr('dblclick', 'onDoubleClick'); lr('focusin', 'onFocus'); lr('focusout', 'onBlur'); lr(Fg, 'onTransitionEnd'); Ui('onMouseEnter', ['mouseout', 'mouseover']); Ui('onMouseLeave', ['mouseout', 'mouseover']); Ui('onPointerEnter', ['pointerout', 'pointerover']); Ui('onPointerLeave', ['pointerout', 'pointerover']); Gr('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')); Gr('onSelect', 'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')); Gr('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']); Gr('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')); Gr('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' ')); Gr('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')); const vs = 'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(' '); const WS = new Set('cancel close invalid load scroll toggle'.split(' ').concat(vs)); function hf (n, e, t) { const r = n.type || 'unknown-event'; n.currentTarget = t, jE(r, e, void 0, n), n.currentTarget = null } function Ng (n, e) { e = (e & 4) !== 0; for (let t = 0; t < n.length; t++) { let r = n[t]; const i = r.event; r = r.listeners; e: { let s = void 0; if (e) for (var o = r.length - 1; o >= 0; o--) { var a = r[o]; var l = a.instance; var u = a.currentTarget; if (a = a.listener, l !== s && i.isPropagationStopped()) break e; hf(i, a, u), s = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e; hf(i, a, u), s = l } } } if (La) throw n = qu, La = !1, qu = null, n } function pe (n, e) { let t = e[sc]; t === void 0 && (t = e[sc] = new Set()); const r = n + '__bubble'; t.has(r) || (Ug(e, n, 2, !1), t.add(r)) } function Wl (n, e, t) { let r = 0; e && (r |= 4), Ug(t, n, r, e) } const bo = '_reactListening' + Math.random().toString(36).slice(2); function Bs (n) { if (!n[bo]) { n[bo] = !0, jm.forEach(function (t) { t !== 'selectionchange' && (WS.has(t) || Wl(t, !1, n), Wl(t, !0, n)) }); const e = n.nodeType === 9 ? n : n.ownerDocument; e === null || e[bo] || (e[bo] = !0, Wl('selectionchange', !1, e)) } } function Ug (n, e, t, r) { switch (Tg(e)) { case 1:var i = aS; break; case 4:i = lS; break; default:i = xd }t = i.bind(null, e, t, n), i = void 0, !Yu || e !== 'touchstart' && e !== 'touchmove' && e !== 'wheel' || (i = !0), r ? i !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: i }) : n.addEventListener(e, t, !0) : i !== void 0 ? n.addEventListener(e, t, { passive: i }) : n.addEventListener(e, t, !1) } function Yl (n, e, t, r, i) { let s = r; if (!(e & 1) && !(e & 2) && r !== null)e:for (;;) { if (r === null) return; let o = r.tag; if (o === 3 || o === 4) { let a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; o = o.return } for (;a !== null;) { if (o = Er(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = s = o; continue e }a = a.parentNode } }r = r.return }ag(function () { let u = s; let c = vd(t); const d = []; e: { var h = Mg.get(n); if (h !== void 0) { var f = Rd; var p = n; switch (n) { case 'keypress':if (ra(t) === 0) break e; case 'keydown':case 'keyup':f = LS; break; case 'focusin':p = 'focus', f = Gl; break; case 'focusout':p = 'blur', f = Gl; break; case 'beforeblur':case 'afterblur':f = Gl; break; case 'click':if (t.button === 2) break e; case 'auxclick':case 'dblclick':case 'mousedown':case 'mousemove':case 'mouseup':case 'mouseout':case 'mouseover':case 'contextmenu':f = Zh; break; case 'drag':case 'dragend':case 'dragenter':case 'dragexit':case 'dragleave':case 'dragover':case 'dragstart':case 'drop':f = dS; break; case 'touchcancel':case 'touchend':case 'touchmove':case 'touchstart':f = wS; break; case Pg:case bg:case Og:f = pS; break; case Fg:f = IS; break; case 'scroll':f = uS; break; case 'wheel':f = DS; break; case 'copy':case 'cut':case 'paste':f = gS; break; case 'gotpointercapture':case 'lostpointercapture':case 'pointercancel':case 'pointerdown':case 'pointermove':case 'pointerout':case 'pointerover':case 'pointerup':f = tf } var m = (e & 4) !== 0; var y = !m && n === 'scroll'; var g = m ? h !== null ? h + 'Capture' : null : h; m = []; for (var v = u, E; v !== null;) { E = v; var x = E.stateNode; if (E.tag === 5 && x !== null && (E = x, g !== null && (x = bs(v, g), x != null && m.push($s(v, x, E)))), y) break; v = v.return }m.length > 0 && (h = new f(h, p, null, t, c), d.push({ event: h, listeners: m })) } } if (!(e & 7)) { e: { if (h = n === 'mouseover' || n === 'pointerover', f = n === 'mouseout' || n === 'pointerout', h && t !== zu && (p = t.relatedTarget || t.fromElement) && (Er(p) || p[Cn])) break e; if ((f || h) && (h = c.window === c ? c : (h = c.ownerDocument) ? h.defaultView || h.parentWindow : window, f ? (p = t.relatedTarget || t.toElement, f = u, p = p ? Er(p) : null, p !== null && (y = Vr(p), p !== y || p.tag !== 5 && p.tag !== 6) && (p = null)) : (f = null, p = u), f !== p)) { if (m = Zh, x = 'onMouseLeave', g = 'onMouseEnter', v = 'mouse', (n === 'pointerout' || n === 'pointerover') && (m = tf, x = 'onPointerLeave', g = 'onPointerEnter', v = 'pointer'), y = f == null ? h : ai(f), E = p == null ? h : ai(p), h = new m(x, v + 'leave', f, t, c), h.target = y, h.relatedTarget = E, x = null, Er(c) === u && (m = new m(g, v + 'enter', p, t, c), m.target = E, m.relatedTarget = y, x = m), y = x, f && p)t: { for (m = f, g = p, v = 0, E = m; E; E = jr(E))v++; for (E = 0, x = g; x; x = jr(x))E++; for (;v - E > 0;)m = jr(m), v--; for (;E - v > 0;)g = jr(g), E--; for (;v--;) { if (m === g || g !== null && m === g.alternate) break t; m = jr(m), g = jr(g) }m = null } else m = null; f !== null && ff(d, h, f, m, !1), p !== null && y !== null && ff(d, y, p, m, !0) } }e: { if (h = u ? ai(u) : window, f = h.nodeName && h.nodeName.toLowerCase(), f === 'select' || f === 'input' && h.type === 'file') var T = NS; else if (sf(h)) if (Cg)T = GS; else { T = BS; var w = US } else (f = h.nodeName) && f.toLowerCase() === 'input' && (h.type === 'checkbox' || h.type === 'radio') && (T = $S); if (T && (T = T(n, u))) { wg(d, T, t, c); break e }w && w(n, h, u), n === 'focusout' && (w = h._wrapperState) && w.controlled && h.type === 'number' && Gu(h, 'number', h.value) } switch (w = u ? ai(u) : window, n) { case 'focusin':(sf(w) || w.contentEditable === 'true') && (si = w, Zu = u, As = null); break; case 'focusout':As = Zu = si = null; break; case 'mousedown':ec = !0; break; case 'contextmenu':case 'mouseup':case 'dragend':ec = !1, cf(d, t, c); break; case 'selectionchange':if (KS) break; case 'keydown':case 'keyup':cf(d, t, c) } let L; if (wd)e: { switch (n) { case 'compositionstart':var A = 'onCompositionStart'; break e; case 'compositionend':A = 'onCompositionEnd'; break e; case 'compositionupdate':A = 'onCompositionUpdate'; break e }A = void 0 } else ii ? Rg(n, t) && (A = 'onCompositionEnd') : n === 'keydown' && t.keyCode === 229 && (A = 'onCompositionStart'); A && (Lg && t.locale !== 'ko' && (ii || A !== 'onCompositionStart' ? A === 'onCompositionEnd' && ii && (L = xg()) : (Yn = c, Ld = 'value' in Yn ? Yn.value : Yn.textContent, ii = !0)), w = Ia(u, A), w.length > 0 && (A = new ef(A, n, null, t, c), d.push({ event: A, listeners: w }), L ? A.data = L : (L = Ag(t), L !== null && (A.data = L)))), (L = PS ? bS(n, t) : OS(n, t)) && (u = Ia(u, 'onBeforeInput'), u.length > 0 && (c = new ef('onBeforeInput', 'beforeinput', null, t, c), d.push({ event: c, listeners: u }), c.data = L)) }Ng(d, e) }) } function $s (n, e, t) { return { instance: n, listener: e, currentTarget: t } } function Ia (n, e) { for (var t = e + 'Capture', r = []; n !== null;) { let i = n; let s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = bs(n, t), s != null && r.unshift($s(n, s, i)), s = bs(n, e), s != null && r.push($s(n, s, i))), n = n.return } return r } function jr (n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5); return n || null } function ff (n, e, t, r, i) { for (var s = e._reactName, o = []; t !== null && t !== r;) { let a = t; let l = a.alternate; const u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = bs(t, s), l != null && o.unshift($s(t, l, a))) : i || (l = bs(t, s), l != null && o.push($s(t, l, a)))), t = t.return }o.length !== 0 && n.push({ event: e, listeners: o }) } const YS = /\r\n?/g; const qS = /\u0000|\uFFFD/g; function pf (n) {
  return (typeof n === 'string' ? n : '' + n).replace(YS, `
`).replace(qS, '')
} function Oo (n, e, t) { if (e = pf(e), pf(n) !== e && t) throw Error(U(425)) } function _a () {} let tc = null; let nc = null; function rc (n, e) { return n === 'textarea' || n === 'noscript' || typeof e.children === 'string' || typeof e.children === 'number' || typeof e.dangerouslySetInnerHTML === 'object' && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } const ic = typeof setTimeout === 'function' ? setTimeout : void 0; const QS = typeof clearTimeout === 'function' ? clearTimeout : void 0; const mf = typeof Promise === 'function' ? Promise : void 0; const XS = typeof queueMicrotask === 'function' ? queueMicrotask : typeof mf < 'u' ? function (n) { return mf.resolve(null).then(n).catch(JS) } : ic; function JS (n) { setTimeout(function () { throw n }) } function ql (n, e) { let t = e; let r = 0; do { const i = t.nextSibling; if (n.removeChild(t), i && i.nodeType === 8) if (t = i.data, t === '/$') { if (r === 0) { n.removeChild(i), Ms(e); return }r-- } else t !== '$' && t !== '$?' && t !== '$!' || r++; t = i } while (t); Ms(e) } function er (n) { for (;n != null; n = n.nextSibling) { let e = n.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = n.data, e === '$' || e === '$!' || e === '$?') break; if (e === '/$') return null } } return n } function gf (n) { n = n.previousSibling; for (let e = 0; n;) { if (n.nodeType === 8) { const t = n.data; if (t === '$' || t === '$!' || t === '$?') { if (e === 0) return n; e-- } else t === '/$' && e++ }n = n.previousSibling } return null } const Zi = Math.random().toString(36).slice(2); const ln = '__reactFiber$' + Zi; const Gs = '__reactProps$' + Zi; var Cn = '__reactContainer$' + Zi; var sc = '__reactEvents$' + Zi; const ZS = '__reactListeners$' + Zi; const eT = '__reactHandles$' + Zi; function Er (n) { let e = n[ln]; if (e) return e; for (let t = n.parentNode; t;) { if (e = t[Cn] || t[ln]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n = gf(n); n !== null;) { if (t = n[ln]) return t; n = gf(n) } return e }n = t, t = n.parentNode } return null } function vo (n) { return n = n[ln] || n[Cn], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n } function ai (n) { if (n.tag === 5 || n.tag === 6) return n.stateNode; throw Error(U(33)) } function dl (n) { return n[Gs] || null } const oc = []; let li = -1; function ur (n) { return { current: n } } function me (n) { li < 0 || (n.current = oc[li], oc[li] = null, li--) } function he (n, e) { li++, oc[li] = n.current, n.current = e } const ar = {}; const Ze = ur(ar); const vt = ur(!1); let Or = ar; function Bi (n, e) { const t = n.type.contextTypes; if (!t) return ar; const r = n.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; const i = {}; let s; for (s in t)i[s] = e[s]; return r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = i), i } function Et (n) { return n = n.childContextTypes, n != null } function Da () { me(vt), me(Ze) } function yf (n, e, t) { if (Ze.current !== ar) throw Error(U(168)); he(Ze, e), he(vt, t) } function Bg (n, e, t) { let r = n.stateNode; if (e = e.childContextTypes, typeof r.getChildContext !== 'function') return t; r = r.getChildContext(); for (const i in r) if (!(i in e)) throw Error(U(108, UE(n) || 'Unknown', i)); return Te({}, t, r) } function ka (n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || ar, Or = Ze.current, he(Ze, n), he(vt, vt.current), !0 } function vf (n, e, t) { const r = n.stateNode; if (!r) throw Error(U(169)); t ? (n = Bg(n, e, Or), r.__reactInternalMemoizedMergedChildContext = n, me(vt), me(Ze), he(Ze, n)) : me(vt), he(vt, t) } let Tn = null; let hl = !1; let Ql = !1; function $g (n) { Tn === null ? Tn = [n] : Tn.push(n) } function tT (n) { hl = !0, $g(n) } function cr () { if (!Ql && Tn !== null) { Ql = !0; let n = 0; const e = le; try { const t = Tn; for (le = 1; n < t.length; n++) { let r = t[n]; do r = r(!0); while (r !== null) }Tn = null, hl = !1 } catch (i) { throw Tn !== null && (Tn = Tn.slice(n + 1)), dg(Ed, cr), i } finally { le = e, Ql = !1 } } return null } const ui = []; let ci = 0; let Pa = null; let ba = 0; const Ot = []; let Ft = 0; let Fr = null; let Ln = 1; let Rn = ''; function gr (n, e) { ui[ci++] = ba, ui[ci++] = Pa, Pa = n, ba = e } function Gg (n, e, t) { Ot[Ft++] = Ln, Ot[Ft++] = Rn, Ot[Ft++] = Fr, Fr = n; let r = Ln; n = Rn; let i = 32 - qt(r) - 1; r &= ~(1 << i), t += 1; let s = 32 - qt(e) + i; if (s > 30) { const o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Ln = 1 << 32 - qt(e) + i | t << i | r, Rn = s + n } else Ln = 1 << s | t << i | r, Rn = n } function Id (n) { n.return !== null && (gr(n, 1), Gg(n, 1, 0)) } function _d (n) { for (;n === Pa;)Pa = ui[--ci], ui[ci] = null, ba = ui[--ci], ui[ci] = null; for (;n === Fr;)Fr = Ot[--Ft], Ot[Ft] = null, Rn = Ot[--Ft], Ot[Ft] = null, Ln = Ot[--Ft], Ot[Ft] = null } let wt = null; let At = null; let ge = !1; let Wt = null; function Vg (n, e) { const t = Mt(5, null, null, 0); t.elementType = 'DELETED', t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t) } function Ef (n, e) { switch (n.tag) { case 5:var t = n.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, wt = n, At = er(e.firstChild), !0) : !1; case 6:return e = n.pendingProps === '' || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, wt = n, At = null, !0) : !1; case 13:return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Fr !== null ? { id: Ln, overflow: Rn } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = Mt(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, wt = n, At = null, !0) : !1; default:return !1 } } function ac (n) { return (n.mode & 1) !== 0 && (n.flags & 128) === 0 } function lc (n) { if (ge) { let e = At; if (e) { const t = e; if (!Ef(n, e)) { if (ac(n)) throw Error(U(418)); e = er(t.nextSibling); const r = wt; e && Ef(n, e) ? Vg(r, t) : (n.flags = n.flags & -4097 | 2, ge = !1, wt = n) } } else { if (ac(n)) throw Error(U(418)); n.flags = n.flags & -4097 | 2, ge = !1, wt = n } } } function Sf (n) { for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;)n = n.return; wt = n } function Fo (n) { if (n !== wt) return !1; if (!ge) return Sf(n), ge = !0, !1; let e; if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== 'head' && e !== 'body' && !rc(n.type, n.memoizedProps)), e && (e = At)) { if (ac(n)) throw Hg(), Error(U(418)); for (;e;)Vg(n, e), e = er(e.nextSibling) } if (Sf(n), n.tag === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(U(317)); e: { for (n = n.nextSibling, e = 0; n;) { if (n.nodeType === 8) { const t = n.data; if (t === '/$') { if (e === 0) { At = er(n.nextSibling); break e }e-- } else t !== '$' && t !== '$!' && t !== '$?' || e++ }n = n.nextSibling }At = null } } else At = wt ? er(n.stateNode.nextSibling) : null; return !0 } function Hg () { for (let n = At; n;)n = er(n.nextSibling) } function $i () { At = wt = null, ge = !1 } function Dd (n) { Wt === null ? Wt = [n] : Wt.push(n) } const nT = Dn.ReactCurrentBatchConfig; function us (n, e, t) { if (n = t.ref, n !== null && typeof n !== 'function' && typeof n !== 'object') { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(U(309)); var r = t.stateNode } if (!r) throw Error(U(147, n)); const i = r; const s = '' + n; return e !== null && e.ref !== null && typeof e.ref === 'function' && e.ref._stringRef === s ? e.ref : (e = function (o) { const a = i.refs; o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof n !== 'string') throw Error(U(284)); if (!t._owner) throw Error(U(290, n)) } return n } function Mo (n, e) { throw n = Object.prototype.toString.call(e), Error(U(31, n === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : n)) } function Tf (n) { const e = n._init; return e(n._payload) } function Kg (n) { function e (g, v) { if (n) { const E = g.deletions; E === null ? (g.deletions = [v], g.flags |= 16) : E.push(v) } } function t (g, v) { if (!n) return null; for (;v !== null;)e(g, v), v = v.sibling; return null } function r (g, v) { for (g = new Map(); v !== null;)v.key !== null ? g.set(v.key, v) : g.set(v.index, v), v = v.sibling; return g } function i (g, v) { return g = ir(g, v), g.index = 0, g.sibling = null, g } function s (g, v, E) { return g.index = E, n ? (E = g.alternate, E !== null ? (E = E.index, E < v ? (g.flags |= 2, v) : E) : (g.flags |= 2, v)) : (g.flags |= 1048576, v) } function o (g) { return n && g.alternate === null && (g.flags |= 2), g } function a (g, v, E, x) { return v === null || v.tag !== 6 ? (v = ru(E, g.mode, x), v.return = g, v) : (v = i(v, E), v.return = g, v) } function l (g, v, E, x) { const T = E.type; return T === ri ? c(g, v, E.props.children, x, E.key) : v !== null && (v.elementType === T || typeof T === 'object' && T !== null && T.$$typeof === Fn && Tf(T) === v.type) ? (x = i(v, E.props), x.ref = us(g, v, E), x.return = g, x) : (x = ca(E.type, E.key, E.props, null, g.mode, x), x.ref = us(g, v, E), x.return = g, x) } function u (g, v, E, x) { return v === null || v.tag !== 4 || v.stateNode.containerInfo !== E.containerInfo || v.stateNode.implementation !== E.implementation ? (v = iu(E, g.mode, x), v.return = g, v) : (v = i(v, E.children || []), v.return = g, v) } function c (g, v, E, x, T) { return v === null || v.tag !== 7 ? (v = Pr(E, g.mode, x, T), v.return = g, v) : (v = i(v, E), v.return = g, v) } function d (g, v, E) { if (typeof v === 'string' && v !== '' || typeof v === 'number') return v = ru('' + v, g.mode, E), v.return = g, v; if (typeof v === 'object' && v !== null) { switch (v.$$typeof) { case Ao:return E = ca(v.type, v.key, v.props, null, g.mode, E), E.ref = us(g, null, v), E.return = g, E; case ni:return v = iu(v, g.mode, E), v.return = g, v; case Fn:var x = v._init; return d(g, x(v._payload), E) } if (gs(v) || is(v)) return v = Pr(v, g.mode, E, null), v.return = g, v; Mo(g, v) } return null } function h (g, v, E, x) { let T = v !== null ? v.key : null; if (typeof E === 'string' && E !== '' || typeof E === 'number') return T !== null ? null : a(g, v, '' + E, x); if (typeof E === 'object' && E !== null) { switch (E.$$typeof) { case Ao:return E.key === T ? l(g, v, E, x) : null; case ni:return E.key === T ? u(g, v, E, x) : null; case Fn:return T = E._init, h(g, v, T(E._payload), x) } if (gs(E) || is(E)) return T !== null ? null : c(g, v, E, x, null); Mo(g, E) } return null } function f (g, v, E, x, T) { if (typeof x === 'string' && x !== '' || typeof x === 'number') return g = g.get(E) || null, a(v, g, '' + x, T); if (typeof x === 'object' && x !== null) { switch (x.$$typeof) { case Ao:return g = g.get(x.key === null ? E : x.key) || null, l(v, g, x, T); case ni:return g = g.get(x.key === null ? E : x.key) || null, u(v, g, x, T); case Fn:var w = x._init; return f(g, v, E, w(x._payload), T) } if (gs(x) || is(x)) return g = g.get(E) || null, c(v, g, x, T, null); Mo(v, x) } return null } function p (g, v, E, x) { for (var T = null, w = null, L = v, A = v = 0, P = null; L !== null && A < E.length; A++) { L.index > A ? (P = L, L = null) : P = L.sibling; const _ = h(g, L, E[A], x); if (_ === null) { L === null && (L = P); break }n && L && _.alternate === null && e(g, L), v = s(_, v, A), w === null ? T = _ : w.sibling = _, w = _, L = P } if (A === E.length) return t(g, L), ge && gr(g, A), T; if (L === null) { for (;A < E.length; A++)L = d(g, E[A], x), L !== null && (v = s(L, v, A), w === null ? T = L : w.sibling = L, w = L); return ge && gr(g, A), T } for (L = r(g, L); A < E.length; A++)P = f(L, g, A, E[A], x), P !== null && (n && P.alternate !== null && L.delete(P.key === null ? A : P.key), v = s(P, v, A), w === null ? T = P : w.sibling = P, w = P); return n && L.forEach(function (F) { return e(g, F) }), ge && gr(g, A), T } function m (g, v, E, x) { let T = is(E); if (typeof T !== 'function') throw Error(U(150)); if (E = T.call(E), E == null) throw Error(U(151)); for (var w = T = null, L = v, A = v = 0, P = null, _ = E.next(); L !== null && !_.done; A++, _ = E.next()) { L.index > A ? (P = L, L = null) : P = L.sibling; const F = h(g, L, _.value, x); if (F === null) { L === null && (L = P); break }n && L && F.alternate === null && e(g, L), v = s(F, v, A), w === null ? T = F : w.sibling = F, w = F, L = P } if (_.done) return t(g, L), ge && gr(g, A), T; if (L === null) { for (;!_.done; A++, _ = E.next())_ = d(g, _.value, x), _ !== null && (v = s(_, v, A), w === null ? T = _ : w.sibling = _, w = _); return ge && gr(g, A), T } for (L = r(g, L); !_.done; A++, _ = E.next())_ = f(L, g, A, _.value, x), _ !== null && (n && _.alternate !== null && L.delete(_.key === null ? A : _.key), v = s(_, v, A), w === null ? T = _ : w.sibling = _, w = _); return n && L.forEach(function ($) { return e(g, $) }), ge && gr(g, A), T } function y (g, v, E, x) { if (typeof E === 'object' && E !== null && E.type === ri && E.key === null && (E = E.props.children), typeof E === 'object' && E !== null) { switch (E.$$typeof) { case Ao:e: { for (var T = E.key, w = v; w !== null;) { if (w.key === T) { if (T = E.type, T === ri) { if (w.tag === 7) { t(g, w.sibling), v = i(w, E.props.children), v.return = g, g = v; break e } } else if (w.elementType === T || typeof T === 'object' && T !== null && T.$$typeof === Fn && Tf(T) === w.type) { t(g, w.sibling), v = i(w, E.props), v.ref = us(g, w, E), v.return = g, g = v; break e }t(g, w); break } else e(g, w); w = w.sibling }E.type === ri ? (v = Pr(E.props.children, g.mode, x, E.key), v.return = g, g = v) : (x = ca(E.type, E.key, E.props, null, g.mode, x), x.ref = us(g, v, E), x.return = g, g = x) } return o(g); case ni:e: { for (w = E.key; v !== null;) { if (v.key === w) if (v.tag === 4 && v.stateNode.containerInfo === E.containerInfo && v.stateNode.implementation === E.implementation) { t(g, v.sibling), v = i(v, E.children || []), v.return = g, g = v; break e } else { t(g, v); break } else e(g, v); v = v.sibling }v = iu(E, g.mode, x), v.return = g, g = v } return o(g); case Fn:return w = E._init, y(g, v, w(E._payload), x) } if (gs(E)) return p(g, v, E, x); if (is(E)) return m(g, v, E, x); Mo(g, E) } return typeof E === 'string' && E !== '' || typeof E === 'number' ? (E = '' + E, v !== null && v.tag === 6 ? (t(g, v.sibling), v = i(v, E), v.return = g, g = v) : (t(g, v), v = ru(E, g.mode, x), v.return = g, g = v), o(g)) : t(g, v) } return y } const Gi = Kg(!0); const jg = Kg(!1); const Oa = ur(null); let Fa = null; let di = null; let kd = null; function Pd () { kd = di = Fa = null } function bd (n) { const e = Oa.current; me(Oa), n._currentValue = e } function uc (n, e, t) { for (;n !== null;) { const r = n.alternate; if ((n.childLanes & e) !== e ? (n.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), n === t) break; n = n.return } } function Ei (n, e) { Fa = n, kd = di = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (yt = !0), n.firstContext = null) } function Ut (n) { const e = n._currentValue; if (kd !== n) if (n = { context: n, memoizedValue: e, next: null }, di === null) { if (Fa === null) throw Error(U(308)); di = n, Fa.dependencies = { lanes: 0, firstContext: n } } else di = di.next = n; return e } let Sr = null; function Od (n) { Sr === null ? Sr = [n] : Sr.push(n) } function zg (n, e, t, r) { const i = e.interleaved; return i === null ? (t.next = t, Od(e)) : (t.next = i.next, i.next = t), e.interleaved = t, In(n, r) } function In (n, e) { n.lanes |= e; let t = n.alternate; for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;)n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return; return t.tag === 3 ? t.stateNode : null } let Mn = !1; function Fd (n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Wg (n, e) { n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function An (n, e) { return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null } } function tr (n, e, t) { let r = n.updateQueue; if (r === null) return null; if (r = r.shared, oe & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, In(n, t) } return i = r.interleaved, i === null ? (e.next = e, Od(r)) : (e.next = i.next, i.next = e), r.interleaved = e, In(n, t) } function ia (n, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { let r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, Sd(n, t) } } function xf (n, e) { let t = n.updateQueue; let r = n.alternate; if (r !== null && (r = r.updateQueue, t === r)) { let i = null; let s = null; if (t = t.firstBaseUpdate, t !== null) { do { const o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; s === null ? i = s = o : s = s.next = o, t = t.next } while (t !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; t = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, n.updateQueue = t; return }n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e } function Ma (n, e, t, r) { let i = n.updateQueue; Mn = !1; let s = i.firstBaseUpdate; let o = i.lastBaseUpdate; let a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a; var u = l.next; l.next = null, o === null ? s = u : o.next = u, o = l; var c = n.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (s !== null) { let d = i.baseState; o = 0, c = u = l = null, a = s; do { let h = a.lane; let f = a.eventTime; if ((r & h) === h) { c !== null && (c = c.next = { eventTime: f, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { let p = n; const m = a; switch (h = e, f = t, m.tag) { case 1:if (p = m.payload, typeof p === 'function') { d = p.call(f, d, h); break e }d = p; break e; case 3:p.flags = p.flags & -65537 | 128; case 0:if (p = m.payload, h = typeof p === 'function' ? p.call(f, d, h) : p, h == null) break e; d = Te({}, d, h); break e; case 2:Mn = !0 } }a.callback !== null && a.lane !== 0 && (n.flags |= 64, h = i.effects, h === null ? i.effects = [a] : h.push(a)) } else f = { eventTime: f, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = f, l = d) : c = c.next = f, o |= h; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; h = a, a = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } while (!0); if (c === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) { i = e; do o |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); Nr |= o, n.lanes = o, n.memoizedState = d } } function Lf (n, e, t) { if (n = e.effects, e.effects = null, n !== null) for (e = 0; e < n.length; e++) { let r = n[e]; const i = r.callback; if (i !== null) { if (r.callback = null, r = t, typeof i !== 'function') throw Error(U(191, i)); i.call(r) } } } const Eo = {}; const hn = ur(Eo); const Vs = ur(Eo); const Hs = ur(Eo); function Tr (n) { if (n === Eo) throw Error(U(174)); return n } function Md (n, e) { switch (he(Hs, e), he(Vs, n), he(hn, Eo), n = e.nodeType, n) { case 9:case 11:e = (e = e.documentElement) ? e.namespaceURI : Hu(null, ''); break; default:n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = Hu(e, n) }me(hn), he(hn, e) } function Vi () { me(hn), me(Vs), me(Hs) } function Yg (n) { Tr(Hs.current); const e = Tr(hn.current); const t = Hu(e, n.type); e !== t && (he(Vs, n), he(hn, t)) } function Nd (n) { Vs.current === n && (me(hn), me(Vs)) } const Ee = ur(0); function Na (n) { for (let e = n; e !== null;) { if (e.tag === 13) { let t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === '$?' || t.data === '$!')) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break; for (;e.sibling === null;) { if (e.return === null || e.return === n) return null; e = e.return }e.sibling.return = e.return, e = e.sibling } return null } const Xl = []; function Ud () { for (let n = 0; n < Xl.length; n++)Xl[n]._workInProgressVersionPrimary = null; Xl.length = 0 } const sa = Dn.ReactCurrentDispatcher; const Jl = Dn.ReactCurrentBatchConfig; let Mr = 0; let Se = null; let be = null; let Ne = null; let Ua = !1; let ws = !1; let Ks = 0; let rT = 0; function Ye () { throw Error(U(321)) } function Bd (n, e) { if (e === null) return !1; for (let t = 0; t < e.length && t < n.length; t++) if (!Xt(n[t], e[t])) return !1; return !0 } function $d (n, e, t, r, i, s) { if (Mr = s, Se = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, sa.current = n === null || n.memoizedState === null ? aT : lT, n = t(r, i), ws) { s = 0; do { if (ws = !1, Ks = 0, s >= 25) throw Error(U(301)); s += 1, Ne = be = null, e.updateQueue = null, sa.current = uT, n = t(r, i) } while (ws) } if (sa.current = Ba, e = be !== null && be.next !== null, Mr = 0, Ne = be = Se = null, Ua = !1, e) throw Error(U(300)); return n } function Gd () { const n = Ks !== 0; return Ks = 0, n } function en () { const n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ne === null ? Se.memoizedState = Ne = n : Ne = Ne.next = n, Ne } function Bt () { if (be === null) { var n = Se.alternate; n = n !== null ? n.memoizedState : null } else n = be.next; const e = Ne === null ? Se.memoizedState : Ne.next; if (e !== null)Ne = e, be = n; else { if (n === null) throw Error(U(310)); be = n, n = { memoizedState: be.memoizedState, baseState: be.baseState, baseQueue: be.baseQueue, queue: be.queue, next: null }, Ne === null ? Se.memoizedState = Ne = n : Ne = Ne.next = n } return Ne } function js (n, e) { return typeof e === 'function' ? e(n) : e } function Zl (n) { const e = Bt(); const t = e.queue; if (t === null) throw Error(U(311)); t.lastRenderedReducer = n; let r = be; let i = r.baseQueue; let s = t.pending; if (s !== null) { if (i !== null) { var o = i.next; i.next = s.next, s.next = o }r.baseQueue = i = s, t.pending = null } if (i !== null) { s = i.next, r = r.baseState; let a = o = null; let l = null; let u = s; do { const c = u.lane; if ((Mr & c) === c)l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : n(r, u.action); else { const d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = r) : l = l.next = d, Se.lanes |= c, Nr |= c }u = u.next } while (u !== null && u !== s); l === null ? o = r : l.next = a, Xt(r, e.memoizedState) || (yt = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, t.lastRenderedState = r } if (n = t.interleaved, n !== null) { i = n; do s = i.lane, Se.lanes |= s, Nr |= s, i = i.next; while (i !== n) } else i === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function eu (n) { const e = Bt(); const t = e.queue; if (t === null) throw Error(U(311)); t.lastRenderedReducer = n; const r = t.dispatch; let i = t.pending; let s = e.memoizedState; if (i !== null) { t.pending = null; let o = i = i.next; do s = n(s, o.action), o = o.next; while (o !== i); Xt(s, e.memoizedState) || (yt = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s } return [s, r] } function qg () {} function Qg (n, e) { const t = Se; let r = Bt(); const i = e(); const s = !Xt(r.memoizedState, i); if (s && (r.memoizedState = i, yt = !0), r = r.queue, Vd(Zg.bind(null, t, r, n), [n]), r.getSnapshot !== e || s || Ne !== null && Ne.memoizedState.tag & 1) { if (t.flags |= 2048, zs(9, Jg.bind(null, t, r, i, e), void 0, null), Be === null) throw Error(U(349)); Mr & 30 || Xg(t, e, i) } return i } function Xg (n, e, t) { n.flags |= 16384, n = { getSnapshot: e, value: t }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n)) } function Jg (n, e, t, r) { e.value = t, e.getSnapshot = r, e0(e) && t0(n) } function Zg (n, e, t) { return t(function () { e0(e) && t0(n) }) } function e0 (n) { const e = n.getSnapshot; n = n.value; try { const t = e(); return !Xt(n, t) } catch { return !0 } } function t0 (n) { const e = In(n, 1); e !== null && Qt(e, n, 1, -1) } function Rf (n) { const e = en(); return typeof n === 'function' && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: js, lastRenderedState: n }, e.queue = n, n = n.dispatch = oT.bind(null, Se, n), [e.memoizedState, n] } function zs (n, e, t, r) { return n = { tag: n, create: e, destroy: t, deps: r, next: null }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (r = t.next, t.next = n, n.next = r, e.lastEffect = n)), n } function n0 () { return Bt().memoizedState } function oa (n, e, t, r) { const i = en(); Se.flags |= n, i.memoizedState = zs(1 | e, t, void 0, r === void 0 ? null : r) } function fl (n, e, t, r) { const i = Bt(); r = r === void 0 ? null : r; let s = void 0; if (be !== null) { const o = be.memoizedState; if (s = o.destroy, r !== null && Bd(r, o.deps)) { i.memoizedState = zs(e, t, s, r); return } }Se.flags |= n, i.memoizedState = zs(1 | e, t, s, r) } function Af (n, e) { return oa(8390656, 8, n, e) } function Vd (n, e) { return fl(2048, 8, n, e) } function r0 (n, e) { return fl(4, 2, n, e) } function i0 (n, e) { return fl(4, 4, n, e) } function s0 (n, e) { if (typeof e === 'function') return n = n(), e(n), function () { e(null) }; if (e != null) return n = n(), e.current = n, function () { e.current = null } } function o0 (n, e, t) { return t = t != null ? t.concat([n]) : null, fl(4, 4, s0.bind(null, e, n), t) } function Hd () {} function a0 (n, e) { const t = Bt(); e = e === void 0 ? null : e; const r = t.memoizedState; return r !== null && e !== null && Bd(e, r[1]) ? r[0] : (t.memoizedState = [n, e], n) } function l0 (n, e) { const t = Bt(); e = e === void 0 ? null : e; const r = t.memoizedState; return r !== null && e !== null && Bd(e, r[1]) ? r[0] : (n = n(), t.memoizedState = [n, e], n) } function u0 (n, e, t) { return Mr & 21 ? (Xt(t, e) || (t = pg(), Se.lanes |= t, Nr |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, yt = !0), n.memoizedState = t) } function iT (n, e) { const t = le; le = t !== 0 && t < 4 ? t : 4, n(!0); const r = Jl.transition; Jl.transition = {}; try { n(!1), e() } finally { le = t, Jl.transition = r } } function c0 () { return Bt().memoizedState } function sT (n, e, t) { const r = rr(n); if (t = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }, d0(n))h0(e, t); else if (t = zg(n, e, t, r), t !== null) { const i = ot(); Qt(t, n, r, i), f0(t, e, r) } } function oT (n, e, t) { const r = rr(n); let i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }; if (d0(n))h0(e, i); else { let s = n.alternate; if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { const o = e.lastRenderedState; const a = s(o, t); if (i.hasEagerState = !0, i.eagerState = a, Xt(a, o)) { const l = e.interleaved; l === null ? (i.next = i, Od(e)) : (i.next = l.next, l.next = i), e.interleaved = i; return } } catch {} finally {}t = zg(n, e, i, r), t !== null && (i = ot(), Qt(t, n, r, i), f0(t, e, r)) } } function d0 (n) { const e = n.alternate; return n === Se || e !== null && e === Se } function h0 (n, e) { ws = Ua = !0; const t = n.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e } function f0 (n, e, t) { if (t & 4194240) { let r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, Sd(n, t) } } var Ba = { readContext: Ut, useCallback: Ye, useContext: Ye, useEffect: Ye, useImperativeHandle: Ye, useInsertionEffect: Ye, useLayoutEffect: Ye, useMemo: Ye, useReducer: Ye, useRef: Ye, useState: Ye, useDebugValue: Ye, useDeferredValue: Ye, useTransition: Ye, useMutableSource: Ye, useSyncExternalStore: Ye, useId: Ye, unstable_isNewReconciler: !1 }; var aT = { readContext: Ut, useCallback: function (n, e) { return en().memoizedState = [n, e === void 0 ? null : e], n }, useContext: Ut, useEffect: Af, useImperativeHandle: function (n, e, t) { return t = t != null ? t.concat([n]) : null, oa(4194308, 4, s0.bind(null, e, n), t) }, useLayoutEffect: function (n, e) { return oa(4194308, 4, n, e) }, useInsertionEffect: function (n, e) { return oa(4, 2, n, e) }, useMemo: function (n, e) { const t = en(); return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n }, useReducer: function (n, e, t) { const r = en(); return e = t !== void 0 ? t(e) : e, r.memoizedState = r.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, r.queue = n, n = n.dispatch = sT.bind(null, Se, n), [r.memoizedState, n] }, useRef: function (n) { const e = en(); return n = { current: n }, e.memoizedState = n }, useState: Rf, useDebugValue: Hd, useDeferredValue: function (n) { return en().memoizedState = n }, useTransition: function () { let n = Rf(!1); const e = n[0]; return n = iT.bind(null, n[1]), en().memoizedState = n, [e, n] }, useMutableSource: function () {}, useSyncExternalStore: function (n, e, t) { const r = Se; const i = en(); if (ge) { if (t === void 0) throw Error(U(407)); t = t() } else { if (t = e(), Be === null) throw Error(U(349)); Mr & 30 || Xg(r, e, t) }i.memoizedState = t; const s = { value: t, getSnapshot: e }; return i.queue = s, Af(Zg.bind(null, r, s, n), [n]), r.flags |= 2048, zs(9, Jg.bind(null, r, s, t, e), void 0, null), t }, useId: function () { const n = en(); let e = Be.identifierPrefix; if (ge) { var t = Rn; const r = Ln; t = (r & ~(1 << 32 - qt(r) - 1)).toString(32) + t, e = ':' + e + 'R' + t, t = Ks++, t > 0 && (e += 'H' + t.toString(32)), e += ':' } else t = rT++, e = ':' + e + 'r' + t.toString(32) + ':'; return n.memoizedState = e }, unstable_isNewReconciler: !1 }; var lT = { readContext: Ut, useCallback: a0, useContext: Ut, useEffect: Vd, useImperativeHandle: o0, useInsertionEffect: r0, useLayoutEffect: i0, useMemo: l0, useReducer: Zl, useRef: n0, useState: function () { return Zl(js) }, useDebugValue: Hd, useDeferredValue: function (n) { const e = Bt(); return u0(e, be.memoizedState, n) }, useTransition: function () { const n = Zl(js)[0]; const e = Bt().memoizedState; return [n, e] }, useMutableSource: qg, useSyncExternalStore: Qg, useId: c0, unstable_isNewReconciler: !1 }; var uT = { readContext: Ut, useCallback: a0, useContext: Ut, useEffect: Vd, useImperativeHandle: o0, useInsertionEffect: r0, useLayoutEffect: i0, useMemo: l0, useReducer: eu, useRef: n0, useState: function () { return eu(js) }, useDebugValue: Hd, useDeferredValue: function (n) { const e = Bt(); return be === null ? e.memoizedState = n : u0(e, be.memoizedState, n) }, useTransition: function () { const n = eu(js)[0]; const e = Bt().memoizedState; return [n, e] }, useMutableSource: qg, useSyncExternalStore: Qg, useId: c0, unstable_isNewReconciler: !1 }; function Kt (n, e) { if (n && n.defaultProps) { e = Te({}, e), n = n.defaultProps; for (const t in n)e[t] === void 0 && (e[t] = n[t]); return e } return e } function cc (n, e, t, r) { e = n.memoizedState, t = t(r, e), t = t == null ? e : Te({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t) } const pl = { isMounted: function (n) { return (n = n._reactInternals) ? Vr(n) === n : !1 }, enqueueSetState: function (n, e, t) { n = n._reactInternals; const r = ot(); const i = rr(n); const s = An(r, i); s.payload = e, t != null && (s.callback = t), e = tr(n, s, i), e !== null && (Qt(e, n, i, r), ia(e, n, i)) }, enqueueReplaceState: function (n, e, t) { n = n._reactInternals; const r = ot(); const i = rr(n); const s = An(r, i); s.tag = 1, s.payload = e, t != null && (s.callback = t), e = tr(n, s, i), e !== null && (Qt(e, n, i, r), ia(e, n, i)) }, enqueueForceUpdate: function (n, e) { n = n._reactInternals; const t = ot(); const r = rr(n); const i = An(t, r); i.tag = 2, e != null && (i.callback = e), e = tr(n, i, r), e !== null && (Qt(e, n, r, t), ia(e, n, r)) } }; function wf (n, e, t, r, i, s, o) { return n = n.stateNode, typeof n.shouldComponentUpdate === 'function' ? n.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Us(t, r) || !Us(i, s) : !0 } function p0 (n, e, t) { let r = !1; let i = ar; let s = e.contextType; return typeof s === 'object' && s !== null ? s = Ut(s) : (i = Et(e) ? Or : Ze.current, r = e.contextTypes, s = (r = r != null) ? Bi(n, i) : ar), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = pl, n.stateNode = e, e._reactInternals = n, r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = i, n.__reactInternalMemoizedMaskedChildContext = s), e } function Cf (n, e, t, r) { n = e.state, typeof e.componentWillReceiveProps === 'function' && e.componentWillReceiveProps(t, r), typeof e.UNSAFE_componentWillReceiveProps === 'function' && e.UNSAFE_componentWillReceiveProps(t, r), e.state !== n && pl.enqueueReplaceState(e, e.state, null) } function dc (n, e, t, r) { const i = n.stateNode; i.props = t, i.state = n.memoizedState, i.refs = {}, Fd(n); let s = e.contextType; typeof s === 'object' && s !== null ? i.context = Ut(s) : (s = Et(e) ? Or : Ze.current, i.context = Bi(n, s)), i.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s === 'function' && (cc(n, e, s, t), i.state = n.memoizedState), typeof e.getDerivedStateFromProps === 'function' || typeof i.getSnapshotBeforeUpdate === 'function' || typeof i.UNSAFE_componentWillMount !== 'function' && typeof i.componentWillMount !== 'function' || (e = i.state, typeof i.componentWillMount === 'function' && i.componentWillMount(), typeof i.UNSAFE_componentWillMount === 'function' && i.UNSAFE_componentWillMount(), e !== i.state && pl.enqueueReplaceState(i, i.state, null), Ma(n, t, i, r), i.state = n.memoizedState), typeof i.componentDidMount === 'function' && (n.flags |= 4194308) } function Hi (n, e) {
  try { let t = ''; let r = e; do t += NE(r), r = r.return; while (r); var i = t } catch (s) {
    i = `
Error generating stack: ` + s.message + `
` + s.stack
  } return { value: n, source: e, stack: i, digest: null }
} function tu (n, e, t) { return { value: n, source: null, stack: t ?? null, digest: e ?? null } } function hc (n, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } const cT = typeof WeakMap === 'function' ? WeakMap : Map; function m0 (n, e, t) { t = An(-1, t), t.tag = 3, t.payload = { element: null }; const r = e.value; return t.callback = function () { Ga || (Ga = !0, xc = r), hc(n, e) }, t } function g0 (n, e, t) { t = An(-1, t), t.tag = 3; const r = n.type.getDerivedStateFromError; if (typeof r === 'function') { const i = e.value; t.payload = function () { return r(i) }, t.callback = function () { hc(n, e) } } const s = n.stateNode; return s !== null && typeof s.componentDidCatch === 'function' && (t.callback = function () { hc(n, e), typeof r !== 'function' && (nr === null ? nr = new Set([this]) : nr.add(this)); const o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : '' }) }), t } function If (n, e, t) { let r = n.pingCache; if (r === null) { r = n.pingCache = new cT(); var i = new Set(); r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set(), r.set(e, i)); i.has(t) || (i.add(t), n = RT.bind(null, n, e, t), e.then(n, n)) } function _f (n) { do { var e; if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n; n = n.return } while (n !== null); return null } function Df (n, e, t, r, i) { return n.mode & 1 ? (n.flags |= 65536, n.lanes = i, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = An(-1, 1), e.tag = 2, tr(t, e, 1))), t.lanes |= 1), n) } const dT = Dn.ReactCurrentOwner; var yt = !1; function st (n, e, t, r) { e.child = n === null ? jg(e, null, t, r) : Gi(e, n.child, t, r) } function kf (n, e, t, r, i) { t = t.render; const s = e.ref; return Ei(e, i), r = $d(n, e, t, r, s, i), t = Gd(), n !== null && !yt ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, _n(n, e, i)) : (ge && t && Id(e), e.flags |= 1, st(n, e, r, i), e.child) } function Pf (n, e, t, r, i) { if (n === null) { var s = t.type; return typeof s === 'function' && !Xd(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, y0(n, e, s, r, i)) : (n = ca(t.type, null, r, e, e.mode, i), n.ref = e.ref, n.return = e, e.child = n) } if (s = n.child, !(n.lanes & i)) { const o = s.memoizedProps; if (t = t.compare, t = t !== null ? t : Us, t(o, r) && n.ref === e.ref) return _n(n, e, i) } return e.flags |= 1, n = ir(s, r), n.ref = e.ref, n.return = e, e.child = n } function y0 (n, e, t, r, i) { if (n !== null) { const s = n.memoizedProps; if (Us(s, r) && n.ref === e.ref) if (yt = !1, e.pendingProps = r = s, (n.lanes & i) !== 0)n.flags & 131072 && (yt = !0); else return e.lanes = n.lanes, _n(n, e, i) } return fc(n, e, t, r, i) } function v0 (n, e, t) { let r = e.pendingProps; const i = r.children; const s = n !== null ? n.memoizedState : null; if (r.mode === 'hidden') if (!(e.mode & 1))e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, he(fi, Rt), Rt |= t; else { if (!(t & 1073741824)) return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, he(fi, Rt), Rt |= n, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : t, he(fi, Rt), Rt |= r } else s !== null ? (r = s.baseLanes | t, e.memoizedState = null) : r = t, he(fi, Rt), Rt |= r; return st(n, e, i, t), e.child } function E0 (n, e) { const t = e.ref; (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function fc (n, e, t, r, i) { let s = Et(t) ? Or : Ze.current; return s = Bi(e, s), Ei(e, i), t = $d(n, e, t, r, s, i), r = Gd(), n !== null && !yt ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, _n(n, e, i)) : (ge && r && Id(e), e.flags |= 1, st(n, e, t, i), e.child) } function bf (n, e, t, r, i) { if (Et(t)) { var s = !0; ka(e) } else s = !1; if (Ei(e, i), e.stateNode === null)aa(n, e), p0(e, t, r), dc(e, t, r, i), r = !0; else if (n === null) { var o = e.stateNode; var a = e.memoizedProps; o.props = a; var l = o.context; var u = t.contextType; typeof u === 'object' && u !== null ? u = Ut(u) : (u = Et(t) ? Or : Ze.current, u = Bi(e, u)); var c = t.getDerivedStateFromProps; var d = typeof c === 'function' || typeof o.getSnapshotBeforeUpdate === 'function'; d || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (a !== r || l !== u) && Cf(e, o, r, u), Mn = !1; var h = e.memoizedState; o.state = h, Ma(e, r, o, i), l = e.memoizedState, a !== r || h !== l || vt.current || Mn ? (typeof c === 'function' && (cc(e, t, c, r), l = e.memoizedState), (a = Mn || wf(e, t, a, r, h, l, u)) ? (d || typeof o.UNSAFE_componentWillMount !== 'function' && typeof o.componentWillMount !== 'function' || (typeof o.componentWillMount === 'function' && o.componentWillMount(), typeof o.UNSAFE_componentWillMount === 'function' && o.UNSAFE_componentWillMount()), typeof o.componentDidMount === 'function' && (e.flags |= 4194308)) : (typeof o.componentDidMount === 'function' && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount === 'function' && (e.flags |= 4194308), r = !1) } else { o = e.stateNode, Wg(n, e), a = e.memoizedProps, u = e.type === e.elementType ? a : Kt(e.type, a), o.props = u, d = e.pendingProps, h = o.context, l = t.contextType, typeof l === 'object' && l !== null ? l = Ut(l) : (l = Et(t) ? Or : Ze.current, l = Bi(e, l)); const f = t.getDerivedStateFromProps; (c = typeof f === 'function' || typeof o.getSnapshotBeforeUpdate === 'function') || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (a !== d || h !== l) && Cf(e, o, r, l), Mn = !1, h = e.memoizedState, o.state = h, Ma(e, r, o, i); let p = e.memoizedState; a !== d || h !== p || vt.current || Mn ? (typeof f === 'function' && (cc(e, t, f, r), p = e.memoizedState), (u = Mn || wf(e, t, u, r, h, p, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate !== 'function' && typeof o.componentWillUpdate !== 'function' || (typeof o.componentWillUpdate === 'function' && o.componentWillUpdate(r, p, l), typeof o.UNSAFE_componentWillUpdate === 'function' && o.UNSAFE_componentWillUpdate(r, p, l)), typeof o.componentDidUpdate === 'function' && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate === 'function' && (e.flags |= 1024)) : (typeof o.componentDidUpdate !== 'function' || a === n.memoizedProps && h === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || a === n.memoizedProps && h === n.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = p), o.props = r, o.state = p, o.context = l, r = u) : (typeof o.componentDidUpdate !== 'function' || a === n.memoizedProps && h === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || a === n.memoizedProps && h === n.memoizedState || (e.flags |= 1024), r = !1) } return pc(n, e, t, r, s, i) } function pc (n, e, t, r, i, s) { E0(n, e); const o = (e.flags & 128) !== 0; if (!r && !o) return i && vf(e, t, !1), _n(n, e, s); r = e.stateNode, dT.current = e; const a = o && typeof t.getDerivedStateFromError !== 'function' ? null : r.render(); return e.flags |= 1, n !== null && o ? (e.child = Gi(e, n.child, null, s), e.child = Gi(e, null, a, s)) : st(n, e, a, s), e.memoizedState = r.state, i && vf(e, t, !0), e.child } function S0 (n) { const e = n.stateNode; e.pendingContext ? yf(n, e.pendingContext, e.pendingContext !== e.context) : e.context && yf(n, e.context, !1), Md(n, e.containerInfo) } function Of (n, e, t, r, i) { return $i(), Dd(i), e.flags |= 256, st(n, e, t, r), e.child } const mc = { dehydrated: null, treeContext: null, retryLane: 0 }; function gc (n) { return { baseLanes: n, cachePool: null, transitions: null } } function T0 (n, e, t) { let r = e.pendingProps; let i = Ee.current; let s = !1; let o = (e.flags & 128) !== 0; let a; if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (i |= 1), he(Ee, i & 1), n === null) return lc(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === '$!' ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, n = r.fallback, s ? (r = e.mode, s = e.child, o = { mode: 'hidden', children: o }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = yl(o, r, 0, null), n = Pr(n, r, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = gc(t), e.memoizedState = mc, n) : Kd(e, o)); if (i = n.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return hT(n, e, o, r, a, i, t); if (s) { s = r.fallback, o = e.mode, i = n.child, a = i.sibling; const l = { mode: 'hidden', children: r.children }; return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = ir(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = ir(a, s) : (s = Pr(s, o, t, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = n.child.memoizedState, o = o === null ? gc(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n.childLanes & ~t, e.memoizedState = mc, r } return s = n.child, n = s.sibling, r = ir(s, { mode: 'visible', children: r.children }), !(e.mode & 1) && (r.lanes = t), r.return = e, r.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = r, e.memoizedState = null, r } function Kd (n, e) { return e = yl({ mode: 'visible', children: e }, n.mode, 0, null), e.return = n, n.child = e } function No (n, e, t, r) { return r !== null && Dd(r), Gi(e, n.child, null, t), n = Kd(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n } function hT (n, e, t, r, i, s, o) { if (t) return e.flags & 256 ? (e.flags &= -257, r = tu(Error(U(422))), No(n, e, o, r)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = yl({ mode: 'visible', children: r.children }, i, 0, null), s = Pr(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && Gi(e, n.child, null, o), e.child.memoizedState = gc(o), e.memoizedState = mc, s); if (!(e.mode & 1)) return No(n, e, o, null); if (i.data === '$!') { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, s = Error(U(419)), r = tu(s, r, void 0), No(n, e, o, r) } if (a = (o & n.childLanes) !== 0, yt || a) { if (r = Be, r !== null) { switch (o & -o) { case 4:i = 2; break; case 16:i = 8; break; case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:i = 32; break; case 536870912:i = 268435456; break; default:i = 0 }i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, In(n, i), Qt(r, n, i, -1)) } return Qd(), r = tu(Error(U(421))), No(n, e, o, r) } return i.data === '$?' ? (e.flags |= 128, e.child = n.child, e = AT.bind(null, n), i._reactRetry = e, null) : (n = s.treeContext, At = er(i.nextSibling), wt = e, ge = !0, Wt = null, n !== null && (Ot[Ft++] = Ln, Ot[Ft++] = Rn, Ot[Ft++] = Fr, Ln = n.id, Rn = n.overflow, Fr = e), e = Kd(e, r.children), e.flags |= 4096, e) } function Ff (n, e, t) { n.lanes |= e; const r = n.alternate; r !== null && (r.lanes |= e), uc(n.return, e, t) } function nu (n, e, t, r, i) { const s = n.memoizedState; s === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: t, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = t, s.tailMode = i) } function x0 (n, e, t) { let r = e.pendingProps; let i = r.revealOrder; const s = r.tail; if (st(n, e, r.children, t), r = Ee.current, r & 2)r = r & 1 | 2, e.flags |= 128; else { if (n !== null && n.flags & 128)e:for (n = e.child; n !== null;) { if (n.tag === 13)n.memoizedState !== null && Ff(n, t, e); else if (n.tag === 19)Ff(n, t, e); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (;n.sibling === null;) { if (n.return === null || n.return === e) break e; n = n.return }n.sibling.return = n.return, n = n.sibling }r &= 1 } if (he(Ee, r), !(e.mode & 1))e.memoizedState = null; else switch (i) { case 'forwards':for (t = e.child, i = null; t !== null;)n = t.alternate, n !== null && Na(n) === null && (i = t), t = t.sibling; t = i, t === null ? (i = e.child, e.child = null) : (i = t.sibling, t.sibling = null), nu(e, !1, i, t, s); break; case 'backwards':for (t = null, i = e.child, e.child = null; i !== null;) { if (n = i.alternate, n !== null && Na(n) === null) { e.child = i; break }n = i.sibling, i.sibling = t, t = i, i = n }nu(e, !0, t, null, s); break; case 'together':nu(e, !1, null, null, void 0); break; default:e.memoizedState = null } return e.child } function aa (n, e) { !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2) } function _n (n, e, t) { if (n !== null && (e.dependencies = n.dependencies), Nr |= e.lanes, !(t & e.childLanes)) return null; if (n !== null && e.child !== n.child) throw Error(U(153)); if (e.child !== null) { for (n = e.child, t = ir(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;)n = n.sibling, t = t.sibling = ir(n, n.pendingProps), t.return = e; t.sibling = null } return e.child } function fT (n, e, t) { switch (e.tag) { case 3:S0(e), $i(); break; case 5:Yg(e); break; case 1:Et(e.type) && ka(e); break; case 4:Md(e, e.stateNode.containerInfo); break; case 10:var r = e.type._context; var i = e.memoizedProps.value; he(Oa, r._currentValue), r._currentValue = i; break; case 13:if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (he(Ee, Ee.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? T0(n, e, t) : (he(Ee, Ee.current & 1), n = _n(n, e, t), n !== null ? n.sibling : null); he(Ee, Ee.current & 1); break; case 19:if (r = (t & e.childLanes) !== 0, n.flags & 128) { if (r) return x0(n, e, t); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), he(Ee, Ee.current), r) break; return null; case 22:case 23:return e.lanes = 0, v0(n, e, t) } return _n(n, e, t) } let L0, yc, R0, A0; L0 = function (n, e) { for (let t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6)n.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (;t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return }t.sibling.return = t.return, t = t.sibling } }; yc = function () {}; R0 = function (n, e, t, r) { let i = n.memoizedProps; if (i !== r) { n = e.stateNode, Tr(hn.current); let s = null; switch (t) { case 'input':i = Bu(n, i), r = Bu(n, r), s = []; break; case 'select':i = Te({}, i, { value: void 0 }), r = Te({}, r, { value: void 0 }), s = []; break; case 'textarea':i = Vu(n, i), r = Vu(n, r), s = []; break; default:typeof i.onClick !== 'function' && typeof r.onClick === 'function' && (n.onclick = _a) }Ku(t, r); let o; t = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === 'style') { var a = i[u]; for (o in a)a.hasOwnProperty(o) && (t || (t = {}), t[o] = '') } else u !== 'dangerouslySetInnerHTML' && u !== 'children' && u !== 'suppressContentEditableWarning' && u !== 'suppressHydrationWarning' && u !== 'autoFocus' && (ks.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { let l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === 'style') if (a) { for (o in a)!a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = ''); for (o in l)l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o]) } else t || (s || (s = []), s.push(u, t)), t = l; else u === 'dangerouslySetInnerHTML' ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === 'children' ? typeof l !== 'string' && typeof l !== 'number' || (s = s || []).push(u, '' + l) : u !== 'suppressContentEditableWarning' && u !== 'suppressHydrationWarning' && (ks.hasOwnProperty(u) ? (l != null && u === 'onScroll' && pe('scroll', n), s || a === l || (s = [])) : (s = s || []).push(u, l)) }t && (s = s || []).push('style', t); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; A0 = function (n, e, t, r) { t !== r && (e.flags |= 4) }; function cs (n, e) { if (!ge) switch (n.tailMode) { case 'hidden':e = n.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? n.tail = null : t.sibling = null; break; case 'collapsed':t = n.tail; for (var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling; r === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : r.sibling = null } } function qe (n) { const e = n.alternate !== null && n.alternate.child === n.child; let t = 0; let r = 0; if (e) for (var i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = n, i = i.sibling; else for (i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = n, i = i.sibling; return n.subtreeFlags |= r, n.childLanes = t, e } function pT (n, e, t) { let r = e.pendingProps; switch (_d(e), e.tag) { case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qe(e), null; case 1:return Et(e.type) && Da(), qe(e), null; case 3:return r = e.stateNode, Vi(), me(vt), me(Ze), Ud(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (n === null || n.child === null) && (Fo(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Wt !== null && (Ac(Wt), Wt = null))), yc(n, e), qe(e), null; case 5:Nd(e); var i = Tr(Hs.current); if (t = e.type, n !== null && e.stateNode != null)R0(n, e, t, r, i), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(U(166)); return qe(e), null } if (n = Tr(hn.current), Fo(e)) { r = e.stateNode, t = e.type; var s = e.memoizedProps; switch (r[ln] = e, r[Gs] = s, n = (e.mode & 1) !== 0, t) { case 'dialog':pe('cancel', r), pe('close', r); break; case 'iframe':case 'object':case 'embed':pe('load', r); break; case 'video':case 'audio':for (i = 0; i < vs.length; i++)pe(vs[i], r); break; case 'source':pe('error', r); break; case 'img':case 'image':case 'link':pe('error', r), pe('load', r); break; case 'details':pe('toggle', r); break; case 'input':Hh(r, s), pe('invalid', r); break; case 'select':r._wrapperState = { wasMultiple: !!s.multiple }, pe('invalid', r); break; case 'textarea':jh(r, s), pe('invalid', r) }Ku(t, s), i = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === 'children' ? typeof a === 'string' ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Oo(r.textContent, a, n), i = ['children', a]) : typeof a === 'number' && r.textContent !== '' + a && (s.suppressHydrationWarning !== !0 && Oo(r.textContent, a, n), i = ['children', '' + a]) : ks.hasOwnProperty(o) && a != null && o === 'onScroll' && pe('scroll', r) } switch (t) { case 'input':wo(r), Kh(r, s, !0); break; case 'textarea':wo(r), zh(r); break; case 'select':case 'option':break; default:typeof s.onClick === 'function' && (r.onclick = _a) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { o = i.nodeType === 9 ? i : i.ownerDocument, n === 'http://www.w3.org/1999/xhtml' && (n = Zm(t)), n === 'http://www.w3.org/1999/xhtml' ? t === 'script' ? (n = o.createElement('div'), n.innerHTML = '<script><\/script>', n = n.removeChild(n.firstChild)) : typeof r.is === 'string' ? n = o.createElement(t, { is: r.is }) : (n = o.createElement(t), t === 'select' && (o = n, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : n = o.createElementNS(n, t), n[ln] = e, n[Gs] = r, L0(n, e, !1, !1), e.stateNode = n; e: { switch (o = ju(t, r), t) { case 'dialog':pe('cancel', n), pe('close', n), i = r; break; case 'iframe':case 'object':case 'embed':pe('load', n), i = r; break; case 'video':case 'audio':for (i = 0; i < vs.length; i++)pe(vs[i], n); i = r; break; case 'source':pe('error', n), i = r; break; case 'img':case 'image':case 'link':pe('error', n), pe('load', n), i = r; break; case 'details':pe('toggle', n), i = r; break; case 'input':Hh(n, r), i = Bu(n, r), pe('invalid', n); break; case 'option':i = r; break; case 'select':n._wrapperState = { wasMultiple: !!r.multiple }, i = Te({}, r, { value: void 0 }), pe('invalid', n); break; case 'textarea':jh(n, r), i = Vu(n, r), pe('invalid', n); break; default:i = r }Ku(t, i), a = i; for (s in a) if (a.hasOwnProperty(s)) { let l = a[s]; s === 'style' ? ng(n, l) : s === 'dangerouslySetInnerHTML' ? (l = l ? l.__html : void 0, l != null && eg(n, l)) : s === 'children' ? typeof l === 'string' ? (t !== 'textarea' || l !== '') && Ps(n, l) : typeof l === 'number' && Ps(n, '' + l) : s !== 'suppressContentEditableWarning' && s !== 'suppressHydrationWarning' && s !== 'autoFocus' && (ks.hasOwnProperty(s) ? l != null && s === 'onScroll' && pe('scroll', n) : l != null && pd(n, s, l, o)) } switch (t) { case 'input':wo(n), Kh(n, r, !1); break; case 'textarea':wo(n), zh(n); break; case 'option':r.value != null && n.setAttribute('value', '' + or(r.value)); break; case 'select':n.multiple = !!r.multiple, s = r.value, s != null ? mi(n, !!r.multiple, s, !1) : r.defaultValue != null && mi(n, !!r.multiple, r.defaultValue, !0); break; default:typeof i.onClick === 'function' && (n.onclick = _a) } switch (t) { case 'button':case 'input':case 'select':case 'textarea':r = !!r.autoFocus; break e; case 'img':r = !0; break e; default:r = !1 } }r && (e.flags |= 4) }e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return qe(e), null; case 6:if (n && e.stateNode != null)A0(n, e, n.memoizedProps, r); else { if (typeof r !== 'string' && e.stateNode === null) throw Error(U(166)); if (t = Tr(Hs.current), Tr(hn.current), Fo(e)) { if (r = e.stateNode, t = e.memoizedProps, r[ln] = e, (s = r.nodeValue !== t) && (n = wt, n !== null)) switch (n.tag) { case 3:Oo(r.nodeValue, t, (n.mode & 1) !== 0); break; case 5:n.memoizedProps.suppressHydrationWarning !== !0 && Oo(r.nodeValue, t, (n.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r), r[ln] = e, e.stateNode = r } return qe(e), null; case 13:if (me(Ee), r = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (ge && At !== null && e.mode & 1 && !(e.flags & 128))Hg(), $i(), e.flags |= 98560, s = !1; else if (s = Fo(e), r !== null && r.dehydrated !== null) { if (n === null) { if (!s) throw Error(U(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(U(317)); s[ln] = e } else $i(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; qe(e), s = !1 } else Wt !== null && (Ac(Wt), Wt = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (r = r !== null, r !== (n !== null && n.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (n === null || Ee.current & 1 ? Fe === 0 && (Fe = 3) : Qd())), e.updateQueue !== null && (e.flags |= 4), qe(e), null); case 4:return Vi(), yc(n, e), n === null && Bs(e.stateNode.containerInfo), qe(e), null; case 10:return bd(e.type._context), qe(e), null; case 17:return Et(e.type) && Da(), qe(e), null; case 19:if (me(Ee), s = e.memoizedState, s === null) return qe(e), null; if (r = (e.flags & 128) !== 0, o = s.rendering, o === null) if (r)cs(s, !1); else { if (Fe !== 0 || n !== null && n.flags & 128) for (n = e.child; n !== null;) { if (o = Na(n), o !== null) { for (e.flags |= 128, cs(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = t, t = e.child; t !== null;)s = t, n = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n = o.dependencies, s.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling; return he(Ee, Ee.current & 1 | 2), e.child }n = n.sibling }s.tail !== null && Ce() > Ki && (e.flags |= 128, r = !0, cs(s, !1), e.lanes = 4194304) } else { if (!r) if (n = Na(o), n !== null) { if (e.flags |= 128, r = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), cs(s, !0), s.tail === null && s.tailMode === 'hidden' && !o.alternate && !ge) return qe(e), null } else 2 * Ce() - s.renderingStartTime > Ki && t !== 1073741824 && (e.flags |= 128, r = !0, cs(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Ce(), e.sibling = null, t = Ee.current, he(Ee, r ? t & 1 | 2 : t & 1), e) : (qe(e), null); case 22:case 23:return qd(), r = e.memoizedState !== null, n !== null && n.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Rt & 1073741824 && (qe(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : qe(e), null; case 24:return null; case 25:return null } throw Error(U(156, e.tag)) } function mT (n, e) { switch (_d(e), e.tag) { case 1:return Et(e.type) && Da(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 3:return Vi(), me(vt), me(Ze), Ud(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null; case 5:return Nd(e), null; case 13:if (me(Ee), n = e.memoizedState, n !== null && n.dehydrated !== null) { if (e.alternate === null) throw Error(U(340)); $i() } return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 19:return me(Ee), null; case 4:return Vi(), null; case 10:return bd(e.type._context), null; case 22:case 23:return qd(), null; case 24:return null; default:return null } } let Uo = !1; let Je = !1; const gT = typeof WeakSet === 'function' ? WeakSet : Set; let H = null; function hi (n, e) { const t = n.ref; if (t !== null) if (typeof t === 'function') try { t(null) } catch (r) { Re(n, e, r) } else t.current = null } function vc (n, e, t) { try { t() } catch (r) { Re(n, e, r) } } let Mf = !1; function yT (n, e) { if (tc = wa, n = Dg(), Cd(n)) { if ('selectionStart' in n) var t = { start: n.selectionStart, end: n.selectionEnd }; else e: { t = (t = n.ownerDocument) && t.defaultView || window; let r = t.getSelection && t.getSelection(); if (r && r.rangeCount !== 0) { t = r.anchorNode; const i = r.anchorOffset; const s = r.focusNode; r = r.focusOffset; try { t.nodeType, s.nodeType } catch { t = null; break e } let o = 0; let a = -1; let l = -1; let u = 0; let c = 0; let d = n; let h = null; t:for (;;) { for (var f; d !== t || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (f = d.firstChild) !== null;)h = d, d = f; for (;;) { if (d === n) break t; if (h === t && ++u === i && (a = o), h === s && ++c === r && (l = o), (f = d.nextSibling) !== null) break; d = h, h = d.parentNode }d = f }t = a === -1 || l === -1 ? null : { start: a, end: l } } else t = null }t = t || { start: 0, end: 0 } } else t = null; for (nc = { focusedElem: n, selectionRange: t }, wa = !1, H = e; H !== null;) if (e = H, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null)n.return = e, H = n; else for (;H !== null;) { e = H; try { var p = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0:case 11:case 15:break; case 1:if (p !== null) { const m = p.memoizedProps; const y = p.memoizedState; const g = e.stateNode; const v = g.getSnapshotBeforeUpdate(e.elementType === e.type ? m : Kt(e.type, m), y); g.__reactInternalSnapshotBeforeUpdate = v } break; case 3:var E = e.stateNode.containerInfo; E.nodeType === 1 ? E.textContent = '' : E.nodeType === 9 && E.documentElement && E.removeChild(E.documentElement); break; case 5:case 6:case 4:case 17:break; default:throw Error(U(163)) } } catch (x) { Re(e, e.return, x) } if (n = e.sibling, n !== null) { n.return = e.return, H = n; break }H = e.return } return p = Mf, Mf = !1, p } function Cs (n, e, t) { let r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { let i = r = r.next; do { if ((i.tag & n) === n) { const s = i.destroy; i.destroy = void 0, s !== void 0 && vc(e, t, s) }i = i.next } while (i !== r) } } function ml (n, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { let t = e = e.next; do { if ((t.tag & n) === n) { const r = t.create; t.destroy = r() }t = t.next } while (t !== e) } } function Ec (n) { const e = n.ref; if (e !== null) { const t = n.stateNode; switch (n.tag) { case 5:n = t; break; default:n = t } typeof e === 'function' ? e(n) : e.current = n } } function w0 (n) { let e = n.alternate; e !== null && (n.alternate = null, w0(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[ln], delete e[Gs], delete e[sc], delete e[ZS], delete e[eT])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } function C0 (n) { return n.tag === 5 || n.tag === 3 || n.tag === 4 } function Nf (n) { e:for (;;) { for (;n.sibling === null;) { if (n.return === null || C0(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.flags & 2 || n.child === null || n.tag === 4) continue e; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function Sc (n, e, t) { const r = n.tag; if (r === 5 || r === 6)n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = _a)); else if (r !== 4 && (n = n.child, n !== null)) for (Sc(n, e, t), n = n.sibling; n !== null;)Sc(n, e, t), n = n.sibling } function Tc (n, e, t) { const r = n.tag; if (r === 5 || r === 6)n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n); else if (r !== 4 && (n = n.child, n !== null)) for (Tc(n, e, t), n = n.sibling; n !== null;)Tc(n, e, t), n = n.sibling } let Ke = null; let zt = !1; function Pn (n, e, t) { for (t = t.child; t !== null;)I0(n, e, t), t = t.sibling } function I0 (n, e, t) { if (dn && typeof dn.onCommitFiberUnmount === 'function') try { dn.onCommitFiberUnmount(al, t) } catch {} switch (t.tag) { case 5:Je || hi(t, e); case 6:var r = Ke; var i = zt; Ke = null, Pn(n, e, t), Ke = r, zt = i, Ke !== null && (zt ? (n = Ke, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Ke.removeChild(t.stateNode)); break; case 18:Ke !== null && (zt ? (n = Ke, t = t.stateNode, n.nodeType === 8 ? ql(n.parentNode, t) : n.nodeType === 1 && ql(n, t), Ms(n)) : ql(Ke, t.stateNode)); break; case 4:r = Ke, i = zt, Ke = t.stateNode.containerInfo, zt = !0, Pn(n, e, t), Ke = r, zt = i; break; case 0:case 11:case 14:case 15:if (!Je && (r = t.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { let s = i; const o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && vc(t, e, o), i = i.next } while (i !== r) }Pn(n, e, t); break; case 1:if (!Je && (hi(t, e), r = t.stateNode, typeof r.componentWillUnmount === 'function')) try { r.props = t.memoizedProps, r.state = t.memoizedState, r.componentWillUnmount() } catch (a) { Re(t, e, a) }Pn(n, e, t); break; case 21:Pn(n, e, t); break; case 22:t.mode & 1 ? (Je = (r = Je) || t.memoizedState !== null, Pn(n, e, t), Je = r) : Pn(n, e, t); break; default:Pn(n, e, t) } } function Uf (n) { const e = n.updateQueue; if (e !== null) { n.updateQueue = null; let t = n.stateNode; t === null && (t = n.stateNode = new gT()), e.forEach(function (r) { const i = wT.bind(null, n, r); t.has(r) || (t.add(r), r.then(i, i)) }) } } function Gt (n, e) { const t = e.deletions; if (t !== null) for (let r = 0; r < t.length; r++) { const i = t[r]; try { const s = n; const o = e; let a = o; e:for (;a !== null;) { switch (a.tag) { case 5:Ke = a.stateNode, zt = !1; break e; case 3:Ke = a.stateNode.containerInfo, zt = !0; break e; case 4:Ke = a.stateNode.containerInfo, zt = !0; break e }a = a.return } if (Ke === null) throw Error(U(160)); I0(s, o, i), Ke = null, zt = !1; const l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { Re(i, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)_0(e, n), e = e.sibling } function _0 (n, e) { let t = n.alternate; let r = n.flags; switch (n.tag) { case 0:case 11:case 14:case 15:if (Gt(e, n), Jt(n), r & 4) { try { Cs(3, n, n.return), ml(3, n) } catch (m) { Re(n, n.return, m) } try { Cs(5, n, n.return) } catch (m) { Re(n, n.return, m) } } break; case 1:Gt(e, n), Jt(n), r & 512 && t !== null && hi(t, t.return); break; case 5:if (Gt(e, n), Jt(n), r & 512 && t !== null && hi(t, t.return), n.flags & 32) { var i = n.stateNode; try { Ps(i, '') } catch (m) { Re(n, n.return, m) } } if (r & 4 && (i = n.stateNode, i != null)) { var s = n.memoizedProps; var o = t !== null ? t.memoizedProps : s; var a = n.type; var l = n.updateQueue; if (n.updateQueue = null, l !== null) try { a === 'input' && s.type === 'radio' && s.name != null && Xm(i, s), ju(a, o); var u = ju(a, s); for (o = 0; o < l.length; o += 2) { var c = l[o]; var d = l[o + 1]; c === 'style' ? ng(i, d) : c === 'dangerouslySetInnerHTML' ? eg(i, d) : c === 'children' ? Ps(i, d) : pd(i, c, d, u) } switch (a) { case 'input':$u(i, s); break; case 'textarea':Jm(i, s); break; case 'select':var h = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var f = s.value; f != null ? mi(i, !!s.multiple, f, !1) : h !== !!s.multiple && (s.defaultValue != null ? mi(i, !!s.multiple, s.defaultValue, !0) : mi(i, !!s.multiple, s.multiple ? [] : '', !1)) }i[Gs] = s } catch (m) { Re(n, n.return, m) } } break; case 6:if (Gt(e, n), Jt(n), r & 4) { if (n.stateNode === null) throw Error(U(162)); i = n.stateNode, s = n.memoizedProps; try { i.nodeValue = s } catch (m) { Re(n, n.return, m) } } break; case 3:if (Gt(e, n), Jt(n), r & 4 && t !== null && t.memoizedState.isDehydrated) try { Ms(e.containerInfo) } catch (m) { Re(n, n.return, m) } break; case 4:Gt(e, n), Jt(n); break; case 13:Gt(e, n), Jt(n), i = n.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (Wd = Ce())), r & 4 && Uf(n); break; case 22:if (c = t !== null && t.memoizedState !== null, n.mode & 1 ? (Je = (u = Je) || c, Gt(e, n), Je = u) : Gt(e, n), Jt(n), r & 8192) { if (u = n.memoizedState !== null, (n.stateNode.isHidden = u) && !c && n.mode & 1) for (H = n, c = n.child; c !== null;) { for (d = H = c; H !== null;) { switch (h = H, f = h.child, h.tag) { case 0:case 11:case 14:case 15:Cs(4, h, h.return); break; case 1:hi(h, h.return); var p = h.stateNode; if (typeof p.componentWillUnmount === 'function') { r = h, t = h.return; try { e = r, p.props = e.memoizedProps, p.state = e.memoizedState, p.componentWillUnmount() } catch (m) { Re(r, t, m) } } break; case 5:hi(h, h.return); break; case 22:if (h.memoizedState !== null) { $f(d); continue } }f !== null ? (f.return = h, H = f) : $f(d) }c = c.sibling }e:for (c = null, d = n; ;) { if (d.tag === 5) { if (c === null) { c = d; try { i = d.stateNode, u ? (s = i.style, typeof s.setProperty === 'function' ? s.setProperty('display', 'none', 'important') : s.display = 'none') : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty('display') ? l.display : null, a.style.display = tg('display', o)) } catch (m) { Re(n, n.return, m) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? '' : d.memoizedProps } catch (m) { Re(n, n.return, m) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === n) break e; for (;d.sibling === null;) { if (d.return === null || d.return === n) break e; c === d && (c = null), d = d.return }c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19:Gt(e, n), Jt(n), r & 4 && Uf(n); break; case 21:break; default:Gt(e, n), Jt(n) } } function Jt (n) { const e = n.flags; if (e & 2) { try { e: { for (let t = n.return; t !== null;) { if (C0(t)) { var r = t; break e }t = t.return } throw Error(U(160)) } switch (r.tag) { case 5:var i = r.stateNode; r.flags & 32 && (Ps(i, ''), r.flags &= -33); var s = Nf(n); Tc(n, s, i); break; case 3:case 4:var o = r.stateNode.containerInfo; var a = Nf(n); Sc(n, a, o); break; default:throw Error(U(161)) } } catch (l) { Re(n, n.return, l) }n.flags &= -3 }e & 4096 && (n.flags &= -4097) } function vT (n, e, t) { H = n, D0(n) } function D0 (n, e, t) { for (let r = (n.mode & 1) !== 0; H !== null;) { const i = H; let s = i.child; if (i.tag === 22 && r) { let o = i.memoizedState !== null || Uo; if (!o) { let a = i.alternate; let l = a !== null && a.memoizedState !== null || Je; a = Uo; const u = Je; if (Uo = o, (Je = l) && !u) for (H = i; H !== null;)o = H, l = o.child, o.tag === 22 && o.memoizedState !== null ? Gf(i) : l !== null ? (l.return = o, H = l) : Gf(i); for (;s !== null;)H = s, D0(s), s = s.sibling; H = i, Uo = a, Je = u }Bf(n) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, H = s) : Bf(n) } } function Bf (n) { for (;H !== null;) { const e = H; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0:case 11:case 15:Je || ml(5, e); break; case 1:var r = e.stateNode; if (e.flags & 4 && !Je) if (t === null)r.componentDidMount(); else { const i = e.elementType === e.type ? t.memoizedProps : Kt(e.type, t.memoizedProps); r.componentDidUpdate(i, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && Lf(e, s, r); break; case 3:var o = e.updateQueue; if (o !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5:t = e.child.stateNode; break; case 1:t = e.child.stateNode }Lf(e, o, t) } break; case 5:var a = e.stateNode; if (t === null && e.flags & 4) { t = a; const l = e.memoizedProps; switch (e.type) { case 'button':case 'input':case 'select':case 'textarea':l.autoFocus && t.focus(); break; case 'img':l.src && (t.src = l.src) } } break; case 6:break; case 4:break; case 12:break; case 13:if (e.memoizedState === null) { const u = e.alternate; if (u !== null) { const c = u.memoizedState; if (c !== null) { const d = c.dehydrated; d !== null && Ms(d) } } } break; case 19:case 17:case 21:case 22:case 23:case 25:break; default:throw Error(U(163)) }Je || e.flags & 512 && Ec(e) } catch (h) { Re(e, e.return, h) } } if (e === n) { H = null; break } if (t = e.sibling, t !== null) { t.return = e.return, H = t; break }H = e.return } } function $f (n) { for (;H !== null;) { const e = H; if (e === n) { H = null; break } const t = e.sibling; if (t !== null) { t.return = e.return, H = t; break }H = e.return } } function Gf (n) { for (;H !== null;) { const e = H; try { switch (e.tag) { case 0:case 11:case 15:var t = e.return; try { ml(4, e) } catch (l) { Re(e, t, l) } break; case 1:var r = e.stateNode; if (typeof r.componentDidMount === 'function') { const i = e.return; try { r.componentDidMount() } catch (l) { Re(e, i, l) } } var s = e.return; try { Ec(e) } catch (l) { Re(e, s, l) } break; case 5:var o = e.return; try { Ec(e) } catch (l) { Re(e, o, l) } } } catch (l) { Re(e, e.return, l) } if (e === n) { H = null; break } const a = e.sibling; if (a !== null) { a.return = e.return, H = a; break }H = e.return } } const ET = Math.ceil; const $a = Dn.ReactCurrentDispatcher; const jd = Dn.ReactCurrentOwner; const Nt = Dn.ReactCurrentBatchConfig; var oe = 0; var Be = null; let _e = null; let ze = 0; var Rt = 0; var fi = ur(0); var Fe = 0; let Ws = null; var Nr = 0; let gl = 0; let zd = 0; let Is = null; let mt = null; var Wd = 0; var Ki = 1 / 0; let vn = null; var Ga = !1; var xc = null; var nr = null; let Bo = !1; let qn = null; let Va = 0; let _s = 0; let Lc = null; let la = -1; let ua = 0; function ot () { return oe & 6 ? Ce() : la !== -1 ? la : la = Ce() } function rr (n) { return n.mode & 1 ? oe & 2 && ze !== 0 ? ze & -ze : nT.transition !== null ? (ua === 0 && (ua = pg()), ua) : (n = le, n !== 0 || (n = window.event, n = n === void 0 ? 16 : Tg(n.type)), n) : 1 } function Qt (n, e, t, r) { if (_s > 50) throw _s = 0, Lc = null, Error(U(185)); go(n, t, r), (!(oe & 2) || n !== Be) && (n === Be && (!(oe & 2) && (gl |= t), Fe === 4 && Bn(n, ze)), St(n, r), t === 1 && oe === 0 && !(e.mode & 1) && (Ki = Ce() + 500, hl && cr())) } function St (n, e) { let t = n.callbackNode; nS(n, e); const r = Aa(n, n === Be ? ze : 0); if (r === 0)t !== null && qh(t), n.callbackNode = null, n.callbackPriority = 0; else if (e = r & -r, n.callbackPriority !== e) { if (t != null && qh(t), e === 1)n.tag === 0 ? tT(Vf.bind(null, n)) : $g(Vf.bind(null, n)), XS(function () { !(oe & 6) && cr() }), t = null; else { switch (mg(r)) { case 1:t = Ed; break; case 4:t = hg; break; case 16:t = Ra; break; case 536870912:t = fg; break; default:t = Ra }t = U0(t, k0.bind(null, n)) }n.callbackPriority = e, n.callbackNode = t } } function k0 (n, e) { if (la = -1, ua = 0, oe & 6) throw Error(U(327)); let t = n.callbackNode; if (Si() && n.callbackNode !== t) return null; let r = Aa(n, n === Be ? ze : 0); if (r === 0) return null; if (r & 30 || r & n.expiredLanes || e)e = Ha(n, r); else { e = r; var i = oe; oe |= 2; var s = b0(); (Be !== n || ze !== e) && (vn = null, Ki = Ce() + 500, kr(n, e)); do try { xT(); break } catch (a) { P0(n, a) } while (!0); Pd(), $a.current = s, oe = i, _e !== null ? e = 0 : (Be = null, ze = 0, e = Fe) } if (e !== 0) { if (e === 2 && (i = Qu(n), i !== 0 && (r = i, e = Rc(n, i))), e === 1) throw t = Ws, kr(n, 0), Bn(n, r), St(n, Ce()), t; if (e === 6)Bn(n, r); else { if (i = n.current.alternate, !(r & 30) && !ST(i) && (e = Ha(n, r), e === 2 && (s = Qu(n), s !== 0 && (r = s, e = Rc(n, s))), e === 1)) throw t = Ws, kr(n, 0), Bn(n, r), St(n, Ce()), t; switch (n.finishedWork = i, n.finishedLanes = r, e) { case 0:case 1:throw Error(U(345)); case 2:yr(n, mt, vn); break; case 3:if (Bn(n, r), (r & 130023424) === r && (e = Wd + 500 - Ce(), e > 10)) { if (Aa(n, 0) !== 0) break; if (i = n.suspendedLanes, (i & r) !== r) { ot(), n.pingedLanes |= n.suspendedLanes & i; break }n.timeoutHandle = ic(yr.bind(null, n, mt, vn), e); break }yr(n, mt, vn); break; case 4:if (Bn(n, r), (r & 4194240) === r) break; for (e = n.eventTimes, i = -1; r > 0;) { let o = 31 - qt(r); s = 1 << o, o = e[o], o > i && (i = o), r &= ~s } if (r = i, r = Ce() - r, r = (r < 120 ? 120 : r < 480 ? 480 : r < 1080 ? 1080 : r < 1920 ? 1920 : r < 3e3 ? 3e3 : r < 4320 ? 4320 : 1960 * ET(r / 1960)) - r, r > 10) { n.timeoutHandle = ic(yr.bind(null, n, mt, vn), r); break }yr(n, mt, vn); break; case 5:yr(n, mt, vn); break; default:throw Error(U(329)) } } } return St(n, Ce()), n.callbackNode === t ? k0.bind(null, n) : null } function Rc (n, e) { const t = Is; return n.current.memoizedState.isDehydrated && (kr(n, e).flags |= 256), n = Ha(n, e), n !== 2 && (e = mt, mt = t, e !== null && Ac(e)), n } function Ac (n) { mt === null ? mt = n : mt.push.apply(mt, n) } function ST (n) { for (let e = n; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (let r = 0; r < t.length; r++) { let i = t[r]; const s = i.getSnapshot; i = i.value; try { if (!Xt(s(), i)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null)t.return = e, e = t; else { if (e === n) break; for (;e.sibling === null;) { if (e.return === null || e.return === n) return !0; e = e.return }e.sibling.return = e.return, e = e.sibling } } return !0 } function Bn (n, e) { for (e &= ~zd, e &= ~gl, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; e > 0;) { const t = 31 - qt(e); const r = 1 << t; n[t] = -1, e &= ~r } } function Vf (n) { if (oe & 6) throw Error(U(327)); Si(); let e = Aa(n, 0); if (!(e & 1)) return St(n, Ce()), null; let t = Ha(n, e); if (n.tag !== 0 && t === 2) { const r = Qu(n); r !== 0 && (e = r, t = Rc(n, r)) } if (t === 1) throw t = Ws, kr(n, 0), Bn(n, e), St(n, Ce()), t; if (t === 6) throw Error(U(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = e, yr(n, mt, vn), St(n, Ce()), null } function Yd (n, e) { const t = oe; oe |= 1; try { return n(e) } finally { oe = t, oe === 0 && (Ki = Ce() + 500, hl && cr()) } } function Ur (n) { qn !== null && qn.tag === 0 && !(oe & 6) && Si(); const e = oe; oe |= 1; const t = Nt.transition; const r = le; try { if (Nt.transition = null, le = 1, n) return n() } finally { le = r, Nt.transition = t, oe = e, !(oe & 6) && cr() } } function qd () { Rt = fi.current, me(fi) } function kr (n, e) { n.finishedWork = null, n.finishedLanes = 0; let t = n.timeoutHandle; if (t !== -1 && (n.timeoutHandle = -1, QS(t)), _e !== null) for (t = _e.return; t !== null;) { var r = t; switch (_d(r), r.tag) { case 1:r = r.type.childContextTypes, r != null && Da(); break; case 3:Vi(), me(vt), me(Ze), Ud(); break; case 5:Nd(r); break; case 4:Vi(); break; case 13:me(Ee); break; case 19:me(Ee); break; case 10:bd(r.type._context); break; case 22:case 23:qd() }t = t.return } if (Be = n, _e = n = ir(n.current, null), ze = Rt = e, Fe = 0, Ws = null, zd = gl = Nr = 0, mt = Is = null, Sr !== null) { for (e = 0; e < Sr.length; e++) if (t = Sr[e], r = t.interleaved, r !== null) { t.interleaved = null; const i = r.next; const s = t.pending; if (s !== null) { const o = s.next; s.next = i, r.next = o }t.pending = r }Sr = null } return n } function P0 (n, e) { do { let t = _e; try { if (Pd(), sa.current = Ba, Ua) { for (let r = Se.memoizedState; r !== null;) { const i = r.queue; i !== null && (i.pending = null), r = r.next }Ua = !1 } if (Mr = 0, Ne = be = Se = null, ws = !1, Ks = 0, jd.current = null, t === null || t.return === null) { Fe = 1, Ws = e, _e = null; break }e: { let s = n; const o = t.return; let a = t; let l = e; if (e = ze, a.flags |= 32768, l !== null && typeof l === 'object' && typeof l.then === 'function') { const u = l; const c = a; const d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { const h = c.alternate; h ? (c.updateQueue = h.updateQueue, c.memoizedState = h.memoizedState, c.lanes = h.lanes) : (c.updateQueue = null, c.memoizedState = null) } const f = _f(o); if (f !== null) { f.flags &= -257, Df(f, o, a, s, e), f.mode & 1 && If(s, u, e), e = f, l = u; const p = e.updateQueue; if (p === null) { const m = new Set(); m.add(l), e.updateQueue = m } else p.add(l); break e } else { if (!(e & 1)) { If(s, u, e), Qd(); break e }l = Error(U(426)) } } else if (ge && a.mode & 1) { const y = _f(o); if (y !== null) { !(y.flags & 65536) && (y.flags |= 256), Df(y, o, a, s, e), Dd(Hi(l, a)); break e } }s = l = Hi(l, a), Fe !== 4 && (Fe = 2), Is === null ? Is = [s] : Is.push(s), s = o; do { switch (s.tag) { case 3:s.flags |= 65536, e &= -e, s.lanes |= e; var g = m0(s, l, e); xf(s, g); break e; case 1:a = l; var v = s.type; var E = s.stateNode; if (!(s.flags & 128) && (typeof v.getDerivedStateFromError === 'function' || E !== null && typeof E.componentDidCatch === 'function' && (nr === null || !nr.has(E)))) { s.flags |= 65536, e &= -e, s.lanes |= e; const x = g0(s, a, e); xf(s, x); break e } }s = s.return } while (s !== null) }F0(t) } catch (T) { e = T, _e === t && t !== null && (_e = t = t.return); continue } break } while (!0) } function b0 () { const n = $a.current; return $a.current = Ba, n === null ? Ba : n } function Qd () { (Fe === 0 || Fe === 3 || Fe === 2) && (Fe = 4), Be === null || !(Nr & 268435455) && !(gl & 268435455) || Bn(Be, ze) } function Ha (n, e) { const t = oe; oe |= 2; const r = b0(); (Be !== n || ze !== e) && (vn = null, kr(n, e)); do try { TT(); break } catch (i) { P0(n, i) } while (!0); if (Pd(), oe = t, $a.current = r, _e !== null) throw Error(U(261)); return Be = null, ze = 0, Fe } function TT () { for (;_e !== null;)O0(_e) } function xT () { for (;_e !== null && !WE();)O0(_e) } function O0 (n) { const e = N0(n.alternate, n, Rt); n.memoizedProps = n.pendingProps, e === null ? F0(n) : _e = e, jd.current = null } function F0 (n) { let e = n; do { let t = e.alternate; if (n = e.return, e.flags & 32768) { if (t = mT(t, e), t !== null) { t.flags &= 32767, _e = t; return } if (n !== null)n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { Fe = 6, _e = null; return } } else if (t = pT(t, e, Rt), t !== null) { _e = t; return } if (e = e.sibling, e !== null) { _e = e; return }_e = e = n } while (e !== null); Fe === 0 && (Fe = 5) } function yr (n, e, t) { const r = le; const i = Nt.transition; try { Nt.transition = null, le = 1, LT(n, e, t, r) } finally { Nt.transition = i, le = r } return null } function LT (n, e, t, r) { do Si(); while (qn !== null); if (oe & 6) throw Error(U(327)); t = n.finishedWork; let i = n.finishedLanes; if (t === null) return null; if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(U(177)); n.callbackNode = null, n.callbackPriority = 0; let s = t.lanes | t.childLanes; if (rS(n, s), n === Be && (_e = Be = null, ze = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Bo || (Bo = !0, U0(Ra, function () { return Si(), null })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) { s = Nt.transition, Nt.transition = null; const o = le; le = 1; const a = oe; oe |= 4, jd.current = null, yT(n, t), _0(t, n), HS(nc), wa = !!tc, nc = tc = null, n.current = t, vT(t), YE(), oe = a, le = o, Nt.transition = s } else n.current = t; if (Bo && (Bo = !1, qn = n, Va = i), s = n.pendingLanes, s === 0 && (nr = null), XE(t.stateNode), St(n, Ce()), e !== null) for (r = n.onRecoverableError, t = 0; t < e.length; t++)i = e[t], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Ga) throw Ga = !1, n = xc, xc = null, n; return Va & 1 && n.tag !== 0 && Si(), s = n.pendingLanes, s & 1 ? n === Lc ? _s++ : (_s = 0, Lc = n) : _s = 0, cr(), null } function Si () { if (qn !== null) { let n = mg(Va); const e = Nt.transition; const t = le; try { if (Nt.transition = null, le = n < 16 ? 16 : n, qn === null) var r = !1; else { if (n = qn, qn = null, Va = 0, oe & 6) throw Error(U(331)); const i = oe; for (oe |= 4, H = n.current; H !== null;) { let s = H; var o = s.child; if (H.flags & 16) { var a = s.deletions; if (a !== null) { for (let l = 0; l < a.length; l++) { const u = a[l]; for (H = u; H !== null;) { let c = H; switch (c.tag) { case 0:case 11:case 15:Cs(8, c, s) } const d = c.child; if (d !== null)d.return = c, H = d; else for (;H !== null;) { c = H; const h = c.sibling; const f = c.return; if (w0(c), c === u) { H = null; break } if (h !== null) { h.return = f, H = h; break }H = f } } } const p = s.alternate; if (p !== null) { let m = p.child; if (m !== null) { p.child = null; do { const y = m.sibling; m.sibling = null, m = y } while (m !== null) } }H = s } } if (s.subtreeFlags & 2064 && o !== null)o.return = s, H = o; else e:for (;H !== null;) { if (s = H, s.flags & 2048) switch (s.tag) { case 0:case 11:case 15:Cs(9, s, s.return) } const g = s.sibling; if (g !== null) { g.return = s.return, H = g; break e }H = s.return } } const v = n.current; for (H = v; H !== null;) { o = H; const E = o.child; if (o.subtreeFlags & 2064 && E !== null)E.return = o, H = E; else e:for (o = v; H !== null;) { if (a = H, a.flags & 2048) try { switch (a.tag) { case 0:case 11:case 15:ml(9, a) } } catch (T) { Re(a, a.return, T) } if (a === o) { H = null; break e } const x = a.sibling; if (x !== null) { x.return = a.return, H = x; break e }H = a.return } } if (oe = i, cr(), dn && typeof dn.onPostCommitFiberRoot === 'function') try { dn.onPostCommitFiberRoot(al, n) } catch {}r = !0 } return r } finally { le = t, Nt.transition = e } } return !1 } function Hf (n, e, t) { e = Hi(t, e), e = m0(n, e, 1), n = tr(n, e, 1), e = ot(), n !== null && (go(n, 1, e), St(n, e)) } function Re (n, e, t) { if (n.tag === 3)Hf(n, n, t); else for (;e !== null;) { if (e.tag === 3) { Hf(e, n, t); break } else if (e.tag === 1) { const r = e.stateNode; if (typeof e.type.getDerivedStateFromError === 'function' || typeof r.componentDidCatch === 'function' && (nr === null || !nr.has(r))) { n = Hi(t, n), n = g0(e, n, 1), e = tr(e, n, 1), n = ot(), e !== null && (go(e, 1, n), St(e, n)); break } }e = e.return } } function RT (n, e, t) { const r = n.pingCache; r !== null && r.delete(e), e = ot(), n.pingedLanes |= n.suspendedLanes & t, Be === n && (ze & t) === t && (Fe === 4 || Fe === 3 && (ze & 130023424) === ze && Ce() - Wd < 500 ? kr(n, 0) : zd |= t), St(n, e) } function M0 (n, e) { e === 0 && (n.mode & 1 ? (e = _o, _o <<= 1, !(_o & 130023424) && (_o = 4194304)) : e = 1); const t = ot(); n = In(n, e), n !== null && (go(n, e, t), St(n, t)) } function AT (n) { const e = n.memoizedState; let t = 0; e !== null && (t = e.retryLane), M0(n, t) } function wT (n, e) { let t = 0; switch (n.tag) { case 13:var r = n.stateNode; var i = n.memoizedState; i !== null && (t = i.retryLane); break; case 19:r = n.stateNode; break; default:throw Error(U(314)) }r !== null && r.delete(e), M0(n, t) } let N0; N0 = function (n, e, t) { if (n !== null) if (n.memoizedProps !== e.pendingProps || vt.current)yt = !0; else { if (!(n.lanes & t) && !(e.flags & 128)) return yt = !1, fT(n, e, t); yt = !!(n.flags & 131072) } else yt = !1, ge && e.flags & 1048576 && Gg(e, ba, e.index); switch (e.lanes = 0, e.tag) { case 2:var r = e.type; aa(n, e), n = e.pendingProps; var i = Bi(e, Ze.current); Ei(e, t), i = $d(null, e, r, n, i, t); var s = Gd(); return e.flags |= 1, typeof i === 'object' && i !== null && typeof i.render === 'function' && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Et(r) ? (s = !0, ka(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Fd(e), i.updater = pl, e.stateNode = i, i._reactInternals = e, dc(e, r, n, t), e = pc(null, e, r, !0, s, t)) : (e.tag = 0, ge && s && Id(e), st(null, e, i, t), e = e.child), e; case 16:r = e.elementType; e: { switch (aa(n, e), n = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = IT(r), n = Kt(r, n), i) { case 0:e = fc(null, e, r, n, t); break e; case 1:e = bf(null, e, r, n, t); break e; case 11:e = kf(null, e, r, n, t); break e; case 14:e = Pf(null, e, r, Kt(r.type, n), t); break e } throw Error(U(306, r, '')) } return e; case 0:return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Kt(r, i), fc(n, e, r, i, t); case 1:return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Kt(r, i), bf(n, e, r, i, t); case 3:e: { if (S0(e), n === null) throw Error(U(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, Wg(n, e), Ma(e, r, null, t); var o = e.memoizedState; if (r = o.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Hi(Error(U(423)), e), e = Of(n, e, r, t, i); break e } else if (r !== i) { i = Hi(Error(U(424)), e), e = Of(n, e, r, t, i); break e } else for (At = er(e.stateNode.containerInfo.firstChild), wt = e, ge = !0, Wt = null, t = jg(e, null, r, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if ($i(), r === i) { e = _n(n, e, t); break e }st(n, e, r, t) }e = e.child } return e; case 5:return Yg(e), n === null && lc(e), r = e.type, i = e.pendingProps, s = n !== null ? n.memoizedProps : null, o = i.children, rc(r, i) ? o = null : s !== null && rc(r, s) && (e.flags |= 32), E0(n, e), st(n, e, o, t), e.child; case 6:return n === null && lc(e), null; case 13:return T0(n, e, t); case 4:return Md(e, e.stateNode.containerInfo), r = e.pendingProps, n === null ? e.child = Gi(e, null, r, t) : st(n, e, r, t), e.child; case 11:return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Kt(r, i), kf(n, e, r, i, t); case 7:return st(n, e, e.pendingProps, t), e.child; case 8:return st(n, e, e.pendingProps.children, t), e.child; case 12:return st(n, e, e.pendingProps.children, t), e.child; case 10:e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, he(Oa, r._currentValue), r._currentValue = o, s !== null) if (Xt(s.value, o)) { if (s.children === i.children && !vt.current) { e = _n(n, e, t); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { let a = s.dependencies; if (a !== null) { o = s.child; for (let l = a.firstContext; l !== null;) { if (l.context === r) { if (s.tag === 1) { l = An(-1, t & -t), l.tag = 2; let u = s.updateQueue; if (u !== null) { u = u.shared; const c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } }s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), uc(s.return, t, e), a.lanes |= t; break }l = l.next } } else if (s.tag === 10)o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(U(341)); o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), uc(o, t, e), o = s.sibling } else o = s.child; if (o !== null)o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break }o = o.return }s = o }st(n, e, i.children, t), e = e.child } return e; case 9:return i = e.type, r = e.pendingProps.children, Ei(e, t), i = Ut(i), r = r(i), e.flags |= 1, st(n, e, r, t), e.child; case 14:return r = e.type, i = Kt(r, e.pendingProps), i = Kt(r.type, i), Pf(n, e, r, i, t); case 15:return y0(n, e, e.type, e.pendingProps, t); case 17:return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Kt(r, i), aa(n, e), e.tag = 1, Et(r) ? (n = !0, ka(e)) : n = !1, Ei(e, t), p0(e, r, i), dc(e, r, i, t), pc(null, e, r, !0, n, t); case 19:return x0(n, e, t); case 22:return v0(n, e, t) } throw Error(U(156, e.tag)) }; function U0 (n, e) { return dg(n, e) } function CT (n, e, t, r) { this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Mt (n, e, t, r) { return new CT(n, e, t, r) } function Xd (n) { return n = n.prototype, !(!n || !n.isReactComponent) } function IT (n) { if (typeof n === 'function') return Xd(n) ? 1 : 0; if (n != null) { if (n = n.$$typeof, n === gd) return 11; if (n === yd) return 14 } return 2 } function ir (n, e) { let t = n.alternate; return t === null ? (t = Mt(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t } function ca (n, e, t, r, i, s) { let o = 2; if (r = n, typeof n === 'function')Xd(n) && (o = 1); else if (typeof n === 'string')o = 5; else e:switch (n) { case ri:return Pr(t.children, i, s, e); case md:o = 8, i |= 8; break; case Fu:return n = Mt(12, t, e, i | 2), n.elementType = Fu, n.lanes = s, n; case Mu:return n = Mt(13, t, e, i), n.elementType = Mu, n.lanes = s, n; case Nu:return n = Mt(19, t, e, i), n.elementType = Nu, n.lanes = s, n; case Ym:return yl(t, i, s, e); default:if (typeof n === 'object' && n !== null) switch (n.$$typeof) { case zm:o = 10; break e; case Wm:o = 9; break e; case gd:o = 11; break e; case yd:o = 14; break e; case Fn:o = 16, r = null; break e } throw Error(U(130, n == null ? n : typeof n, '')) } return e = Mt(o, t, e, i), e.elementType = n, e.type = r, e.lanes = s, e } function Pr (n, e, t, r) { return n = Mt(7, n, r, e), n.lanes = t, n } function yl (n, e, t, r) { return n = Mt(22, n, r, e), n.elementType = Ym, n.lanes = t, n.stateNode = { isHidden: !1 }, n } function ru (n, e, t) { return n = Mt(6, n, null, e), n.lanes = t, n } function iu (n, e, t) { return e = Mt(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e } function _T (n, e, t, r, i) { this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ul(0), this.expirationTimes = Ul(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ul(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Jd (n, e, t, r, i, s, o, a, l) { return n = new _T(n, e, t, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Mt(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = { element: r, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Fd(s), n } function DT (n, e, t) { const r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: ni, key: r == null ? null : '' + r, children: n, containerInfo: e, implementation: t } } function B0 (n) { if (!n) return ar; n = n._reactInternals; e: { if (Vr(n) !== n || n.tag !== 1) throw Error(U(170)); var e = n; do { switch (e.tag) { case 3:e = e.stateNode.context; break e; case 1:if (Et(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(U(171)) } if (n.tag === 1) { const t = n.type; if (Et(t)) return Bg(n, t, e) } return e } function $0 (n, e, t, r, i, s, o, a, l) { return n = Jd(t, r, !0, n, i, s, o, a, l), n.context = B0(null), t = n.current, r = ot(), i = rr(t), s = An(r, i), s.callback = e ?? null, tr(t, s, i), n.current.lanes = i, go(n, i, r), St(n, r), n } function vl (n, e, t, r) { const i = e.current; const s = ot(); const o = rr(i); return t = B0(t), e.context === null ? e.context = t : e.pendingContext = t, e = An(s, o), e.payload = { element: n }, r = r === void 0 ? null : r, r !== null && (e.callback = r), n = tr(i, e, o), n !== null && (Qt(n, i, o, s), ia(n, i, o)), o } function Ka (n) { if (n = n.current, !n.child) return null; switch (n.child.tag) { case 5:return n.child.stateNode; default:return n.child.stateNode } } function Kf (n, e) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { const t = n.retryLane; n.retryLane = t !== 0 && t < e ? t : e } } function Zd (n, e) { Kf(n, e), (n = n.alternate) && Kf(n, e) } function kT () { return null } const G0 = typeof reportError === 'function' ? reportError : function (n) { console.error(n) }; function eh (n) { this._internalRoot = n }El.prototype.render = eh.prototype.render = function (n) { const e = this._internalRoot; if (e === null) throw Error(U(409)); vl(n, e, null, null) }; El.prototype.unmount = eh.prototype.unmount = function () { const n = this._internalRoot; if (n !== null) { this._internalRoot = null; const e = n.containerInfo; Ur(function () { vl(null, n, null, null) }), e[Cn] = null } }; function El (n) { this._internalRoot = n }El.prototype.unstable_scheduleHydration = function (n) { if (n) { const e = vg(); n = { blockedOn: null, target: n, priority: e }; for (var t = 0; t < Un.length && e !== 0 && e < Un[t].priority; t++);Un.splice(t, 0, n), t === 0 && Sg(n) } }; function th (n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function Sl (n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== ' react-mount-point-unstable ')) } function jf () {} function PT (n, e, t, r, i) { if (i) { if (typeof r === 'function') { const s = r; r = function () { const u = Ka(o); s.call(u) } } var o = $0(e, r, n, 0, null, !1, !1, '', jf); return n._reactRootContainer = o, n[Cn] = o.current, Bs(n.nodeType === 8 ? n.parentNode : n), Ur(), o } for (;i = n.lastChild;)n.removeChild(i); if (typeof r === 'function') { const a = r; r = function () { const u = Ka(l); a.call(u) } } var l = Jd(n, 0, !1, null, null, !1, !1, '', jf); return n._reactRootContainer = l, n[Cn] = l.current, Bs(n.nodeType === 8 ? n.parentNode : n), Ur(function () { vl(e, l, t, r) }), l } function Tl (n, e, t, r, i) { const s = t._reactRootContainer; if (s) { var o = s; if (typeof i === 'function') { const a = i; i = function () { const l = Ka(o); a.call(l) } }vl(e, o, n, i) } else o = PT(t, e, n, i, r); return Ka(o) }gg = function (n) { switch (n.tag) { case 3:var e = n.stateNode; if (e.current.memoizedState.isDehydrated) { const t = ys(e.pendingLanes); t !== 0 && (Sd(e, t | 1), St(e, Ce()), !(oe & 6) && (Ki = Ce() + 500, cr())) } break; case 13:Ur(function () { const r = In(n, 1); if (r !== null) { const i = ot(); Qt(r, n, 1, i) } }), Zd(n, 1) } }; Td = function (n) { if (n.tag === 13) { const e = In(n, 134217728); if (e !== null) { const t = ot(); Qt(e, n, 134217728, t) }Zd(n, 134217728) } }; yg = function (n) { if (n.tag === 13) { const e = rr(n); const t = In(n, e); if (t !== null) { const r = ot(); Qt(t, n, e, r) }Zd(n, e) } }; vg = function () { return le }; Eg = function (n, e) { const t = le; try { return le = n, e() } finally { le = t } }; Wu = function (n, e, t) { switch (e) { case 'input':if ($u(n, t), e = t.name, t.type === 'radio' && e != null) { for (t = n; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll('input[name=' + JSON.stringify('' + e) + '][type="radio"]'), e = 0; e < t.length; e++) { const r = t[e]; if (r !== n && r.form === n.form) { const i = dl(r); if (!i) throw Error(U(90)); Qm(r), $u(r, i) } } } break; case 'textarea':Jm(n, t); break; case 'select':e = t.value, e != null && mi(n, !!t.multiple, e, !1) } }; sg = Yd; og = Ur; const bT = { usingClientEntryPoint: !1, Events: [vo, ai, dl, rg, ig, Yd] }; const ds = { findFiberByHostInstance: Er, bundleType: 0, version: '18.3.1', rendererPackageName: 'react-dom' }; const OT = { bundleType: ds.bundleType, version: ds.version, rendererPackageName: ds.rendererPackageName, rendererConfig: ds.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Dn.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return n = ug(n), n === null ? null : n.stateNode }, findFiberByHostInstance: ds.findFiberByHostInstance || kT, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: '18.3.1-next-f1338f8080-20240426' }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') { const $o = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!$o.isDisabled && $o.supportsFiber) try { al = $o.inject(OT), dn = $o } catch {} }It.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bT; It.createPortal = function (n, e) { const t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null; if (!th(e)) throw Error(U(200)); return DT(n, e, null, t) }; It.createRoot = function (n, e) { if (!th(n)) throw Error(U(299)); let t = !1; let r = ''; let i = G0; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = Jd(n, 1, !1, null, null, t, !1, r, i), n[Cn] = e.current, Bs(n.nodeType === 8 ? n.parentNode : n), new eh(e) }; It.findDOMNode = function (n) { if (n == null) return null; if (n.nodeType === 1) return n; const e = n._reactInternals; if (e === void 0) throw typeof n.render === 'function' ? Error(U(188)) : (n = Object.keys(n).join(','), Error(U(268, n))); return n = ug(e), n = n === null ? null : n.stateNode, n }; It.flushSync = function (n) { return Ur(n) }; It.hydrate = function (n, e, t) { if (!Sl(e)) throw Error(U(200)); return Tl(null, n, e, !0, t) }; It.hydrateRoot = function (n, e, t) { if (!th(n)) throw Error(U(405)); const r = t != null && t.hydratedSources || null; let i = !1; let s = ''; let o = G0; if (t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = $0(e, null, n, 1, t ?? null, i, !1, s, o), n[Cn] = e.current, Bs(n), r) for (n = 0; n < r.length; n++)t = r[n], i = t._getVersion, i = i(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, i] : e.mutableSourceEagerHydrationData.push(t, i); return new El(e) }; It.render = function (n, e, t) { if (!Sl(e)) throw Error(U(200)); return Tl(null, n, e, !1, t) }; It.unmountComponentAtNode = function (n) { if (!Sl(n)) throw Error(U(40)); return n._reactRootContainer ? (Ur(function () { Tl(null, null, n, !1, function () { n._reactRootContainer = null, n[Cn] = null }) }), !0) : !1 }; It.unstable_batchedUpdates = Yd; It.unstable_renderSubtreeIntoContainer = function (n, e, t, r) { if (!Sl(t)) throw Error(U(200)); if (n == null || n._reactInternals === void 0) throw Error(U(38)); return Tl(n, e, t, !1, r) }; It.version = '18.3.1-next-f1338f8080-20240426'; function V0 () { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function')) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(V0) } catch (n) { console.error(n) } }V0(), Vm.exports = It; const FT = Vm.exports; const zf = FT; bu.createRoot = zf.createRoot, bu.hydrateRoot = zf.hydrateRoot/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ys () { return Ys = Object.assign ? Object.assign.bind() : function (n) { for (let e = 1; e < arguments.length; e++) { const t = arguments[e]; for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, Ys.apply(this, arguments) } let Qn; (function (n) { n.Pop = 'POP', n.Push = 'PUSH', n.Replace = 'REPLACE' })(Qn || (Qn = {})); const Wf = 'popstate'; function MT (n) { n === void 0 && (n = {}); function e (i, s) { let { pathname: o = '/', search: a = '', hash: l = '' } = Hr(i.location.hash.substr(1)); return !o.startsWith('/') && !o.startsWith('.') && (o = '/' + o), wc('', { pathname: o, search: a, hash: l }, s.state && s.state.usr || null, s.state && s.state.key || 'default') } function t (i, s) { const o = i.document.querySelector('base'); let a = ''; if (o && o.getAttribute('href')) { const l = i.location.href; const u = l.indexOf('#'); a = u === -1 ? l : l.slice(0, u) } return a + '#' + (typeof s === 'string' ? s : ja(s)) } function r (i, s) { nh(i.pathname.charAt(0) === '/', 'relative pathnames are not supported in hash history.push(' + JSON.stringify(s) + ')') } return UT(e, t, r, n) } function Ie (n, e) { if (n === !1 || n === null || typeof n > 'u') throw new Error(e) } function nh (n, e) { if (!n) { typeof console < 'u' && console.warn(e); try { throw new Error(e) } catch {} } } function NT () { return Math.random().toString(36).substr(2, 8) } function Yf (n, e) { return { usr: n.state, key: n.key, idx: e } } function wc (n, e, t, r) { return t === void 0 && (t = null), Ys({ pathname: typeof n === 'string' ? n : n.pathname, search: '', hash: '' }, typeof e === 'string' ? Hr(e) : e, { state: t, key: e && e.key || r || NT() }) } function ja (n) { let { pathname: e = '/', search: t = '', hash: r = '' } = n; return t && t !== '?' && (e += t.charAt(0) === '?' ? t : '?' + t), r && r !== '#' && (e += r.charAt(0) === '#' ? r : '#' + r), e } function Hr (n) { const e = {}; if (n) { const t = n.indexOf('#'); t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t)); const r = n.indexOf('?'); r >= 0 && (e.search = n.substr(r), n = n.substr(0, r)), n && (e.pathname = n) } return e } function UT (n, e, t, r) { r === void 0 && (r = {}); const { window: i = document.defaultView, v5Compat: s = !1 } = r; const o = i.history; let a = Qn.Pop; let l = null; let u = c(); u == null && (u = 0, o.replaceState(Ys({}, o.state, { idx: u }), '')); function c () { return (o.state || { idx: null }).idx } function d () { a = Qn.Pop; const y = c(); const g = y == null ? null : y - u; u = y, l && l({ action: a, location: m.location, delta: g }) } function h (y, g) { a = Qn.Push; const v = wc(m.location, y, g); t && t(v, y), u = c() + 1; const E = Yf(v, u); const x = m.createHref(v); try { o.pushState(E, '', x) } catch (T) { if (T instanceof DOMException && T.name === 'DataCloneError') throw T; i.location.assign(x) }s && l && l({ action: a, location: m.location, delta: 1 }) } function f (y, g) { a = Qn.Replace; const v = wc(m.location, y, g); t && t(v, y), u = c(); const E = Yf(v, u); const x = m.createHref(v); o.replaceState(E, '', x), s && l && l({ action: a, location: m.location, delta: 0 }) } function p (y) { const g = i.location.origin !== 'null' ? i.location.origin : i.location.href; let v = typeof y === 'string' ? y : ja(y); return v = v.replace(/ $/, '%20'), Ie(g, 'No window.location.(origin|href) available to create URL for href: ' + v), new URL(v, g) } const m = { get action () { return a }, get location () { return n(i, o) }, listen (y) { if (l) throw new Error('A history only accepts one active listener'); return i.addEventListener(Wf, d), l = y, () => { i.removeEventListener(Wf, d), l = null } }, createHref (y) { return e(i, y) }, createURL: p, encodeLocation (y) { const g = p(y); return { pathname: g.pathname, search: g.search, hash: g.hash } }, push: h, replace: f, go (y) { return o.go(y) } }; return m } let qf; (function (n) { n.data = 'data', n.deferred = 'deferred', n.redirect = 'redirect', n.error = 'error' })(qf || (qf = {})); function BT (n, e, t) { t === void 0 && (t = '/'); const r = typeof e === 'string' ? Hr(e) : e; const i = rh(r.pathname || '/', t); if (i == null) return null; const s = H0(n); $T(s); let o = null; for (let a = 0; o == null && a < s.length; ++a) { const l = JT(i); o = qT(s[a], l) } return o } function H0 (n, e, t, r) { e === void 0 && (e = []), t === void 0 && (t = []), r === void 0 && (r = ''); const i = (s, o, a) => { const l = { relativePath: a === void 0 ? s.path || '' : a, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; l.relativePath.startsWith('/') && (Ie(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + 'must start with the combined path of all its parent routes.'), l.relativePath = l.relativePath.slice(r.length)); const u = sr([r, l.relativePath]); const c = t.concat(l); s.children && s.children.length > 0 && (Ie(s.index !== !0, 'Index routes must not have child routes. Please remove ' + ('all child routes from route path "' + u + '".')), H0(s.children, e, c, u)), !(s.path == null && !s.index) && e.push({ path: u, score: WT(u, s.index), routesMeta: c }) }; return n.forEach((s, o) => { let a; if (s.path === '' || !((a = s.path) != null && a.includes('?')))i(s, o); else for (const l of K0(s.path))i(s, o, l) }), e } function K0 (n) { const e = n.split('/'); if (e.length === 0) return []; const [t, ...r] = e; const i = t.endsWith('?'); const s = t.replace(/\?$/, ''); if (r.length === 0) return i ? [s, ''] : [s]; const o = K0(r.join('/')); const a = []; return a.push(...o.map(l => l === '' ? s : [s, l].join('/'))), i && a.push(...o), a.map(l => n.startsWith('/') && l === '' ? '/' : l) } function $T (n) { n.sort((e, t) => e.score !== t.score ? t.score - e.score : YT(e.routesMeta.map(r => r.childrenIndex), t.routesMeta.map(r => r.childrenIndex))) } const GT = /^:[\w-]+$/; const VT = 3; const HT = 2; const KT = 1; const jT = 10; const zT = -2; const Qf = n => n === '*'; function WT (n, e) { const t = n.split('/'); let r = t.length; return t.some(Qf) && (r += zT), e && (r += HT), t.filter(i => !Qf(i)).reduce((i, s) => i + (GT.test(s) ? VT : s === '' ? KT : jT), r) } function YT (n, e) { return n.length === e.length && n.slice(0, -1).every((r, i) => r === e[i]) ? n[n.length - 1] - e[e.length - 1] : 0 } function qT (n, e) { const { routesMeta: t } = n; const r = {}; let i = '/'; const s = []; for (let o = 0; o < t.length; ++o) { const a = t[o]; const l = o === t.length - 1; const u = i === '/' ? e : e.slice(i.length) || '/'; const c = QT({ path: a.relativePath, caseSensitive: a.caseSensitive, end: l }, u); if (!c) return null; Object.assign(r, c.params); const d = a.route; s.push({ params: r, pathname: sr([i, c.pathname]), pathnameBase: nx(sr([i, c.pathnameBase])), route: d }), c.pathnameBase !== '/' && (i = sr([i, c.pathnameBase])) } return s } function QT (n, e) { typeof n === 'string' && (n = { path: n, caseSensitive: !1, end: !0 }); const [t, r] = XT(n.path, n.caseSensitive, n.end); const i = e.match(t); if (!i) return null; const s = i[0]; let o = s.replace(/(.)\/+$/, '$1'); const a = i.slice(1); return { params: r.reduce((u, c, d) => { const { paramName: h, isOptional: f } = c; if (h === '*') { const m = a[d] || ''; o = s.slice(0, s.length - m.length).replace(/(.)\/+$/, '$1') } const p = a[d]; return f && !p ? u[h] = void 0 : u[h] = (p || '').replace(/%2F/g, '/'), u }, {}), pathname: s, pathnameBase: o, pattern: n } } function XT (n, e, t) { e === void 0 && (e = !1), t === void 0 && (t = !0), nh(n === '*' || !n.endsWith('*') || n.endsWith('/*'), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, '/*') + '" because the `*` character must ') + 'always follow a `/` in the pattern. To get rid of this warning, ' + ('please change the route path to "' + n.replace(/\*$/, '/*') + '".')); const r = []; let i = '^' + n.replace(/\/*\*?$/, '').replace(/^\/*/, '/').replace(/[\\.*+^${}|()[\]]/g, '\\$&').replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? '/?([^\\/]+)?' : '/([^\\/]+)')); return n.endsWith('*') ? (r.push({ paramName: '*' }), i += n === '*' || n === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$') : t ? i += '\\/*$' : n !== '' && n !== '/' && (i += '(?:(?=\\/|$))'), [new RegExp(i, e ? void 0 : 'i'), r] } function JT (n) { try { return n.split('/').map(e => decodeURIComponent(e).replace(/\//g, '%2F')).join('/') } catch (e) { return nh(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ('encoding (' + e + ').')), n } } function rh (n, e) { if (e === '/') return n; if (!n.toLowerCase().startsWith(e.toLowerCase())) return null; const t = e.endsWith('/') ? e.length - 1 : e.length; const r = n.charAt(t); return r && r !== '/' ? null : n.slice(t) || '/' } function ZT (n, e) { e === void 0 && (e = '/'); const { pathname: t, search: r = '', hash: i = '' } = typeof n === 'string' ? Hr(n) : n; return { pathname: t ? t.startsWith('/') ? t : ex(t, e) : e, search: rx(r), hash: ix(i) } } function ex (n, e) { const t = e.replace(/\/+$/, '').split('/'); return n.split('/').forEach(i => { i === '..' ? t.length > 1 && t.pop() : i !== '.' && t.push(i) }), t.length > 1 ? t.join('/') : '/' } function su (n, e, t, r) { return "Cannot include a '" + n + "' character in a manually specified " + ('`to.' + e + '` field [' + JSON.stringify(r) + '].  Please separate it out to the ') + ('`to.' + t + '` field. Alternatively you may provide the full path as ') + 'a string in <Link to="..."> and the router will parse it for you.' } function tx (n) { return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0) } function ih (n, e) { const t = tx(n); return e ? t.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : t.map(r => r.pathnameBase) } function sh (n, e, t, r) { r === void 0 && (r = !1); let i; typeof n === 'string' ? i = Hr(n) : (i = Ys({}, n), Ie(!i.pathname || !i.pathname.includes('?'), su('?', 'pathname', 'search', i)), Ie(!i.pathname || !i.pathname.includes('#'), su('#', 'pathname', 'hash', i)), Ie(!i.search || !i.search.includes('#'), su('#', 'search', 'hash', i))); const s = n === '' || i.pathname === ''; const o = s ? '/' : i.pathname; let a; if (o == null)a = t; else { let d = e.length - 1; if (!r && o.startsWith('..')) { const h = o.split('/'); for (;h[0] === '..';)h.shift(), d -= 1; i.pathname = h.join('/') }a = d >= 0 ? e[d] : '/' } const l = ZT(i, a); const u = o && o !== '/' && o.endsWith('/'); const c = (s || o === '.') && t.endsWith('/'); return !l.pathname.endsWith('/') && (u || c) && (l.pathname += '/'), l } const sr = n => n.join('/').replace(/\/\/+/g, '/'); const nx = n => n.replace(/\/+$/, '').replace(/^\/*/, '/'); const rx = n => !n || n === '?' ? '' : n.startsWith('?') ? n : '?' + n; const ix = n => !n || n === '#' ? '' : n.startsWith('#') ? n : '#' + n; function sx (n) { return n != null && typeof n.status === 'number' && typeof n.statusText === 'string' && typeof n.internal === 'boolean' && 'data' in n } const j0 = ['post', 'put', 'patch', 'delete']; new Set(j0); const ox = ['get', ...j0]; new Set(ox)/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function qs () { return qs = Object.assign ? Object.assign.bind() : function (n) { for (let e = 1; e < arguments.length; e++) { const t = arguments[e]; for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, qs.apply(this, arguments) } const oh = k.createContext(null); const ax = k.createContext(null); const dr = k.createContext(null); const xl = k.createContext(null); const kn = k.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const z0 = k.createContext(null); function lx (n, e) { const { relative: t } = e === void 0 ? {} : e; es() || Ie(!1); const { basename: r, navigator: i } = k.useContext(dr); const { hash: s, pathname: o, search: a } = q0(n, { relative: t }); let l = o; return r !== '/' && (l = o === '/' ? r : sr([r, o])), i.createHref({ pathname: l, search: a, hash: s }) } function es () { return k.useContext(xl) != null } function ts () { return es() || Ie(!1), k.useContext(xl).location } function W0 (n) { k.useContext(dr).static || k.useLayoutEffect(n) } function Y0 () { const { isDataRoute: n } = k.useContext(kn); return n ? Lx() : ux() } function ux () { es() || Ie(!1); const n = k.useContext(oh); const { basename: e, future: t, navigator: r } = k.useContext(dr); const { matches: i } = k.useContext(kn); const { pathname: s } = ts(); const o = JSON.stringify(ih(i, t.v7_relativeSplatPath)); const a = k.useRef(!1); return W0(() => { a.current = !0 }), k.useCallback(function (u, c) { if (c === void 0 && (c = {}), !a.current) return; if (typeof u === 'number') { r.go(u); return } const d = sh(u, JSON.parse(o), s, c.relative === 'path'); n == null && e !== '/' && (d.pathname = d.pathname === '/' ? e : sr([e, d.pathname])), (c.replace ? r.replace : r.push)(d, c.state, c) }, [e, r, o, s, n]) } const cx = k.createContext(null); function dx (n) { const e = k.useContext(kn).outlet; return e && k.createElement(cx.Provider, { value: n }, e) } function q0 (n, e) { const { relative: t } = e === void 0 ? {} : e; const { future: r } = k.useContext(dr); const { matches: i } = k.useContext(kn); const { pathname: s } = ts(); const o = JSON.stringify(ih(i, r.v7_relativeSplatPath)); return k.useMemo(() => sh(n, JSON.parse(o), s, t === 'path'), [n, o, s, t]) } function hx (n, e) { return fx(n, e) } function fx (n, e, t, r) { es() || Ie(!1); const { navigator: i } = k.useContext(dr); const { matches: s } = k.useContext(kn); const o = s[s.length - 1]; const a = o ? o.params : {}; o && o.pathname; const l = o ? o.pathnameBase : '/'; o && o.route; const u = ts(); let c; if (e) { let d; const y = typeof e === 'string' ? Hr(e) : e; l === '/' || (d = y.pathname) != null && d.startsWith(l) || Ie(!1), c = y } else c = u; const h = c.pathname || '/'; let f = h; if (l !== '/') { const y = l.replace(/^\//, '').split('/'); f = '/' + h.replace(/^\//, '').split('/').slice(y.length).join('/') } const p = BT(n, { pathname: f }); const m = vx(p && p.map(y => Object.assign({}, y, { params: Object.assign({}, a, y.params), pathname: sr([l, i.encodeLocation ? i.encodeLocation(y.pathname).pathname : y.pathname]), pathnameBase: y.pathnameBase === '/' ? l : sr([l, i.encodeLocation ? i.encodeLocation(y.pathnameBase).pathname : y.pathnameBase]) })), s, t, r); return e && m ? k.createElement(xl.Provider, { value: { location: qs({ pathname: '/', search: '', hash: '', state: null, key: 'default' }, c), navigationType: Qn.Pop } }, m) : m } function px () { const n = xx(); const e = sx(n) ? n.status + ' ' + n.statusText : n instanceof Error ? n.message : JSON.stringify(n); const t = n instanceof Error ? n.stack : null; const i = { padding: '0.5rem', backgroundColor: 'rgba(200,200,200, 0.5)' }; return k.createElement(k.Fragment, null, k.createElement('h2', null, 'Unexpected Application Error!'), k.createElement('h3', { style: { fontStyle: 'italic' } }, e), t ? k.createElement('pre', { style: i }, t) : null, null) } const mx = k.createElement(px, null); class gx extends k.Component {constructor (e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError (e) { return { error: e } } static getDerivedStateFromProps (e, t) { return t.location !== e.location || t.revalidation !== 'idle' && e.revalidation === 'idle' ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } }componentDidCatch (e, t) { console.error('React Router caught the following error during render', e, t) }render () { return this.state.error !== void 0 ? k.createElement(kn.Provider, { value: this.props.routeContext }, k.createElement(z0.Provider, { value: this.state.error, children: this.props.component })) : this.props.children }} function yx (n) { const { routeContext: e, match: t, children: r } = n; const i = k.useContext(oh); return i && i.static && i.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = t.route.id), k.createElement(kn.Provider, { value: e }, r) } function vx (n, e, t, r) { let i; if (e === void 0 && (e = []), t === void 0 && (t = null), r === void 0 && (r = null), n == null) { let s; if ((s = t) != null && s.errors)n = t.matches; else return null } let o = n; const a = (i = t) == null ? void 0 : i.errors; if (a != null) { const c = o.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); c >= 0 || Ie(!1), o = o.slice(0, Math.min(o.length, c + 1)) } let l = !1; let u = -1; if (t && r && r.v7_partialHydration) for (let c = 0; c < o.length; c++) { const d = o[c]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (u = c), d.route.id) { const { loaderData: h, errors: f } = t; const p = d.route.loader && h[d.route.id] === void 0 && (!f || f[d.route.id] === void 0); if (d.route.lazy || p) { l = !0, u >= 0 ? o = o.slice(0, u + 1) : o = [o[0]]; break } } } return o.reduceRight((c, d, h) => { let f; let p = !1; let m = null; let y = null; t && (f = a && d.route.id ? a[d.route.id] : void 0, m = d.route.errorElement || mx, l && (u < 0 && h === 0 ? (p = !0, y = null) : u === h && (p = !0, y = d.route.hydrateFallbackElement || null))); const g = e.concat(o.slice(0, h + 1)); const v = () => { let E; return f ? E = m : p ? E = y : d.route.Component ? E = k.createElement(d.route.Component, null) : d.route.element ? E = d.route.element : E = c, k.createElement(yx, { match: d, routeContext: { outlet: c, matches: g, isDataRoute: t != null }, children: E }) }; return t && (d.route.ErrorBoundary || d.route.errorElement || h === 0) ? k.createElement(gx, { location: t.location, revalidation: t.revalidation, component: m, error: f, children: v(), routeContext: { outlet: null, matches: g, isDataRoute: !0 } }) : v() }, null) } var Q0 = (function (n) { return n.UseBlocker = 'useBlocker', n.UseRevalidator = 'useRevalidator', n.UseNavigateStable = 'useNavigate', n }(Q0 || {})); var za = (function (n) { return n.UseBlocker = 'useBlocker', n.UseLoaderData = 'useLoaderData', n.UseActionData = 'useActionData', n.UseRouteError = 'useRouteError', n.UseNavigation = 'useNavigation', n.UseRouteLoaderData = 'useRouteLoaderData', n.UseMatches = 'useMatches', n.UseRevalidator = 'useRevalidator', n.UseNavigateStable = 'useNavigate', n.UseRouteId = 'useRouteId', n }(za || {})); function Ex (n) { const e = k.useContext(oh); return e || Ie(!1), e } function Sx (n) { const e = k.useContext(ax); return e || Ie(!1), e } function Tx (n) { const e = k.useContext(kn); return e || Ie(!1), e } function X0 (n) { const e = Tx(); const t = e.matches[e.matches.length - 1]; return t.route.id || Ie(!1), t.route.id } function xx () { let n; const e = k.useContext(z0); const t = Sx(za.UseRouteError); const r = X0(za.UseRouteError); return e !== void 0 ? e : (n = t.errors) == null ? void 0 : n[r] } function Lx () { const { router: n } = Ex(Q0.UseNavigateStable); const e = X0(za.UseNavigateStable); const t = k.useRef(!1); return W0(() => { t.current = !0 }), k.useCallback(function (i, s) { s === void 0 && (s = {}), t.current && (typeof i === 'number' ? n.navigate(i) : n.navigate(i, qs({ fromRouteId: e }, s))) }, [n, e]) } function Rx (n) { const { to: e, replace: t, state: r, relative: i } = n; es() || Ie(!1); const { future: s, static: o } = k.useContext(dr); const { matches: a } = k.useContext(kn); const { pathname: l } = ts(); const u = Y0(); const c = sh(e, ih(a, s.v7_relativeSplatPath), l, i === 'path'); const d = JSON.stringify(c); return k.useEffect(() => u(JSON.parse(d), { replace: t, state: r, relative: i }), [u, d, i, t, r]), null } function Ax (n) { return dx(n.context) } function ei (n) { Ie(!1) } function wx (n) { let { basename: e = '/', children: t = null, location: r, navigationType: i = Qn.Pop, navigator: s, static: o = !1, future: a } = n; es() && Ie(!1); const l = e.replace(/^\/*/, '/'); const u = k.useMemo(() => ({ basename: l, navigator: s, static: o, future: qs({ v7_relativeSplatPath: !1 }, a) }), [l, a, s, o]); typeof r === 'string' && (r = Hr(r)); const { pathname: c = '/', search: d = '', hash: h = '', state: f = null, key: p = 'default' } = r; const m = k.useMemo(() => { const y = rh(c, l); return y == null ? null : { location: { pathname: y, search: d, hash: h, state: f, key: p }, navigationType: i } }, [l, c, d, h, f, p, i]); return m == null ? null : k.createElement(dr.Provider, { value: u }, k.createElement(xl.Provider, { children: t, value: m })) } function Cx (n) { const { children: e, location: t } = n; return hx(Cc(e), t) } new Promise(() => {}); function Cc (n, e) { e === void 0 && (e = []); const t = []; return k.Children.forEach(n, (r, i) => { if (!k.isValidElement(r)) return; const s = [...e, i]; if (r.type === k.Fragment) { t.push.apply(t, Cc(r.props.children, s)); return }r.type !== ei && Ie(!1), !r.props.index || !r.props.children || Ie(!1); const o = { id: r.props.id || s.join('-'), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (o.children = Cc(r.props.children, s)), t.push(o) }), t }/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ic () { return Ic = Object.assign ? Object.assign.bind() : function (n) { for (let e = 1; e < arguments.length; e++) { const t = arguments[e]; for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, Ic.apply(this, arguments) } function Ix (n, e) { if (n == null) return {}; const t = {}; const r = Object.keys(n); let i; let s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (t[i] = n[i]); return t } function _x (n) { return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) } function Dx (n, e) { return n.button === 0 && (!e || e === '_self') && !_x(n) } const kx = ['onClick', 'relative', 'reloadDocument', 'replace', 'state', 'target', 'to', 'preventScrollReset', 'unstable_viewTransition']; const Px = '6'; try { window.__reactRouterVersion = Px } catch {} const bx = 'startTransition'; const Xf = RE[bx]; function Ox (n) { const { basename: e, children: t, future: r, window: i } = n; const s = k.useRef(); s.current == null && (s.current = MT({ window: i, v5Compat: !0 })); const o = s.current; const [a, l] = k.useState({ action: o.action, location: o.location }); const { v7_startTransition: u } = r || {}; const c = k.useCallback(d => { u && Xf ? Xf(() => l(d)) : l(d) }, [l, u]); return k.useLayoutEffect(() => o.listen(c), [o, c]), k.createElement(wx, { basename: e, children: t, location: a.location, navigationType: a.action, navigator: o, future: r }) } const Fx = typeof window < 'u' && typeof window.document < 'u' && typeof window.document.createElement < 'u'; const Mx = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i; const ou = k.forwardRef(function (e, t) { let { onClick: r, relative: i, reloadDocument: s, replace: o, state: a, target: l, to: u, preventScrollReset: c, unstable_viewTransition: d } = e; const h = Ix(e, kx); const { basename: f } = k.useContext(dr); let p; let m = !1; if (typeof u === 'string' && Mx.test(u) && (p = u, Fx)) try { const E = new URL(window.location.href); const x = u.startsWith('//') ? new URL(E.protocol + u) : new URL(u); const T = rh(x.pathname, f); x.origin === E.origin && T != null ? u = T + x.search + x.hash : m = !0 } catch {} const y = lx(u, { relative: i }); const g = Nx(u, { replace: o, state: a, target: l, preventScrollReset: c, relative: i, unstable_viewTransition: d }); function v (E) { r && r(E), E.defaultPrevented || g(E) } return k.createElement('a', Ic({}, h, { href: p || y, onClick: m || s ? r : v, ref: t, target: l })) }); let Jf; (function (n) { n.UseScrollRestoration = 'useScrollRestoration', n.UseSubmit = 'useSubmit', n.UseSubmitFetcher = 'useSubmitFetcher', n.UseFetcher = 'useFetcher', n.useViewTransitionState = 'useViewTransitionState' })(Jf || (Jf = {})); let Zf; (function (n) { n.UseFetcher = 'useFetcher', n.UseFetchers = 'useFetchers', n.UseScrollRestoration = 'useScrollRestoration' })(Zf || (Zf = {})); function Nx (n, e) { const { target: t, replace: r, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a } = e === void 0 ? {} : e; const l = Y0(); const u = ts(); const c = q0(n, { relative: o }); return k.useCallback(d => { if (Dx(d, t)) { d.preventDefault(); const h = r !== void 0 ? r : ja(u) === ja(c); l(n, { replace: h, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a }) } }, [u, l, c, r, i, t, n, s, o, a]) } const ns = class {constructor () { this.listeners = new Set(), this.subscribe = this.subscribe.bind(this) }subscribe (n) { return this.listeners.add(n), this.onSubscribe(), () => { this.listeners.delete(n), this.onUnsubscribe() } }hasListeners () { return this.listeners.size > 0 }onSubscribe () {}onUnsubscribe () {}}; const ji = typeof window > 'u' || 'Deno' in globalThis; function Pt () {} function Ux (n, e) { return typeof n === 'function' ? n(e) : n } function _c (n) { return typeof n === 'number' && n >= 0 && n !== 1 / 0 } function J0 (n, e) { return Math.max(n + (e || 0) - Date.now(), 0) } function ep (n, e) { const { type: t = 'all', exact: r, fetchStatus: i, predicate: s, queryKey: o, stale: a } = n; if (o) { if (r) { if (e.queryHash !== ah(o, e.options)) return !1 } else if (!Qs(e.queryKey, o)) return !1 } if (t !== 'all') { const l = e.isActive(); if (t === 'active' && !l || t === 'inactive' && l) return !1 } return !(typeof a === 'boolean' && e.isStale() !== a || i && i !== e.state.fetchStatus || s && !s(e)) } function tp (n, e) { const { exact: t, status: r, predicate: i, mutationKey: s } = n; if (s) { if (!e.options.mutationKey) return !1; if (t) { if (Br(e.options.mutationKey) !== Br(s)) return !1 } else if (!Qs(e.options.mutationKey, s)) return !1 } return !(r && e.state.status !== r || i && !i(e)) } function ah (n, e) { return ((e == null ? void 0 : e.queryKeyHashFn) || Br)(n) } function Br (n) { return JSON.stringify(n, (e, t) => Dc(t) ? Object.keys(t).sort().reduce((r, i) => (r[i] = t[i], r), {}) : t) } function Qs (n, e) { return n === e ? !0 : typeof n !== typeof e ? !1 : n && e && typeof n === 'object' && typeof e === 'object' ? !Object.keys(e).some(t => !Qs(n[t], e[t])) : !1 } function Z0 (n, e) { if (n === e) return n; const t = np(n) && np(e); if (t || Dc(n) && Dc(e)) { const r = t ? n : Object.keys(n); const i = r.length; const s = t ? e : Object.keys(e); const o = s.length; const a = t ? [] : {}; let l = 0; for (let u = 0; u < o; u++) { const c = t ? u : s[u]; (!t && r.includes(c) || t) && n[c] === void 0 && e[c] === void 0 ? (a[c] = void 0, l++) : (a[c] = Z0(n[c], e[c]), a[c] === n[c] && n[c] !== void 0 && l++) } return i === o && l === i ? n : a } return e } function Wa (n, e) { if (!e || Object.keys(n).length !== Object.keys(e).length) return !1; for (const t in n) if (n[t] !== e[t]) return !1; return !0 } function np (n) { return Array.isArray(n) && n.length === Object.keys(n).length } function Dc (n) { if (!rp(n)) return !1; const e = n.constructor; if (e === void 0) return !0; const t = e.prototype; return !(!rp(t) || !t.hasOwnProperty('isPrototypeOf') || Object.getPrototypeOf(n) !== Object.prototype) } function rp (n) { return Object.prototype.toString.call(n) === '[object Object]' } function Bx (n) { return new Promise(e => { setTimeout(e, n) }) } function kc (n, e, t) { return typeof t.structuralSharing === 'function' ? t.structuralSharing(n, e) : t.structuralSharing !== !1 ? Z0(n, e) : e } function $x (n, e, t = 0) { const r = [...n, e]; return t && r.length > t ? r.slice(1) : r } function Gx (n, e, t = 0) { const r = [e, ...n]; return t && r.length > t ? r.slice(0, -1) : r } const lh = Symbol(); let Lr; let $n; let Ri; let Sm; const Vx = (Sm = class extends ns {constructor () { super(); j(this, Lr, void 0); j(this, $n, void 0); j(this, Ri, void 0); V(this, Ri, e => { if (!ji && window.addEventListener) { const t = () => e(); return window.addEventListener('visibilitychange', t, !1), () => { window.removeEventListener('visibilitychange', t) } } }) }onSubscribe () { R(this, $n) || this.setEventListener(R(this, Ri)) }onUnsubscribe () { let e; this.hasListeners() || ((e = R(this, $n)) == null || e.call(this), V(this, $n, void 0)) }setEventListener (e) { let t; V(this, Ri, e), (t = R(this, $n)) == null || t.call(this), V(this, $n, e(r => { typeof r === 'boolean' ? this.setFocused(r) : this.onFocus() })) }setFocused (e) { R(this, Lr) !== e && (V(this, Lr, e), this.onFocus()) }onFocus () { const e = this.isFocused(); this.listeners.forEach(t => { t(e) }) }isFocused () { let e; return typeof R(this, Lr) === 'boolean' ? R(this, Lr) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== 'hidden' }}, Lr = new WeakMap(), $n = new WeakMap(), Ri = new WeakMap(), Sm); const uh = new Vx(); let Ai; let Gn; let wi; let Tm; const Hx = (Tm = class extends ns {constructor () { super(); j(this, Ai, !0); j(this, Gn, void 0); j(this, wi, void 0); V(this, wi, e => { if (!ji && window.addEventListener) { const t = () => e(!0); const r = () => e(!1); return window.addEventListener('online', t, !1), window.addEventListener('offline', r, !1), () => { window.removeEventListener('online', t), window.removeEventListener('offline', r) } } }) }onSubscribe () { R(this, Gn) || this.setEventListener(R(this, wi)) }onUnsubscribe () { let e; this.hasListeners() || ((e = R(this, Gn)) == null || e.call(this), V(this, Gn, void 0)) }setEventListener (e) { let t; V(this, wi, e), (t = R(this, Gn)) == null || t.call(this), V(this, Gn, e(this.setOnline.bind(this))) }setOnline (e) { R(this, Ai) !== e && (V(this, Ai, e), this.listeners.forEach(r => { r(e) })) }isOnline () { return R(this, Ai) }}, Ai = new WeakMap(), Gn = new WeakMap(), wi = new WeakMap(), Tm); const Ya = new Hx(); function Kx (n) { return Math.min(1e3 * 2 ** n, 3e4) } function ey (n) { return (n ?? 'online') === 'online' ? Ya.isOnline() : !0 } const ty = class {constructor (n) { this.revert = n == null ? void 0 : n.revert, this.silent = n == null ? void 0 : n.silent }}; function au (n) { return n instanceof ty } function ny (n) { let e = !1; let t = 0; let r = !1; let i; let s; let o; const a = new Promise((g, v) => { s = g, o = v }); const l = g => { let v; r || (p(new ty(g)), (v = n.abort) == null || v.call(n)) }; const u = () => { e = !0 }; const c = () => { e = !1 }; const d = () => uh.isFocused() && (n.networkMode === 'always' || Ya.isOnline()) && n.canRun(); const h = () => ey(n.networkMode) && n.canRun(); const f = g => { let v; r || (r = !0, (v = n.onSuccess) == null || v.call(n, g), i == null || i(), s(g)) }; const p = g => { let v; r || (r = !0, (v = n.onError) == null || v.call(n, g), i == null || i(), o(g)) }; const m = () => new Promise(g => { let v; i = E => { (r || d()) && g(E) }, (v = n.onPause) == null || v.call(n) }).then(() => { let g; i = void 0, r || (g = n.onContinue) == null || g.call(n) }); const y = () => { if (r) return; let g; try { g = n.fn() } catch (v) { g = Promise.reject(v) }Promise.resolve(g).then(f).catch(v => { let L; if (r) return; const E = n.retry ?? (ji ? 0 : 3); const x = n.retryDelay ?? Kx; const T = typeof x === 'function' ? x(t, v) : x; const w = E === !0 || typeof E === 'number' && t < E || typeof E === 'function' && E(t, v); if (e || !w) { p(v); return }t++, (L = n.onFail) == null || L.call(n, t, v), Bx(T).then(() => d() ? void 0 : m()).then(() => { e ? p(v) : y() }) }) }; return { promise: a, cancel: l, continue: () => (i == null || i(), a), cancelRetry: u, continueRetry: c, canStart: h, start: () => (h() ? y() : m().then(y), a) } } function jx () { let n = []; let e = 0; let t = h => { h() }; let r = h => { h() }; let i = h => setTimeout(h, 0); const s = h => { i = h }; const o = h => { let f; e++; try { f = h() } finally { e--, e || u() } return f }; const a = h => { e ? n.push(h) : i(() => { t(h) }) }; const l = h => (...f) => { a(() => { h(...f) }) }; const u = () => { const h = n; n = [], h.length && i(() => { r(() => { h.forEach(f => { t(f) }) }) }) }; return { batch: o, batchCalls: l, schedule: a, setNotifyFunction: h => { t = h }, setBatchNotifyFunction: h => { r = h }, setScheduler: s } } const Oe = jx(); let Rr; let xm; const ry = (xm = class {constructor () { j(this, Rr, void 0) }destroy () { this.clearGcTimeout() }scheduleGc () { this.clearGcTimeout(), _c(this.gcTime) && V(this, Rr, setTimeout(() => { this.optionalRemove() }, this.gcTime)) }updateGcTime (n) { this.gcTime = Math.max(this.gcTime || 0, n ?? (ji ? 1 / 0 : 5 * 60 * 1e3)) }clearGcTimeout () { R(this, Rr) && (clearTimeout(R(this, Rr)), V(this, Rr, void 0)) }}, Rr = new WeakMap(), xm); let Ci; let Ii; let kt; let nt; let no; let Ar; let jt; let yn; let Lm; const zx = (Lm = class extends ry {constructor (e) { super(); j(this, jt); j(this, Ci, void 0); j(this, Ii, void 0); j(this, kt, void 0); j(this, nt, void 0); j(this, no, void 0); j(this, Ar, void 0); V(this, Ar, !1), V(this, no, e.defaultOptions), this.setOptions(e.options), this.observers = [], V(this, kt, e.cache), this.queryKey = e.queryKey, this.queryHash = e.queryHash, V(this, Ci, e.state || Wx(this.options)), this.state = R(this, Ci), this.scheduleGc() } get meta () { return this.options.meta }setOptions (e) { this.options = { ...R(this, no), ...e }, this.updateGcTime(this.options.gcTime) }optionalRemove () { !this.observers.length && this.state.fetchStatus === 'idle' && R(this, kt).remove(this) }setData (e, t) { const r = kc(this.state.data, e, this.options); return te(this, jt, yn).call(this, { data: r, type: 'success', dataUpdatedAt: t == null ? void 0 : t.updatedAt, manual: t == null ? void 0 : t.manual }), r }setState (e, t) { te(this, jt, yn).call(this, { type: 'setState', state: e, setStateOptions: t }) }cancel (e) { let r, i; const t = (r = R(this, nt)) == null ? void 0 : r.promise; return (i = R(this, nt)) == null || i.cancel(e), t ? t.then(Pt).catch(Pt) : Promise.resolve() }destroy () { super.destroy(), this.cancel({ silent: !0 }) }reset () { this.destroy(), this.setState(R(this, Ci)) }isActive () { return this.observers.some(e => e.options.enabled !== !1) }isDisabled () { return this.getObserversCount() > 0 && !this.isActive() }isStale () { return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0 }isStaleByTime (e = 0) { return this.state.isInvalidated || this.state.data === void 0 || !J0(this.state.dataUpdatedAt, e) }onFocus () { let t; const e = this.observers.find(r => r.shouldFetchOnWindowFocus()); e == null || e.refetch({ cancelRefetch: !1 }), (t = R(this, nt)) == null || t.continue() }onOnline () { let t; const e = this.observers.find(r => r.shouldFetchOnReconnect()); e == null || e.refetch({ cancelRefetch: !1 }), (t = R(this, nt)) == null || t.continue() }addObserver (e) { this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), R(this, kt).notify({ type: 'observerAdded', query: this, observer: e })) }removeObserver (e) { this.observers.includes(e) && (this.observers = this.observers.filter(t => t !== e), this.observers.length || (R(this, nt) && (R(this, Ar) ? R(this, nt).cancel({ revert: !0 }) : R(this, nt).cancelRetry()), this.scheduleGc()), R(this, kt).notify({ type: 'observerRemoved', query: this, observer: e })) }getObserversCount () { return this.observers.length }invalidate () { this.state.isInvalidated || te(this, jt, yn).call(this, { type: 'invalidate' }) }fetch (e, t) { let u, c, d; if (this.state.fetchStatus !== 'idle') { if (this.state.data !== void 0 && (t != null && t.cancelRefetch)) this.cancel({ silent: !0 }); else if (R(this, nt)) return R(this, nt).continueRetry(), R(this, nt).promise } if (e && this.setOptions(e), !this.options.queryFn) { const h = this.observers.find(f => f.options.queryFn); h && this.setOptions(h.options) } const r = new AbortController(); const i = { queryKey: this.queryKey, meta: this.meta }; const s = h => { Object.defineProperty(h, 'signal', { enumerable: !0, get: () => (V(this, Ar, !0), r.signal) }) }; s(i); const o = () => !this.options.queryFn || this.options.queryFn === lh ? Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`)) : (V(this, Ar, !1), this.options.persister ? this.options.persister(this.options.queryFn, i, this) : this.options.queryFn(i)); const a = { fetchOptions: t, options: this.options, queryKey: this.queryKey, state: this.state, fetchFn: o }; s(a), (u = this.options.behavior) == null || u.onFetch(a, this), V(this, Ii, this.state), (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((c = a.fetchOptions) == null ? void 0 : c.meta)) && te(this, jt, yn).call(this, { type: 'fetch', meta: (d = a.fetchOptions) == null ? void 0 : d.meta }); const l = h => { let f, p, m, y; au(h) && h.silent || te(this, jt, yn).call(this, { type: 'error', error: h }), au(h) || ((p = (f = R(this, kt).config).onError) == null || p.call(f, h, this), (y = (m = R(this, kt).config).onSettled) == null || y.call(m, this.state.data, h, this)), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1 }; return V(this, nt, ny({ fn: a.fetchFn, abort: r.abort.bind(r), onSuccess: h => { let f, p, m, y; if (h === void 0) { l(new Error(`${this.queryHash} data is undefined`)); return } this.setData(h), (p = (f = R(this, kt).config).onSuccess) == null || p.call(f, h, this), (y = (m = R(this, kt).config).onSettled) == null || y.call(m, h, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1 }, onError: l, onFail: (h, f) => { te(this, jt, yn).call(this, { type: 'failed', failureCount: h, error: f }) }, onPause: () => { te(this, jt, yn).call(this, { type: 'pause' }) }, onContinue: () => { te(this, jt, yn).call(this, { type: 'continue' }) }, retry: a.options.retry, retryDelay: a.options.retryDelay, networkMode: a.options.networkMode, canRun: () => !0 })), R(this, nt).start() }}, Ci = new WeakMap(), Ii = new WeakMap(), kt = new WeakMap(), nt = new WeakMap(), no = new WeakMap(), Ar = new WeakMap(), jt = new WeakSet(), yn = function (e) { const t = r => { switch (e.type) { case 'failed':return { ...r, fetchFailureCount: e.failureCount, fetchFailureReason: e.error }; case 'pause':return { ...r, fetchStatus: 'paused' }; case 'continue':return { ...r, fetchStatus: 'fetching' }; case 'fetch':return { ...r, ...iy(r.data, this.options), fetchMeta: e.meta ?? null }; case 'success':return { ...r, data: e.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: e.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: 'success', ...!e.manual && { fetchStatus: 'idle', fetchFailureCount: 0, fetchFailureReason: null } }; case 'error':const i = e.error; return au(i) && i.revert && R(this, Ii) ? { ...R(this, Ii), fetchStatus: 'idle' } : { ...r, error: i, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, fetchFailureReason: i, fetchStatus: 'idle', status: 'error' }; case 'invalidate':return { ...r, isInvalidated: !0 }; case 'setState':return { ...r, ...e.state } } }; this.state = t(this.state), Oe.batch(() => { this.observers.forEach(r => { r.onQueryUpdate() }), R(this, kt).notify({ query: this, type: 'updated', action: e }) }) }, Lm); function iy (n, e) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: ey(e.networkMode) ? 'fetching' : 'paused', ...n === void 0 && { error: null, status: 'pending' } } } function Wx (n) { const e = typeof n.initialData === 'function' ? n.initialData() : n.initialData; const t = e !== void 0; const r = t ? typeof n.initialDataUpdatedAt === 'function' ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0; return { data: e, dataUpdateCount: 0, dataUpdatedAt: t ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: t ? 'success' : 'pending', fetchStatus: 'idle' } } let nn; let Rm; const Yx = (Rm = class extends ns {constructor (e = {}) { super(); j(this, nn, void 0); this.config = e, V(this, nn, new Map()) }build (e, t, r) { const i = t.queryKey; const s = t.queryHash ?? ah(i, t); let o = this.get(s); return o || (o = new zx({ cache: this, queryKey: i, queryHash: s, options: e.defaultQueryOptions(t), state: r, defaultOptions: e.getQueryDefaults(i) }), this.add(o)), o }add (e) { R(this, nn).has(e.queryHash) || (R(this, nn).set(e.queryHash, e), this.notify({ type: 'added', query: e })) }remove (e) { const t = R(this, nn).get(e.queryHash); t && (e.destroy(), t === e && R(this, nn).delete(e.queryHash), this.notify({ type: 'removed', query: e })) }clear () { Oe.batch(() => { this.getAll().forEach(e => { this.remove(e) }) }) }get (e) { return R(this, nn).get(e) }getAll () { return [...R(this, nn).values()] }find (e) { const t = { exact: !0, ...e }; return this.getAll().find(r => ep(t, r)) }findAll (e = {}) { const t = this.getAll(); return Object.keys(e).length > 0 ? t.filter(r => ep(e, r)) : t }notify (e) { Oe.batch(() => { this.listeners.forEach(t => { t(e) }) }) }onFocus () { Oe.batch(() => { this.getAll().forEach(e => { e.onFocus() }) }) }onOnline () { Oe.batch(() => { this.getAll().forEach(e => { e.onOnline() }) }) }}, nn = new WeakMap(), Rm); let rn; let rt; let wr; let sn; let On; let Am; const qx = (Am = class extends ry {constructor (e) { super(); j(this, sn); j(this, rn, void 0); j(this, rt, void 0); j(this, wr, void 0); this.mutationId = e.mutationId, V(this, rt, e.mutationCache), V(this, rn, []), this.state = e.state || sy(), this.setOptions(e.options), this.scheduleGc() }setOptions (e) { this.options = e, this.updateGcTime(this.options.gcTime) } get meta () { return this.options.meta }addObserver (e) { R(this, rn).includes(e) || (R(this, rn).push(e), this.clearGcTimeout(), R(this, rt).notify({ type: 'observerAdded', mutation: this, observer: e })) }removeObserver (e) { V(this, rn, R(this, rn).filter(t => t !== e)), this.scheduleGc(), R(this, rt).notify({ type: 'observerRemoved', mutation: this, observer: e }) }optionalRemove () { R(this, rn).length || (this.state.status === 'pending' ? this.scheduleGc() : R(this, rt).remove(this)) }continue () { let e; return ((e = R(this, wr)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables) } async execute (e) { let i, s, o, a, l, u, c, d, h, f, p, m, y, g, v, E, x, T, w, L; V(this, wr, ny({ fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error('No mutationFn found')), onFail: (A, P) => { te(this, sn, On).call(this, { type: 'failed', failureCount: A, error: P }) }, onPause: () => { te(this, sn, On).call(this, { type: 'pause' }) }, onContinue: () => { te(this, sn, On).call(this, { type: 'continue' }) }, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => R(this, rt).canRun(this) })); const t = this.state.status === 'pending'; const r = !R(this, wr).canStart(); try { if (!t) { te(this, sn, On).call(this, { type: 'pending', variables: e, isPaused: r }), await ((s = (i = R(this, rt).config).onMutate) == null ? void 0 : s.call(i, e, this)); const P = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, e)); P !== this.state.context && te(this, sn, On).call(this, { type: 'pending', context: P, variables: e, isPaused: r }) } const A = await R(this, wr).start(); return await ((u = (l = R(this, rt).config).onSuccess) == null ? void 0 : u.call(l, A, e, this.state.context, this)), await ((d = (c = this.options).onSuccess) == null ? void 0 : d.call(c, A, e, this.state.context)), await ((f = (h = R(this, rt).config).onSettled) == null ? void 0 : f.call(h, A, null, this.state.variables, this.state.context, this)), await ((m = (p = this.options).onSettled) == null ? void 0 : m.call(p, A, null, e, this.state.context)), te(this, sn, On).call(this, { type: 'success', data: A }), A } catch (A) { try { throw await ((g = (y = R(this, rt).config).onError) == null ? void 0 : g.call(y, A, e, this.state.context, this)), await ((E = (v = this.options).onError) == null ? void 0 : E.call(v, A, e, this.state.context)), await ((T = (x = R(this, rt).config).onSettled) == null ? void 0 : T.call(x, void 0, A, this.state.variables, this.state.context, this)), await ((L = (w = this.options).onSettled) == null ? void 0 : L.call(w, void 0, A, e, this.state.context)), A } finally { te(this, sn, On).call(this, { type: 'error', error: A }) } } finally { R(this, rt).runNext(this) } }}, rn = new WeakMap(), rt = new WeakMap(), wr = new WeakMap(), sn = new WeakSet(), On = function (e) { const t = r => { switch (e.type) { case 'failed':return { ...r, failureCount: e.failureCount, failureReason: e.error }; case 'pause':return { ...r, isPaused: !0 }; case 'continue':return { ...r, isPaused: !1 }; case 'pending':return { ...r, context: e.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: e.isPaused, status: 'pending', variables: e.variables, submittedAt: Date.now() }; case 'success':return { ...r, data: e.data, failureCount: 0, failureReason: null, error: null, status: 'success', isPaused: !1 }; case 'error':return { ...r, data: void 0, error: e.error, failureCount: r.failureCount + 1, failureReason: e.error, isPaused: !1, status: 'error' } } }; this.state = t(this.state), Oe.batch(() => { R(this, rn).forEach(r => { r.onMutationUpdate(e) }), R(this, rt).notify({ mutation: this, type: 'updated', action: e }) }) }, Am); function sy () { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: 'idle', variables: void 0, submittedAt: 0 } } let Lt; let ro; let wm; const Qx = (wm = class extends ns {constructor (e = {}) { super(); j(this, Lt, void 0); j(this, ro, void 0); this.config = e, V(this, Lt, new Map()), V(this, ro, Date.now()) }build (e, t, r) { const i = new qx({ mutationCache: this, mutationId: ++Lo(this, ro)._, options: e.defaultMutationOptions(t), state: r }); return this.add(i), i }add (e) { const t = Go(e); const r = R(this, Lt).get(t) ?? []; r.push(e), R(this, Lt).set(t, r), this.notify({ type: 'added', mutation: e }) }remove (e) { let r; const t = Go(e); if (R(this, Lt).has(t)) { const i = (r = R(this, Lt).get(t)) == null ? void 0 : r.filter(s => s !== e); i && (i.length === 0 ? R(this, Lt).delete(t) : R(this, Lt).set(t, i)) } this.notify({ type: 'removed', mutation: e }) }canRun (e) { let r; const t = (r = R(this, Lt).get(Go(e))) == null ? void 0 : r.find(i => i.state.status === 'pending'); return !t || t === e }runNext (e) { let r; const t = (r = R(this, Lt).get(Go(e))) == null ? void 0 : r.find(i => i !== e && i.state.isPaused); return (t == null ? void 0 : t.continue()) ?? Promise.resolve() }clear () { Oe.batch(() => { this.getAll().forEach(e => { this.remove(e) }) }) }getAll () { return [...R(this, Lt).values()].flat() }find (e) { const t = { exact: !0, ...e }; return this.getAll().find(r => tp(t, r)) }findAll (e = {}) { return this.getAll().filter(t => tp(e, t)) }notify (e) { Oe.batch(() => { this.listeners.forEach(t => { t(e) }) }) }resumePausedMutations () { const e = this.getAll().filter(t => t.state.isPaused); return Oe.batch(() => Promise.all(e.map(t => t.continue().catch(Pt)))) }}, Lt = new WeakMap(), ro = new WeakMap(), wm); function Go (n) { let e; return ((e = n.options.scope) == null ? void 0 : e.id) ?? String(n.mutationId) } function Xx (n) { return { onFetch: (e, t) => { const r = async () => { let p, m, y, g, v; const i = e.options; const s = (y = (m = (p = e.fetchOptions) == null ? void 0 : p.meta) == null ? void 0 : m.fetchMore) == null ? void 0 : y.direction; const o = ((g = e.state.data) == null ? void 0 : g.pages) || []; const a = ((v = e.state.data) == null ? void 0 : v.pageParams) || []; const l = { pages: [], pageParams: [] }; let u = !1; const c = E => { Object.defineProperty(E, 'signal', { enumerable: !0, get: () => (e.signal.aborted ? u = !0 : e.signal.addEventListener('abort', () => { u = !0 }), e.signal) }) }; const d = e.options.queryFn && e.options.queryFn !== lh ? e.options.queryFn : () => Promise.reject(new Error(`Missing queryFn: '${e.options.queryHash}'`)); const h = async (E, x, T) => { if (u) return Promise.reject(); if (x == null && E.pages.length) return Promise.resolve(E); const w = { queryKey: e.queryKey, pageParam: x, direction: T ? 'backward' : 'forward', meta: e.options.meta }; c(w); const L = await d(w); const { maxPages: A } = e.options; const P = T ? Gx : $x; return { pages: P(E.pages, L, A), pageParams: P(E.pageParams, x, A) } }; let f; if (s && o.length) { const E = s === 'backward'; const x = E ? Jx : ip; const T = { pages: o, pageParams: a }; const w = x(i, T); f = await h(T, w, E) } else { f = await h(l, a[0] ?? i.initialPageParam); const E = n ?? o.length; for (let x = 1; x < E; x++) { const T = ip(i, f); f = await h(f, T) } } return f }; e.options.persister ? e.fetchFn = () => { let i, s; return (s = (i = e.options).persister) == null ? void 0 : s.call(i, r, { queryKey: e.queryKey, meta: e.options.meta, signal: e.signal }, t) } : e.fetchFn = r } } } function ip (n, { pages: e, pageParams: t }) { const r = e.length - 1; return n.getNextPageParam(e[r], e, t[r], t) } function Jx (n, { pages: e, pageParams: t }) { let r; return (r = n.getPreviousPageParam) == null ? void 0 : r.call(n, e[0], e, t[0], t) } let Le; let Vn; let Hn; let _i; let Di; let Kn; let ki; let Pi; let Cm; const Zx = (Cm = class {constructor (n = {}) { j(this, Le, void 0); j(this, Vn, void 0); j(this, Hn, void 0); j(this, _i, void 0); j(this, Di, void 0); j(this, Kn, void 0); j(this, ki, void 0); j(this, Pi, void 0); V(this, Le, n.queryCache || new Yx()), V(this, Vn, n.mutationCache || new Qx()), V(this, Hn, n.defaultOptions || {}), V(this, _i, new Map()), V(this, Di, new Map()), V(this, Kn, 0) }mount () { Lo(this, Kn)._++, R(this, Kn) === 1 && (V(this, ki, uh.subscribe(async n => { n && (await this.resumePausedMutations(), R(this, Le).onFocus()) })), V(this, Pi, Ya.subscribe(async n => { n && (await this.resumePausedMutations(), R(this, Le).onOnline()) }))) }unmount () { let n, e; Lo(this, Kn)._--, R(this, Kn) === 0 && ((n = R(this, ki)) == null || n.call(this), V(this, ki, void 0), (e = R(this, Pi)) == null || e.call(this), V(this, Pi, void 0)) }isFetching (n) { return R(this, Le).findAll({ ...n, fetchStatus: 'fetching' }).length }isMutating (n) { return R(this, Vn).findAll({ ...n, status: 'pending' }).length }getQueryData (n) { let t; const e = this.defaultQueryOptions({ queryKey: n }); return (t = R(this, Le).get(e.queryHash)) == null ? void 0 : t.state.data }ensureQueryData (n) { const e = this.getQueryData(n.queryKey); if (e === void 0) return this.fetchQuery(n); { const t = this.defaultQueryOptions(n); const r = R(this, Le).build(this, t); return n.revalidateIfStale && r.isStaleByTime(t.staleTime) && this.prefetchQuery(t), Promise.resolve(e) } }getQueriesData (n) { return R(this, Le).findAll(n).map(({ queryKey: e, state: t }) => { const r = t.data; return [e, r] }) }setQueryData (n, e, t) { const r = this.defaultQueryOptions({ queryKey: n }); const i = R(this, Le).get(r.queryHash); const s = i == null ? void 0 : i.state.data; const o = Ux(e, s); if (o !== void 0) return R(this, Le).build(this, r).setData(o, { ...t, manual: !0 }) }setQueriesData (n, e, t) { return Oe.batch(() => R(this, Le).findAll(n).map(({ queryKey: r }) => [r, this.setQueryData(r, e, t)])) }getQueryState (n) { let t; const e = this.defaultQueryOptions({ queryKey: n }); return (t = R(this, Le).get(e.queryHash)) == null ? void 0 : t.state }removeQueries (n) { const e = R(this, Le); Oe.batch(() => { e.findAll(n).forEach(t => { e.remove(t) }) }) }resetQueries (n, e) { const t = R(this, Le); const r = { type: 'active', ...n }; return Oe.batch(() => (t.findAll(n).forEach(i => { i.reset() }), this.refetchQueries(r, e))) }cancelQueries (n = {}, e = {}) { const t = { revert: !0, ...e }; const r = Oe.batch(() => R(this, Le).findAll(n).map(i => i.cancel(t))); return Promise.all(r).then(Pt).catch(Pt) }invalidateQueries (n = {}, e = {}) { return Oe.batch(() => { if (R(this, Le).findAll(n).forEach(r => { r.invalidate() }), n.refetchType === 'none') return Promise.resolve(); const t = { ...n, type: n.refetchType ?? n.type ?? 'active' }; return this.refetchQueries(t, e) }) }refetchQueries (n = {}, e) { const t = { ...e, cancelRefetch: (e == null ? void 0 : e.cancelRefetch) ?? !0 }; const r = Oe.batch(() => R(this, Le).findAll(n).filter(i => !i.isDisabled()).map(i => { let s = i.fetch(void 0, t); return t.throwOnError || (s = s.catch(Pt)), i.state.fetchStatus === 'paused' ? Promise.resolve() : s })); return Promise.all(r).then(Pt) }fetchQuery (n) { const e = this.defaultQueryOptions(n); e.retry === void 0 && (e.retry = !1); const t = R(this, Le).build(this, e); return t.isStaleByTime(e.staleTime) ? t.fetch(e) : Promise.resolve(t.state.data) }prefetchQuery (n) { return this.fetchQuery(n).then(Pt).catch(Pt) }fetchInfiniteQuery (n) { return n.behavior = Xx(n.pages), this.fetchQuery(n) }prefetchInfiniteQuery (n) { return this.fetchInfiniteQuery(n).then(Pt).catch(Pt) }resumePausedMutations () { return Ya.isOnline() ? R(this, Vn).resumePausedMutations() : Promise.resolve() }getQueryCache () { return R(this, Le) }getMutationCache () { return R(this, Vn) }getDefaultOptions () { return R(this, Hn) }setDefaultOptions (n) { V(this, Hn, n) }setQueryDefaults (n, e) { R(this, _i).set(Br(n), { queryKey: n, defaultOptions: e }) }getQueryDefaults (n) { const e = [...R(this, _i).values()]; let t = {}; return e.forEach(r => { Qs(n, r.queryKey) && (t = { ...t, ...r.defaultOptions }) }), t }setMutationDefaults (n, e) { R(this, Di).set(Br(n), { mutationKey: n, defaultOptions: e }) }getMutationDefaults (n) { const e = [...R(this, Di).values()]; let t = {}; return e.forEach(r => { Qs(n, r.mutationKey) && (t = { ...t, ...r.defaultOptions }) }), t }defaultQueryOptions (n) { if (n._defaulted) return n; const e = { ...R(this, Hn).queries, ...this.getQueryDefaults(n.queryKey), ...n, _defaulted: !0 }; return e.queryHash || (e.queryHash = ah(e.queryKey, e)), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== 'always'), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = 'offlineFirst'), e.enabled !== !0 && e.queryFn === lh && (e.enabled = !1), e }defaultMutationOptions (n) { return n != null && n._defaulted ? n : { ...R(this, Hn).mutations, ...(n == null ? void 0 : n.mutationKey) && this.getMutationDefaults(n.mutationKey), ...n, _defaulted: !0 } }clear () { R(this, Le).clear(), R(this, Vn).clear() }}, Le = new WeakMap(), Vn = new WeakMap(), Hn = new WeakMap(), _i = new WeakMap(), Di = new WeakMap(), Kn = new WeakMap(), ki = new WeakMap(), Pi = new WeakMap(), Cm); let ht; let ce; let io; let it; let Cr; let bi; let on; let so; let Oi; let Fi; let Ir; let _r; let jn; let Mi; let Dr; let Es; let oo; let Pc; let ao; let bc; let lo; let Oc; let uo; let Fc; let co; let Mc; let ho; let Nc; let fo; let Uc; let sl; let oy; let Im; const eL = (Im = class extends ns {constructor (e, t) { super(); j(this, Dr); j(this, oo); j(this, ao); j(this, lo); j(this, uo); j(this, co); j(this, ho); j(this, fo); j(this, sl); j(this, ht, void 0); j(this, ce, void 0); j(this, io, void 0); j(this, it, void 0); j(this, Cr, void 0); j(this, bi, void 0); j(this, on, void 0); j(this, so, void 0); j(this, Oi, void 0); j(this, Fi, void 0); j(this, Ir, void 0); j(this, _r, void 0); j(this, jn, void 0); j(this, Mi, new Set()); this.options = t, V(this, ht, e), V(this, on, null), this.bindMethods(), this.setOptions(t) }bindMethods () { this.refetch = this.refetch.bind(this) }onSubscribe () { this.listeners.size === 1 && (R(this, ce).addObserver(this), sp(R(this, ce), this.options) ? te(this, Dr, Es).call(this) : this.updateResult(), te(this, uo, Fc).call(this)) }onUnsubscribe () { this.hasListeners() || this.destroy() }shouldFetchOnReconnect () { return Bc(R(this, ce), this.options, this.options.refetchOnReconnect) }shouldFetchOnWindowFocus () { return Bc(R(this, ce), this.options, this.options.refetchOnWindowFocus) }destroy () { this.listeners = new Set(), te(this, co, Mc).call(this), te(this, ho, Nc).call(this), R(this, ce).removeObserver(this) }setOptions (e, t) { const r = this.options; const i = R(this, ce); if (this.options = R(this, ht).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled !== 'boolean') throw new Error('Expected enabled to be a boolean'); te(this, fo, Uc).call(this), R(this, ce).setOptions(this.options), r._defaulted && !Wa(this.options, r) && R(this, ht).getQueryCache().notify({ type: 'observerOptionsUpdated', query: R(this, ce), observer: this }); const s = this.hasListeners(); s && op(R(this, ce), i, this.options, r) && te(this, Dr, Es).call(this), this.updateResult(t), s && (R(this, ce) !== i || this.options.enabled !== r.enabled || this.options.staleTime !== r.staleTime) && te(this, oo, Pc).call(this); const o = te(this, ao, bc).call(this); s && (R(this, ce) !== i || this.options.enabled !== r.enabled || o !== R(this, jn)) && te(this, lo, Oc).call(this, o) }getOptimisticResult (e) { const t = R(this, ht).getQueryCache().build(R(this, ht), e); const r = this.createResult(t, e); return nL(this, r) && (V(this, it, r), V(this, bi, this.options), V(this, Cr, R(this, ce).state)), r }getCurrentResult () { return R(this, it) }trackResult (e, t) { const r = {}; return Object.keys(e).forEach(i => { Object.defineProperty(r, i, { configurable: !1, enumerable: !0, get: () => (this.trackProp(i), t == null || t(i), e[i]) }) }), r }trackProp (e) { R(this, Mi).add(e) }getCurrentQuery () { return R(this, ce) }refetch ({ ...e } = {}) { return this.fetch({ ...e }) }fetchOptimistic (e) { const t = R(this, ht).defaultQueryOptions(e); const r = R(this, ht).getQueryCache().build(R(this, ht), t); return r.isFetchingOptimistic = !0, r.fetch().then(() => this.createResult(r, t)) }fetch (e) { return te(this, Dr, Es).call(this, { ...e, cancelRefetch: e.cancelRefetch ?? !0 }).then(() => (this.updateResult(), R(this, it))) }createResult (e, t) { let L; const r = R(this, ce); const i = this.options; const s = R(this, it); const o = R(this, Cr); const a = R(this, bi); const u = e !== r ? e.state : R(this, io); const { state: c } = e; let d = { ...c }; let h = !1; let f; if (t._optimisticResults) { const A = this.hasListeners(); const P = !A && sp(e, t); const _ = A && op(e, r, t, i); (P || _) && (d = { ...d, ...iy(c.data, e.options) }), t._optimisticResults === 'isRestoring' && (d.fetchStatus = 'idle') } let { error: p, errorUpdatedAt: m, status: y } = d; if (t.select && d.data !== void 0) if (s && d.data === (o == null ? void 0 : o.data) && t.select === R(this, so))f = R(this, Oi); else try { V(this, so, t.select), f = t.select(d.data), f = kc(s == null ? void 0 : s.data, f, t), V(this, Oi, f), V(this, on, null) } catch (A) { V(this, on, A) } else f = d.data; if (t.placeholderData !== void 0 && f === void 0 && y === 'pending') { let A; if (s != null && s.isPlaceholderData && t.placeholderData === (a == null ? void 0 : a.placeholderData))A = s.data; else if (A = typeof t.placeholderData === 'function' ? t.placeholderData((L = R(this, Fi)) == null ? void 0 : L.state.data, R(this, Fi)) : t.placeholderData, t.select && A !== void 0) try { A = t.select(A), V(this, on, null) } catch (P) { V(this, on, P) }A !== void 0 && (y = 'success', f = kc(s == null ? void 0 : s.data, A, t), h = !0) }R(this, on) && (p = R(this, on), f = R(this, Oi), m = Date.now(), y = 'error'); const g = d.fetchStatus === 'fetching'; const v = y === 'pending'; const E = y === 'error'; const x = v && g; const T = f !== void 0; return { status: y, fetchStatus: d.fetchStatus, isPending: v, isSuccess: y === 'success', isError: E, isInitialLoading: x, isLoading: x, data: f, dataUpdatedAt: d.dataUpdatedAt, error: p, errorUpdatedAt: m, failureCount: d.fetchFailureCount, failureReason: d.fetchFailureReason, errorUpdateCount: d.errorUpdateCount, isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0, isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount, isFetching: g, isRefetching: g && !v, isLoadingError: E && !T, isPaused: d.fetchStatus === 'paused', isPlaceholderData: h, isRefetchError: E && T, isStale: ch(e, t), refetch: this.refetch } }updateResult (e) { const t = R(this, it); const r = this.createResult(R(this, ce), this.options); if (V(this, Cr, R(this, ce).state), V(this, bi, this.options), R(this, Cr).data !== void 0 && V(this, Fi, R(this, ce)), Wa(r, t)) return; V(this, it, r); const i = {}; const s = () => { if (!t) return !0; const { notifyOnChangeProps: o } = this.options; const a = typeof o === 'function' ? o() : o; if (a === 'all' || !a && !R(this, Mi).size) return !0; const l = new Set(a ?? R(this, Mi)); return this.options.throwOnError && l.add('error'), Object.keys(R(this, it)).some(u => { const c = u; return R(this, it)[c] !== t[c] && l.has(c) }) }; (e == null ? void 0 : e.listeners) !== !1 && s() && (i.listeners = !0), te(this, sl, oy).call(this, { ...i, ...e }) }onQueryUpdate () { this.updateResult(), this.hasListeners() && te(this, uo, Fc).call(this) }}, ht = new WeakMap(), ce = new WeakMap(), io = new WeakMap(), it = new WeakMap(), Cr = new WeakMap(), bi = new WeakMap(), on = new WeakMap(), so = new WeakMap(), Oi = new WeakMap(), Fi = new WeakMap(), Ir = new WeakMap(), _r = new WeakMap(), jn = new WeakMap(), Mi = new WeakMap(), Dr = new WeakSet(), Es = function (e) { te(this, fo, Uc).call(this); let t = R(this, ce).fetch(this.options, e); return e != null && e.throwOnError || (t = t.catch(Pt)), t }, oo = new WeakSet(), Pc = function () { if (te(this, co, Mc).call(this), ji || R(this, it).isStale || !_c(this.options.staleTime)) return; const t = J0(R(this, it).dataUpdatedAt, this.options.staleTime) + 1; V(this, Ir, setTimeout(() => { R(this, it).isStale || this.updateResult() }, t)) }, ao = new WeakSet(), bc = function () { return (typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(R(this, ce)) : this.options.refetchInterval) ?? !1 }, lo = new WeakSet(), Oc = function (e) { te(this, ho, Nc).call(this), V(this, jn, e), !(ji || this.options.enabled === !1 || !_c(R(this, jn)) || R(this, jn) === 0) && V(this, _r, setInterval(() => { (this.options.refetchIntervalInBackground || uh.isFocused()) && te(this, Dr, Es).call(this) }, R(this, jn))) }, uo = new WeakSet(), Fc = function () { te(this, oo, Pc).call(this), te(this, lo, Oc).call(this, te(this, ao, bc).call(this)) }, co = new WeakSet(), Mc = function () { R(this, Ir) && (clearTimeout(R(this, Ir)), V(this, Ir, void 0)) }, ho = new WeakSet(), Nc = function () { R(this, _r) && (clearInterval(R(this, _r)), V(this, _r, void 0)) }, fo = new WeakSet(), Uc = function () { const e = R(this, ht).getQueryCache().build(R(this, ht), this.options); if (e === R(this, ce)) return; const t = R(this, ce); V(this, ce, e), V(this, io, e.state), this.hasListeners() && (t == null || t.removeObserver(this), e.addObserver(this)) }, sl = new WeakSet(), oy = function (e) { Oe.batch(() => { e.listeners && this.listeners.forEach(t => { t(R(this, it)) }), R(this, ht).getQueryCache().notify({ query: R(this, ce), type: 'observerResultsUpdated' }) }) }, Im); function tL (n, e) { return e.enabled !== !1 && n.state.data === void 0 && !(n.state.status === 'error' && e.retryOnMount === !1) } function sp (n, e) { return tL(n, e) || n.state.data !== void 0 && Bc(n, e, e.refetchOnMount) } function Bc (n, e, t) { if (e.enabled !== !1) { const r = typeof t === 'function' ? t(n) : t; return r === 'always' || r !== !1 && ch(n, e) } return !1 } function op (n, e, t, r) { return (n !== e || r.enabled === !1) && (!t.suspense || n.state.status !== 'error') && ch(n, t) } function ch (n, e) { return e.enabled !== !1 && n.isStaleByTime(e.staleTime) } function nL (n, e) { return !Wa(n.getCurrentResult(), e) } let zn; let Wn; let ft; let xn; let Ni; let da; let po; let $c; let _m; const rL = (_m = class extends ns {constructor (t, r) { super(); j(this, Ni); j(this, po); j(this, zn, void 0); j(this, Wn, void 0); j(this, ft, void 0); j(this, xn, void 0); V(this, zn, t), this.setOptions(r), this.bindMethods(), te(this, Ni, da).call(this) }bindMethods () { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) }setOptions (t) { let i; const r = this.options; this.options = R(this, zn).defaultMutationOptions(t), Wa(this.options, r) || R(this, zn).getMutationCache().notify({ type: 'observerOptionsUpdated', mutation: R(this, ft), observer: this }), r != null && r.mutationKey && this.options.mutationKey && Br(r.mutationKey) !== Br(this.options.mutationKey) ? this.reset() : ((i = R(this, ft)) == null ? void 0 : i.state.status) === 'pending' && R(this, ft).setOptions(this.options) }onUnsubscribe () { let t; this.hasListeners() || (t = R(this, ft)) == null || t.removeObserver(this) }onMutationUpdate (t) { te(this, Ni, da).call(this), te(this, po, $c).call(this, t) }getCurrentResult () { return R(this, Wn) }reset () { let t; (t = R(this, ft)) == null || t.removeObserver(this), V(this, ft, void 0), te(this, Ni, da).call(this), te(this, po, $c).call(this) }mutate (t, r) { let i; return V(this, xn, r), (i = R(this, ft)) == null || i.removeObserver(this), V(this, ft, R(this, zn).getMutationCache().build(R(this, zn), this.options)), R(this, ft).addObserver(this), R(this, ft).execute(t) }}, zn = new WeakMap(), Wn = new WeakMap(), ft = new WeakMap(), xn = new WeakMap(), Ni = new WeakSet(), da = function () { let r; const t = ((r = R(this, ft)) == null ? void 0 : r.state) ?? sy(); V(this, Wn, { ...t, isPending: t.status === 'pending', isSuccess: t.status === 'success', isError: t.status === 'error', isIdle: t.status === 'idle', mutate: this.mutate, reset: this.reset }) }, po = new WeakSet(), $c = function (t) { Oe.batch(() => { let r, i, s, o, a, l, u, c; if (R(this, xn) && this.hasListeners()) { const d = R(this, Wn).variables; const h = R(this, Wn).context; (t == null ? void 0 : t.type) === 'success' ? ((i = (r = R(this, xn)).onSuccess) == null || i.call(r, t.data, d, h), (o = (s = R(this, xn)).onSettled) == null || o.call(s, t.data, null, d, h)) : (t == null ? void 0 : t.type) === 'error' && ((l = (a = R(this, xn)).onError) == null || l.call(a, t.error, d, h), (c = (u = R(this, xn)).onSettled) == null || c.call(u, void 0, t.error, d, h)) } this.listeners.forEach(d => { d(R(this, Wn)) }) }) }, _m); const ay = k.createContext(void 0); const dh = n => { const e = k.useContext(ay); if (!e) throw new Error('No QueryClient set, use QueryClientProvider to set one'); return e }; const iL = ({ client: n, children: e }) => (k.useEffect(() => (n.mount(), () => { n.unmount() }), [n]), B.jsx(ay.Provider, { value: n, children: e })); const ly = k.createContext(!1); const sL = () => k.useContext(ly); ly.Provider; function oL () { let n = !1; return { clearReset: () => { n = !1 }, reset: () => { n = !0 }, isReset: () => n } } const aL = k.createContext(oL()); const lL = () => k.useContext(aL); function uy (n, e) { return typeof n === 'function' ? n(...e) : !!n } function uL () {} const cL = (n, e) => { (n.suspense || n.throwOnError) && (e.isReset() || (n.retryOnMount = !1)) }; const dL = n => { k.useEffect(() => { n.clearReset() }, [n]) }; const hL = ({ result: n, errorResetBoundary: e, throwOnError: t, query: r }) => n.isError && !e.isReset() && !n.isFetching && r && uy(t, [n.error, r]); const fL = n => { n.suspense && typeof n.staleTime !== 'number' && (n.staleTime = 1e3) }; const pL = (n, e) => (n == null ? void 0 : n.suspense) && e.isPending; const mL = (n, e, t) => e.fetchOptimistic(n).catch(() => { t.clearReset() }); function gL (n, e, t) { const r = dh(); const i = sL(); const s = lL(); const o = r.defaultQueryOptions(n); o._optimisticResults = i ? 'isRestoring' : 'optimistic', fL(o), cL(o, s), dL(s); const [a] = k.useState(() => new e(r, o)); const l = a.getOptimisticResult(o); if (k.useSyncExternalStore(k.useCallback(u => { const c = i ? () => {} : a.subscribe(Oe.batchCalls(u)); return a.updateResult(), c }, [a, i]), () => a.getCurrentResult(), () => a.getCurrentResult()), k.useEffect(() => { a.setOptions(o, { listeners: !1 }) }, [o, a]), pL(o, l)) throw mL(o, a, s); if (hL({ result: l, errorResetBoundary: s, throwOnError: o.throwOnError, query: r.getQueryCache().get(o.queryHash) })) throw l.error; return o.notifyOnChangeProps ? l : a.trackResult(l) } function hh (n, e) { return gL(n, eL) } function yL (n, e) { const t = dh(); const [r] = k.useState(() => new rL(t, n)); k.useEffect(() => { r.setOptions(n) }, [r, n]); const i = k.useSyncExternalStore(k.useCallback(o => r.subscribe(Oe.batchCalls(o)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()); const s = k.useCallback((o, a) => { r.mutate(o, a).catch(uL) }, [r]); if (i.error && uy(r.options.throwOnError, [i.error])) throw i.error; return { ...i, mutate: s, mutateAsync: i.mutate } } const cy = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (n) { (function () { const e = {}.hasOwnProperty; function t () { for (var s = '', o = 0; o < arguments.length; o++) { const a = arguments[o]; a && (s = i(s, r(a))) } return s } function r (s) { if (typeof s === 'string' || typeof s === 'number') return s; if (typeof s !== 'object') return ''; if (Array.isArray(s)) return t.apply(null, s); if (s.toString !== Object.prototype.toString && !s.toString.toString().includes('[native code]')) return s.toString(); let o = ''; for (const a in s)e.call(s, a) && s[a] && (o = i(o, a)); return o } function i (s, o) { return o ? s ? s + ' ' + o : s + o : s }n.exports ? (t.default = t, n.exports = t) : window.classNames = t })() })(cy); const vL = cy.exports; const Ti = ad(vL); const EL = '_header_10ovb_1'; const SL = '_link_10ovb_17'; const TL = '_active_10ovb_21'; const hr = { header: EL, link: SL, active: TL }; const xL = () => { const n = ts(); return B.jsxs('header', { className: hr.header, children: [B.jsx(ou, { className: Ti(hr.link, { [hr.active]: n.pathname === '/tv' }), to: '/tv', children: 'TV' }), B.jsx(ou, { className: Ti(hr.link, { [hr.active]: n.pathname === '/stream' }), to: '/stream', children: 'Stream' }), B.jsx(ou, { className: Ti(hr.link, { [hr.active]: n.pathname === '/torrent' }), to: '/torrent', children: 'Torrent' })] }) }; const LL = '_main_yzoji_1'; const RL = { main: LL }; const AL = () => B.jsxs('main', { children: [B.jsx(xL, {}), B.jsx('div', { className: RL.main, children: B.jsx(Ax, {}) })] }); const wL = 'http://localhost:8000/api'; const Kr = async (n, e) => { try { const t = await fetch(wL + n, e); if (!t.ok) throw new Error('Failed to fetch playlist'); return await (t == null ? void 0 : t.json()) } catch (t) { console.error('Error fetching playlist:', t) } }; const CL = async n => await Kr(`/tv/playlist/${n}`); const IL = async () => await Kr('/tv/update'); const _L = async n => await Kr(`/video/stream/add/${n}`); const DL = async n => await Kr(`/video/stream/stop/${n}`); const kL = async (n, e) => await Kr(`/video/stream/start/${n}/${e}`); const PL = async (n, e) => await Kr(`/search/ru/${e}/${n}`); const bL = async n => await Kr('/search/ru/magnet', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ data: n }) }); const dy = () => ({ addMagnet: async t => await _L(t), stopStream: async t => await DL(t) }); const OL = '_container_er2xj_1'; const FL = '_header_er2xj_6'; const ML = '_main_er2xj_12'; const NL = '_controls_er2xj_17'; const UL = '_video_er2xj_21'; const BL = '_input_er2xj_30'; const $L = '_buttons_er2xj_38'; const fr = { container: OL, header: FL, main: ML, controls: NL, video: UL, input: BL, buttons: $L }; const hy = ({ setData: n, infoHash: e }) => { const t = 'http://localhost:8000/api'; const r = k.useRef(); return k.useEffect(() => (e != null && (r.current = new EventSource(t + `/video/stream/stats/${e}`), r.current.onmessage = i => { const s = JSON.parse(i.data); n(s) }, r.current.onerror = i => { console.error('SSE Error:', i) }), () => { let i; (i = r.current) == null || i.close() }), [t, e, n]), r.current }; const GL = 'modulepreload'; const VL = function (n) { return '/' + n }; const ap = {}; const ct = function (e, t, r) { let i = Promise.resolve(); if (t && t.length > 0) { document.getElementsByTagName('link'); const s = document.querySelector('meta[property=csp-nonce]'); const o = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute('nonce')); i = Promise.all(t.map(a => { if (a = VL(a), a in ap) return; ap[a] = !0; const l = a.endsWith('.css'); const u = l ? '[rel="stylesheet"]' : ''; if (document.querySelector(`link[href="${a}"]${u}`)) return; const c = document.createElement('link'); if (c.rel = l ? 'stylesheet' : GL, l || (c.as = 'script', c.crossOrigin = ''), c.href = a, o && c.setAttribute('nonce', o), document.head.appendChild(c), l) return new Promise((d, h) => { c.addEventListener('load', d), c.addEventListener('error', () => h(new Error(`Unable to preload CSS for ${a}`))) }) })) } return i.then(() => e()).catch(s => { const o = new Event('vite:preloadError', { cancelable: !0 }); if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s }) }; const HL = function (e, t, r) { const i = document.head || document.getElementsByTagName('head')[0]; const s = document.createElement('script'); typeof t === 'function' && (r = t, t = {}), t = t || {}, r = r || function () {}, s.type = t.type || 'text/javascript', s.charset = t.charset || 'utf8', s.async = 'async' in t ? !!t.async : !0, s.src = e, t.attrs && KL(s, t.attrs), t.text && (s.text = '' + t.text); const o = 'onload' in s ? lp : jL; o(s, r), s.onload || lp(s, r), i.appendChild(s) }; function KL (n, e) { for (const t in e)n.setAttribute(t, e[t]) } function lp (n, e) { n.onload = function () { this.onerror = this.onload = null, e(null, n) }, n.onerror = function () { this.onerror = this.onload = null, e(new Error('Failed to load ' + this.src), n) } } function jL (n, e) { n.onreadystatechange = function () { this.readyState != 'complete' && this.readyState != 'loaded' || (this.onreadystatechange = null, e(null, n)) } } const zL = function (e) { return WL(e) && !YL(e) }; function WL (n) { return !!n && typeof n === 'object' } function YL (n) { const e = Object.prototype.toString.call(n); return e === '[object RegExp]' || e === '[object Date]' || XL(n) } const qL = typeof Symbol === 'function' && Symbol.for; const QL = qL ? Symbol.for('react.element') : 60103; function XL (n) { return n.$$typeof === QL } function JL (n) { return Array.isArray(n) ? [] : {} } function Xs (n, e) { return e.clone !== !1 && e.isMergeableObject(n) ? zi(JL(n), n, e) : n } function ZL (n, e, t) { return n.concat(e).map(function (r) { return Xs(r, t) }) } function eR (n, e) { if (!e.customMerge) return zi; const t = e.customMerge(n); return typeof t === 'function' ? t : zi } function tR (n) { return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n).filter(function (e) { return Object.propertyIsEnumerable.call(n, e) }) : [] } function up (n) { return Object.keys(n).concat(tR(n)) } function fy (n, e) { try { return e in n } catch { return !1 } } function nR (n, e) { return fy(n, e) && !(Object.hasOwnProperty.call(n, e) && Object.propertyIsEnumerable.call(n, e)) } function rR (n, e, t) { const r = {}; return t.isMergeableObject(n) && up(n).forEach(function (i) { r[i] = Xs(n[i], t) }), up(e).forEach(function (i) { nR(n, i) || (fy(n, i) && t.isMergeableObject(e[i]) ? r[i] = eR(i, t)(n[i], e[i], t) : r[i] = Xs(e[i], t)) }), r } function zi (n, e, t) { t = t || {}, t.arrayMerge = t.arrayMerge || ZL, t.isMergeableObject = t.isMergeableObject || zL, t.cloneUnlessOtherwiseSpecified = Xs; const r = Array.isArray(e); const i = Array.isArray(n); const s = r === i; return s ? r ? t.arrayMerge(n, e, t) : rR(n, e, t) : Xs(e, t) }zi.all = function (e, t) { if (!Array.isArray(e)) throw new Error('first argument should be an array'); return e.reduce(function (r, i) { return zi(r, i, t) }, {}) }; const iR = zi; const py = iR; const sR = Object.create; const Ll = Object.defineProperty; const oR = Object.getOwnPropertyDescriptor; const aR = Object.getOwnPropertyNames; const lR = Object.getPrototypeOf; const uR = Object.prototype.hasOwnProperty; const cR = (n, e) => { for (const t in e)Ll(n, t, { get: e[t], enumerable: !0 }) }; const my = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of aR(e))!uR.call(n, i) && i !== t && Ll(n, i, { get: () => e[i], enumerable: !(r = oR(e, i)) || r.enumerable }); return n }; const fh = (n, e, t) => (t = n != null ? sR(lR(n)) : {}, my(!n || !n.__esModule ? Ll(t, 'default', { value: n, enumerable: !0 }) : t, n)); const dR = n => my(Ll({}, '__esModule', { value: !0 }), n); const gy = {}; cR(gy, { callPlayer: () => CR, getConfig: () => AR, getSDK: () => RR, isBlobUrl: () => _R, isMediaStream: () => IR, lazy: () => mR, omit: () => wR, parseEndTime: () => TR, parseStartTime: () => SR, queryString: () => LR, randomString: () => xR, supportsWebKitPresentationMode: () => DR }); const Rl = dR(gy); const hR = fh(k); const fR = fh(HL); const pR = fh(py); const mR = n => hR.default.lazy(async () => { const e = await n(); return typeof e.default === 'function' ? e : e.default }); const gR = /[?&#](?:start|t)=([0-9hms]+)/; const yR = /[?&#]end=([0-9hms]+)/; const Gc = /(\d+)(h|m|s)/g; const vR = /^\d+$/; function yy (n, e) { if (n instanceof Array) return; const t = n.match(e); if (t) { const r = t[1]; if (r.match(Gc)) return ER(r); if (vR.test(r)) return parseInt(r) } } function ER (n) { let e = 0; let t = Gc.exec(n); for (;t !== null;) { const [, r, i] = t; i === 'h' && (e += parseInt(r, 10) * 60 * 60), i === 'm' && (e += parseInt(r, 10) * 60), i === 's' && (e += parseInt(r, 10)), t = Gc.exec(n) } return e } function SR (n) { return yy(n, gR) } function TR (n) { return yy(n, yR) } function xR () { return Math.random().toString(36).substr(2, 5) } function LR (n) { return Object.keys(n).map(e => `${e}=${n[e]}`).join('&') } function lu (n) { return window[n] ? window[n] : window.exports && window.exports[n] ? window.exports[n] : window.module && window.module.exports && window.module.exports[n] ? window.module.exports[n] : null } const zr = {}; const RR = function (e, t, r = null, i = () => !0, s = fR.default) { const o = lu(t); return o && i(o) ? Promise.resolve(o) : new Promise((a, l) => { if (zr[e]) { zr[e].push({ resolve: a, reject: l }); return }zr[e] = [{ resolve: a, reject: l }]; const u = c => { zr[e].forEach(d => d.resolve(c)) }; if (r) { const c = window[r]; window[r] = function () { c && c(), u(lu(t)) } }s(e, c => { c ? (zr[e].forEach(d => d.reject(c)), zr[e] = null) : r || u(lu(t)) }) }) }; function AR (n, e) { return (0, pR.default)(e.config, n.config) } function wR (n, ...e) { const t = [].concat(...e); const r = {}; const i = Object.keys(n); for (const s of i)t.indexOf(s) === -1 && (r[s] = n[s]); return r } function CR (n, ...e) { if (!this.player || !this.player[n]) { let t = `ReactPlayer: ${this.constructor.displayName} player could not call %c${n}%c  `; return this.player ? this.player[n] || (t += 'The method was not available') : t += 'The player was not available', console.warn(t, 'font-weight: bold', ''), null } return this.player[n](...e) } function IR (n) { return typeof window < 'u' && typeof window.MediaStream < 'u' && n instanceof window.MediaStream } function _R (n) { return /^blob:/.test(n) } function DR (n = document.createElement('video')) { const e = /iPhone|iPod/.test(navigator.userAgent) === !1; return n.webkitSupportsPresentationMode && typeof n.webkitSetPresentationMode === 'function' && e } const ph = Object.defineProperty; const kR = Object.getOwnPropertyDescriptor; const PR = Object.getOwnPropertyNames; const bR = Object.prototype.hasOwnProperty; const OR = (n, e) => { for (const t in e)ph(n, t, { get: e[t], enumerable: !0 }) }; const FR = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of PR(e))!bR.call(n, i) && i !== t && ph(n, i, { get: () => e[i], enumerable: !(r = kR(e, i)) || r.enumerable }); return n }; const MR = n => FR(ph({}, '__esModule', { value: !0 }), n); const vy = {}; OR(vy, { AUDIO_EXTENSIONS: () => mh, DASH_EXTENSIONS: () => Py, FLV_EXTENSIONS: () => by, HLS_EXTENSIONS: () => yh, MATCH_URL_DAILYMOTION: () => Iy, MATCH_URL_FACEBOOK: () => xy, MATCH_URL_FACEBOOK_WATCH: () => Ly, MATCH_URL_KALTURA: () => ky, MATCH_URL_MIXCLOUD: () => _y, MATCH_URL_MUX: () => Ty, MATCH_URL_SOUNDCLOUD: () => Ey, MATCH_URL_STREAMABLE: () => Ry, MATCH_URL_TWITCH_CHANNEL: () => Cy, MATCH_URL_TWITCH_VIDEO: () => wy, MATCH_URL_VIDYARD: () => Dy, MATCH_URL_VIMEO: () => Sy, MATCH_URL_WISTIA: () => Ay, MATCH_URL_YOUTUBE: () => Vc, VIDEO_EXTENSIONS: () => gh, canPlay: () => UR }); const NR = MR(vy); const cp = Rl; const Vc = /(?:youtu\.be\/|youtube(?:-nocookie|education)?\.com\/(?:embed\/|v\/|watch\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})|youtube\.com\/playlist\?list=|youtube\.com\/user\//; const Ey = /(?:soundcloud\.com|snd\.sc)\/[^.]+$/; const Sy = /vimeo\.com\/(?!progressive_redirect).+/; const Ty = /stream\.mux\.com\/(?!\w+\.m3u8)(\w+)/; const xy = /^https?:\/\/(www\.)?facebook\.com.*\/(video(s)?|watch|story)(\.php?|\/).+$/; const Ly = /^https?:\/\/fb\.watch\/.+$/; const Ry = /streamable\.com\/([a-z0-9]+)$/; const Ay = /(?:wistia\.(?:com|net)|wi\.st)\/(?:medias|embed)\/(?:iframe\/)?([^?]+)/; const wy = /(?:www\.|go\.)?twitch\.tv\/videos\/(\d+)($|\?)/; const Cy = /(?:www\.|go\.)?twitch\.tv\/([a-zA-Z0-9_]+)($|\?)/; const Iy = /^(?:(?:https?):)?(?:\/\/)?(?:www\.)?(?:(?:dailymotion\.com(?:\/embed)?\/video)|dai\.ly)\/([a-zA-Z0-9]+)(?:_[\w_-]+)?(?:[\w.#_-]+)?/; const _y = /mixcloud\.com\/([^/]+\/[^/]+)/; const Dy = /vidyard.com\/(?:watch\/)?([a-zA-Z0-9-_]+)/; const ky = /^https?:\/\/[a-zA-Z]+\.kaltura.(com|org)\/p\/([0-9]+)\/sp\/([0-9]+)00\/embedIframeJs\/uiconf_id\/([0-9]+)\/partner_id\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/; const mh = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i; const gh = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i; const yh = /\.(m3u8)($|\?)/i; const Py = /\.(mpd)($|\?)/i; const by = /\.(flv)($|\?)/i; const Hc = n => { if (n instanceof Array) { for (const e of n) if (typeof e === 'string' && Hc(e) || Hc(e.src)) return !0; return !1 } return (0, cp.isMediaStream)(n) || (0, cp.isBlobUrl)(n) ? !0 : mh.test(n) || gh.test(n) || yh.test(n) || Py.test(n) || by.test(n) }; const UR = { youtube: n => n instanceof Array ? n.every(e => Vc.test(e)) : Vc.test(n), soundcloud: n => Ey.test(n) && !mh.test(n), vimeo: n => Sy.test(n) && !gh.test(n) && !yh.test(n), mux: n => Ty.test(n), facebook: n => xy.test(n) || Ly.test(n), streamable: n => Ry.test(n), wistia: n => Ay.test(n), twitch: n => wy.test(n) || Cy.test(n), dailymotion: n => Iy.test(n), mixcloud: n => _y.test(n), vidyard: n => Dy.test(n), kaltura: n => ky.test(n), file: Hc }; const vh = Object.defineProperty; const BR = Object.getOwnPropertyDescriptor; const $R = Object.getOwnPropertyNames; const GR = Object.prototype.hasOwnProperty; const VR = (n, e) => { for (const t in e)vh(n, t, { get: e[t], enumerable: !0 }) }; const HR = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of $R(e))!GR.call(n, i) && i !== t && vh(n, i, { get: () => e[i], enumerable: !(r = BR(e, i)) || r.enumerable }); return n }; const KR = n => HR(vh({}, '__esModule', { value: !0 }), n); const Oy = {}; VR(Oy, { default: () => zR }); const jR = KR(Oy); const ut = Rl; const et = NR; var zR = [{ key: 'youtube', name: 'YouTube', canPlay: et.canPlay.youtube, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./YouTube-CwRrEAEa.js').then(n => n.Y), [])) }, { key: 'soundcloud', name: 'SoundCloud', canPlay: et.canPlay.soundcloud, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./SoundCloud-BQ6DZJ1t.js').then(n => n.S), [])) }, { key: 'vimeo', name: 'Vimeo', canPlay: et.canPlay.vimeo, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Vimeo-CdKxOriU.js').then(n => n.V), [])) }, { key: 'mux', name: 'Mux', canPlay: et.canPlay.mux, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Mux-DnQljapI.js').then(n => n.M), [])) }, { key: 'facebook', name: 'Facebook', canPlay: et.canPlay.facebook, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Facebook-NgKFmTPU.js').then(n => n.F), [])) }, { key: 'streamable', name: 'Streamable', canPlay: et.canPlay.streamable, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Streamable-DQ16cIwI.js').then(n => n.S), [])) }, { key: 'wistia', name: 'Wistia', canPlay: et.canPlay.wistia, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Wistia-DtwRxIaa.js').then(n => n.W), [])) }, { key: 'twitch', name: 'Twitch', canPlay: et.canPlay.twitch, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Twitch-Blot8uKA.js').then(n => n.T), [])) }, { key: 'dailymotion', name: 'DailyMotion', canPlay: et.canPlay.dailymotion, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./DailyMotion-DJZ5ybLb.js').then(n => n.D), [])) }, { key: 'mixcloud', name: 'Mixcloud', canPlay: et.canPlay.mixcloud, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Mixcloud-BY4OM9wo.js').then(n => n.M), [])) }, { key: 'vidyard', name: 'Vidyard', canPlay: et.canPlay.vidyard, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Vidyard-eylriiHK.js').then(n => n.V), [])) }, { key: 'kaltura', name: 'Kaltura', canPlay: et.canPlay.kaltura, lazyPlayer: (0, ut.lazy)(() => ct(() => import('./Kaltura-C_V6mOIQ.js').then(n => n.K), [])) }, { key: 'file', name: 'FilePlayer', canPlay: et.canPlay.file, canEnablePIP: n => et.canPlay.file(n) && (document.pictureInPictureEnabled || (0, ut.supportsWebKitPresentationMode)()) && !et.AUDIO_EXTENSIONS.test(n), lazyPlayer: (0, ut.lazy)(() => ct(() => import('./FilePlayer-D7MQhzNy.js').then(n => n.F), [])) }]; const dp = Number.isNaN || function (e) { return typeof e === 'number' && e !== e }; function WR (n, e) { return !!(n === e || dp(n) && dp(e)) } function YR (n, e) { if (n.length !== e.length) return !1; for (let t = 0; t < n.length; t++) if (!WR(n[t], e[t])) return !1; return !0 } function qR (n, e) { e === void 0 && (e = YR); let t; let r = []; let i; let s = !1; function o () { for (var a = [], l = 0; l < arguments.length; l++)a[l] = arguments[l]; return s && t === this && e(a, r) || (i = n.apply(this, a), s = !0, t = this, r = a), i } return o } const QR = Object.freeze(Object.defineProperty({ __proto__: null, default: qR }, Symbol.toStringTag, { value: 'Module' })); const XR = lE(QR); const JR = typeof Element < 'u'; const ZR = typeof Map === 'function'; const e1 = typeof Set === 'function'; const t1 = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView; function ha (n, e) { if (n === e) return !0; if (n && e && typeof n === 'object' && typeof e === 'object') { if (n.constructor !== e.constructor) return !1; let t, r, i; if (Array.isArray(n)) { if (t = n.length, t != e.length) return !1; for (r = t; r-- !== 0;) if (!ha(n[r], e[r])) return !1; return !0 } let s; if (ZR && n instanceof Map && e instanceof Map) { if (n.size !== e.size) return !1; for (s = n.entries(); !(r = s.next()).done;) if (!e.has(r.value[0])) return !1; for (s = n.entries(); !(r = s.next()).done;) if (!ha(r.value[1], e.get(r.value[0]))) return !1; return !0 } if (e1 && n instanceof Set && e instanceof Set) { if (n.size !== e.size) return !1; for (s = n.entries(); !(r = s.next()).done;) if (!e.has(r.value[0])) return !1; return !0 } if (t1 && ArrayBuffer.isView(n) && ArrayBuffer.isView(e)) { if (t = n.length, t != e.length) return !1; for (r = t; r-- !== 0;) if (n[r] !== e[r]) return !1; return !0 } if (n.constructor === RegExp) return n.source === e.source && n.flags === e.flags; if (n.valueOf !== Object.prototype.valueOf && typeof n.valueOf === 'function' && typeof e.valueOf === 'function') return n.valueOf() === e.valueOf(); if (n.toString !== Object.prototype.toString && typeof n.toString === 'function' && typeof e.toString === 'function') return n.toString() === e.toString(); if (i = Object.keys(n), t = i.length, t !== Object.keys(e).length) return !1; for (r = t; r-- !== 0;) if (!Object.prototype.hasOwnProperty.call(e, i[r])) return !1; if (JR && n instanceof Element) return !1; for (r = t; r-- !== 0;) if (!((i[r] === '_owner' || i[r] === '__v' || i[r] === '__o') && n.$$typeof) && !ha(n[i[r]], e[i[r]])) return !1; return !0 } return n !== n && e !== e } const Fy = function (e, t) { try { return ha(e, t) } catch (r) { if ((r.message || '').match(/stack|recursion/i)) return console.warn('react-fast-compare cannot handle circular refs'), !1; throw r } }; const My = { exports: {} }; const n1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'; const r1 = n1; const i1 = r1; function Ny () {} function Uy () {}Uy.resetWarningCache = Ny; const s1 = function () { function n (r, i, s, o, a, l) { if (l !== i1) { const u = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types'); throw u.name = 'Invariant Violation', u } }n.isRequired = n; function e () { return n } const t = { array: n, bigint: n, bool: n, func: n, number: n, object: n, string: n, symbol: n, any: n, arrayOf: e, element: n, elementType: n, instanceOf: e, node: n, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: Uy, resetWarningCache: Ny }; return t.PropTypes = t, t }; My.exports = s1(); const o1 = My.exports; const a1 = Object.create; const Al = Object.defineProperty; const l1 = Object.getOwnPropertyDescriptor; const u1 = Object.getOwnPropertyNames; const c1 = Object.getPrototypeOf; const d1 = Object.prototype.hasOwnProperty; const h1 = (n, e) => { for (const t in e)Al(n, t, { get: e[t], enumerable: !0 }) }; const By = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of u1(e))!d1.call(n, i) && i !== t && Al(n, i, { get: () => e[i], enumerable: !(r = l1(e, i)) || r.enumerable }); return n }; const f1 = (n, e, t) => (t = n != null ? a1(c1(n)) : {}, By(!n || !n.__esModule ? Al(t, 'default', { value: n, enumerable: !0 }) : t, n)); const p1 = n => By(Al({}, '__esModule', { value: !0 }), n); const $y = {}; h1($y, { defaultProps: () => y1, propTypes: () => g1 }); const Gy = p1($y); const m1 = f1(o1); const { string: Ve, bool: tt, number: Wr, array: uu, oneOfType: hs, shape: Tt, object: Qe, func: ke, node: hp } = m1.default; const g1 = { url: hs([Ve, uu, Qe]), playing: tt, loop: tt, controls: tt, volume: Wr, muted: tt, playbackRate: Wr, width: hs([Ve, Wr]), height: hs([Ve, Wr]), style: Qe, progressInterval: Wr, playsinline: tt, pip: tt, stopOnUnmount: tt, light: hs([tt, Ve, Qe]), playIcon: hp, previewTabIndex: Wr, previewAriaLabel: Ve, fallback: hp, oEmbedUrl: Ve, wrapper: hs([Ve, ke, Tt({ render: ke.isRequired })]), config: Tt({ soundcloud: Tt({ options: Qe }), youtube: Tt({ playerVars: Qe, embedOptions: Qe, onUnstarted: ke }), facebook: Tt({ appId: Ve, version: Ve, playerId: Ve, attributes: Qe }), dailymotion: Tt({ params: Qe }), vimeo: Tt({ playerOptions: Qe, title: Ve }), mux: Tt({ attributes: Qe, version: Ve }), file: Tt({ attributes: Qe, tracks: uu, forceVideo: tt, forceAudio: tt, forceHLS: tt, forceSafariHLS: tt, forceDisableHls: tt, forceDASH: tt, forceFLV: tt, hlsOptions: Qe, hlsVersion: Ve, dashVersion: Ve, flvVersion: Ve }), wistia: Tt({ options: Qe, playerId: Ve, customControls: uu }), mixcloud: Tt({ options: Qe }), twitch: Tt({ options: Qe, playerId: Ve }), vidyard: Tt({ options: Qe }) }), onReady: ke, onStart: ke, onPlay: ke, onPause: ke, onBuffer: ke, onBufferEnd: ke, onEnded: ke, onError: ke, onDuration: ke, onSeek: ke, onPlaybackRateChange: ke, onPlaybackQualityChange: ke, onProgress: ke, onClickPreview: ke, onEnablePIP: ke, onDisablePIP: ke }; const He = () => {}; const y1 = { playing: !1, loop: !1, controls: !1, volume: null, muted: !1, playbackRate: 1, width: '640px', height: '360px', style: {}, progressInterval: 1e3, playsinline: !1, pip: !1, stopOnUnmount: !0, light: !1, fallback: null, wrapper: 'div', previewTabIndex: 0, previewAriaLabel: '', oEmbedUrl: 'https://noembed.com/embed?url={url}', config: { soundcloud: { options: { visual: !0, buying: !1, liking: !1, download: !1, sharing: !1, show_comments: !1, show_playcount: !1 } }, youtube: { playerVars: { playsinline: 1, showinfo: 0, rel: 0, iv_load_policy: 3, modestbranding: 1 }, embedOptions: {}, onUnstarted: He }, facebook: { appId: '1309697205772819', version: 'v3.3', playerId: null, attributes: {} }, dailymotion: { params: { api: 1, 'endscreen-enable': !1 } }, vimeo: { playerOptions: { autopause: !1, byline: !1, portrait: !1, title: !1 }, title: null }, mux: { attributes: {}, version: '2' }, file: { attributes: {}, tracks: [], forceVideo: !1, forceAudio: !1, forceHLS: !1, forceDASH: !1, forceFLV: !1, hlsOptions: {}, hlsVersion: '1.1.4', dashVersion: '3.1.3', flvVersion: '1.5.0', forceDisableHls: !1 }, wistia: { options: {}, playerId: null, customControls: null }, mixcloud: { options: { hide_cover: 1 } }, twitch: { options: {}, playerId: null }, vidyard: { options: {} } }, onReady: He, onStart: He, onPlay: He, onPause: He, onBuffer: He, onBufferEnd: He, onEnded: He, onError: He, onDuration: He, onSeek: He, onPlaybackRateChange: He, onPlaybackQualityChange: He, onProgress: He, onClickPreview: He, onEnablePIP: He, onDisablePIP: He }; const v1 = Object.create; const So = Object.defineProperty; const E1 = Object.getOwnPropertyDescriptor; const S1 = Object.getOwnPropertyNames; const T1 = Object.getPrototypeOf; const x1 = Object.prototype.hasOwnProperty; const L1 = (n, e, t) => e in n ? So(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t; const R1 = (n, e) => { for (const t in e)So(n, t, { get: e[t], enumerable: !0 }) }; const Vy = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of S1(e))!x1.call(n, i) && i !== t && So(n, i, { get: () => e[i], enumerable: !(r = E1(e, i)) || r.enumerable }); return n }; const Hy = (n, e, t) => (t = n != null ? v1(T1(n)) : {}, Vy(!n || !n.__esModule ? So(t, 'default', { value: n, enumerable: !0 }) : t, n)); const A1 = n => Vy(So({}, '__esModule', { value: !0 }), n); const we = (n, e, t) => (L1(n, typeof e !== 'symbol' ? e + '' : e, t), t); const Ky = {}; R1(Ky, { default: () => wl }); const w1 = A1(Ky); const fp = Hy(k); const C1 = Hy(Fy); const jy = Gy; const I1 = Rl; const _1 = 5e3; class wl extends fp.Component {constructor () { super(...arguments), we(this, 'mounted', !1), we(this, 'isReady', !1), we(this, 'isPlaying', !1), we(this, 'isLoading', !0), we(this, 'loadOnReady', null), we(this, 'startOnPlay', !0), we(this, 'seekOnPlay', null), we(this, 'onDurationCalled', !1), we(this, 'handlePlayerMount', e => { if (this.player) { this.progress(); return } this.player = e, this.player.load(this.props.url), this.progress() }), we(this, 'getInternalPlayer', e => this.player ? this.player[e] : null), we(this, 'progress', () => { if (this.props.url && this.player && this.isReady) { const e = this.getCurrentTime() || 0; const t = this.getSecondsLoaded(); const r = this.getDuration(); if (r) { const i = { playedSeconds: e, played: e / r }; t !== null && (i.loadedSeconds = t, i.loaded = t / r), (i.playedSeconds !== this.prevPlayed || i.loadedSeconds !== this.prevLoaded) && this.props.onProgress(i), this.prevPlayed = i.playedSeconds, this.prevLoaded = i.loadedSeconds } } this.progressTimeout = setTimeout(this.progress, this.props.progressFrequency || this.props.progressInterval) }), we(this, 'handleReady', () => { if (!this.mounted) return; this.isReady = !0, this.isLoading = !1; const { onReady: e, playing: t, volume: r, muted: i } = this.props; e(), !i && r !== null && this.player.setVolume(r), this.loadOnReady ? (this.player.load(this.loadOnReady, !0), this.loadOnReady = null) : t && this.player.play(), this.handleDurationCheck() }), we(this, 'handlePlay', () => { this.isPlaying = !0, this.isLoading = !1; const { onStart: e, onPlay: t, playbackRate: r } = this.props; this.startOnPlay && (this.player.setPlaybackRate && r !== 1 && this.player.setPlaybackRate(r), e(), this.startOnPlay = !1), t(), this.seekOnPlay && (this.seekTo(this.seekOnPlay), this.seekOnPlay = null), this.handleDurationCheck() }), we(this, 'handlePause', e => { this.isPlaying = !1, this.isLoading || this.props.onPause(e) }), we(this, 'handleEnded', () => { const { activePlayer: e, loop: t, onEnded: r } = this.props; e.loopOnEnded && t && this.seekTo(0), t || (this.isPlaying = !1, r()) }), we(this, 'handleError', (...e) => { this.isLoading = !1, this.props.onError(...e) }), we(this, 'handleDurationCheck', () => { clearTimeout(this.durationCheckTimeout); const e = this.getDuration(); e ? this.onDurationCalled || (this.props.onDuration(e), this.onDurationCalled = !0) : this.durationCheckTimeout = setTimeout(this.handleDurationCheck, 100) }), we(this, 'handleLoaded', () => { this.isLoading = !1 }) }componentDidMount () { this.mounted = !0 }componentWillUnmount () { clearTimeout(this.progressTimeout), clearTimeout(this.durationCheckTimeout), this.isReady && this.props.stopOnUnmount && (this.player.stop(), this.player.disablePIP && this.player.disablePIP()), this.mounted = !1 }componentDidUpdate (e) { if (!this.player) return; const { url: t, playing: r, volume: i, muted: s, playbackRate: o, pip: a, loop: l, activePlayer: u, disableDeferredLoading: c } = this.props; if (!(0, C1.default)(e.url, t)) { if (this.isLoading && !u.forceLoad && !c && !(0, I1.isMediaStream)(t)) { console.warn(`ReactPlayer: the attempt to load ${t} is being deferred until the player has loaded`), this.loadOnReady = t; return } this.isLoading = !0, this.startOnPlay = !0, this.onDurationCalled = !1, this.player.load(t, this.isReady) }!e.playing && r && !this.isPlaying && this.player.play(), e.playing && !r && this.isPlaying && this.player.pause(), !e.pip && a && this.player.enablePIP && this.player.enablePIP(), e.pip && !a && this.player.disablePIP && this.player.disablePIP(), e.volume !== i && i !== null && this.player.setVolume(i), e.muted !== s && (s ? this.player.mute() : (this.player.unmute(), i !== null && setTimeout(() => this.player.setVolume(i)))), e.playbackRate !== o && this.player.setPlaybackRate && this.player.setPlaybackRate(o), e.loop !== l && this.player.setLoop && this.player.setLoop(l) }getDuration () { return this.isReady ? this.player.getDuration() : null }getCurrentTime () { return this.isReady ? this.player.getCurrentTime() : null }getSecondsLoaded () { return this.isReady ? this.player.getSecondsLoaded() : null }seekTo (e, t, r) { if (!this.isReady) { e !== 0 && (this.seekOnPlay = e, setTimeout(() => { this.seekOnPlay = null }, _1)); return } if (t ? t === 'fraction' : e > 0 && e < 1) { const s = this.player.getDuration(); if (!s) { console.warn('ReactPlayer: could not seek using fraction duration not yet available'); return } this.player.seekTo(s * e, r); return } this.player.seekTo(e, r) }render () { const e = this.props.activePlayer; return e ? fp.default.createElement(e, { ...this.props, onMount: this.handlePlayerMount, onReady: this.handleReady, onPlay: this.handlePlay, onPause: this.handlePause, onEnded: this.handleEnded, onLoaded: this.handleLoaded, onError: this.handleError }) : null }}we(wl, 'displayName', 'Player'); we(wl, 'propTypes', jy.propTypes); we(wl, 'defaultProps', jy.defaultProps); const D1 = Object.create; const To = Object.defineProperty; const k1 = Object.getOwnPropertyDescriptor; const P1 = Object.getOwnPropertyNames; const b1 = Object.getPrototypeOf; const O1 = Object.prototype.hasOwnProperty; const F1 = (n, e, t) => e in n ? To(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t; const M1 = (n, e) => { for (const t in e)To(n, t, { get: e[t], enumerable: !0 }) }; const zy = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of P1(e))!O1.call(n, i) && i !== t && To(n, i, { get: () => e[i], enumerable: !(r = k1(e, i)) || r.enumerable }); return n }; const xo = (n, e, t) => (t = n != null ? D1(b1(n)) : {}, zy(!n || !n.__esModule ? To(t, 'default', { value: n, enumerable: !0 }) : t, n)); const N1 = n => zy(To({}, '__esModule', { value: !0 }), n); const Ae = (n, e, t) => (F1(n, typeof e !== 'symbol' ? e + '' : e, t), t); const Wy = {}; M1(Wy, { createReactPlayer: () => z1 }); const U1 = N1(Wy); const ti = xo(k); const B1 = xo(py); const cu = xo(XR); const pp = xo(Fy); const Ss = Gy; const Yy = Rl; const $1 = xo(w1); const G1 = (0, Yy.lazy)(() => ct(() => import('./Preview-DzIRSmvR.js').then(n => n.P), [])); const V1 = typeof window < 'u' && window.document && typeof document < 'u'; const H1 = typeof Pl < 'u' && Pl.window && Pl.window.document; const K1 = Object.keys(Ss.propTypes); const j1 = V1 || H1 ? ti.Suspense : () => null; const fs = []; const z1 = (n, e) => { let t; return t = class extends ti.Component {constructor () { super(...arguments), Ae(this, 'state', { showPreview: !!this.props.light }), Ae(this, 'references', { wrapper: r => { this.wrapper = r }, player: r => { this.player = r } }), Ae(this, 'handleClickPreview', r => { this.setState({ showPreview: !1 }), this.props.onClickPreview(r) }), Ae(this, 'showPreview', () => { this.setState({ showPreview: !0 }) }), Ae(this, 'getDuration', () => this.player ? this.player.getDuration() : null), Ae(this, 'getCurrentTime', () => this.player ? this.player.getCurrentTime() : null), Ae(this, 'getSecondsLoaded', () => this.player ? this.player.getSecondsLoaded() : null), Ae(this, 'getInternalPlayer', (r = 'player') => this.player ? this.player.getInternalPlayer(r) : null), Ae(this, 'seekTo', (r, i, s) => { if (!this.player) return null; this.player.seekTo(r, i, s) }), Ae(this, 'handleReady', () => { this.props.onReady(this) }), Ae(this, 'getActivePlayer', (0, cu.default)(r => { for (const i of [...fs, ...n]) if (i.canPlay(r)) return i; return e || null })), Ae(this, 'getConfig', (0, cu.default)((r, i) => { const { config: s } = this.props; return B1.default.all([Ss.defaultProps.config, Ss.defaultProps.config[i] || {}, s, s[i] || {}]) })), Ae(this, 'getAttributes', (0, cu.default)(r => (0, Yy.omit)(this.props, K1))), Ae(this, 'renderActivePlayer', r => { if (!r) return null; const i = this.getActivePlayer(r); if (!i) return null; const s = this.getConfig(r, i.key); return ti.default.createElement($1.default, { ...this.props, key: i.key, ref: this.references.player, config: s, activePlayer: i.lazyPlayer || i, onReady: this.handleReady }) }) }shouldComponentUpdate (r, i) { return !(0, pp.default)(this.props, r) || !(0, pp.default)(this.state, i) }componentDidUpdate (r) { const { light: i } = this.props; !r.light && i && this.setState({ showPreview: !0 }), r.light && !i && this.setState({ showPreview: !1 }) }renderPreview (r) { if (!r) return null; const { light: i, playIcon: s, previewTabIndex: o, oEmbedUrl: a, previewAriaLabel: l } = this.props; return ti.default.createElement(G1, { url: r, light: i, playIcon: s, previewTabIndex: o, previewAriaLabel: l, oEmbedUrl: a, onClick: this.handleClickPreview }) }render () { const { url: r, style: i, width: s, height: o, fallback: a, wrapper: l } = this.props; const { showPreview: u } = this.state; const c = this.getAttributes(r); const d = typeof l === 'string' ? this.references.wrapper : void 0; return ti.default.createElement(l, { ref: d, style: { ...i, width: s, height: o }, ...c }, ti.default.createElement(j1, { fallback: a }, u ? this.renderPreview(r) : this.renderActivePlayer(r))) }}, Ae(t, 'displayName', 'ReactPlayer'), Ae(t, 'propTypes', Ss.propTypes), Ae(t, 'defaultProps', Ss.defaultProps), Ae(t, 'addCustomPlayer', r => { fs.push(r) }), Ae(t, 'removeCustomPlayers', () => { fs.length = 0 }), Ae(t, 'canPlay', r => { for (const i of [...fs, ...n]) if (i.canPlay(r)) return !0; return !1 }), Ae(t, 'canEnablePIP', r => { for (const i of [...fs, ...n]) if (i.canEnablePIP && i.canEnablePIP(r)) return !0; return !1 }), t }; const W1 = Object.create; const Cl = Object.defineProperty; const Y1 = Object.getOwnPropertyDescriptor; const q1 = Object.getOwnPropertyNames; const Q1 = Object.getPrototypeOf; const X1 = Object.prototype.hasOwnProperty; const J1 = (n, e) => { for (const t in e)Cl(n, t, { get: e[t], enumerable: !0 }) }; const qy = (n, e, t, r) => { if (e && typeof e === 'object' || typeof e === 'function') for (const i of q1(e))!X1.call(n, i) && i !== t && Cl(n, i, { get: () => e[i], enumerable: !(r = Y1(e, i)) || r.enumerable }); return n }; const Z1 = (n, e, t) => (t = n != null ? W1(Q1(n)) : {}, qy(!n || !n.__esModule ? Cl(t, 'default', { value: n, enumerable: !0 }) : t, n)); const eA = n => qy(Cl({}, '__esModule', { value: !0 }), n); const Qy = {}; J1(Qy, { default: () => iA }); const tA = eA(Qy); const Kc = Z1(jR); const nA = U1; const rA = Kc.default[Kc.default.length - 1]; var iA = (0, nA.createReactPlayer)(Kc.default, rA); const Xy = ad(tA); const sA = 'http://localhost:8000/api'; const oA = () => { const [n, e] = k.useState(''); const [t, r] = k.useState(''); const [i, s] = k.useState(); const { addMagnet: o, stopStream: a } = dy(); const l = hy({ setData: s, infoHash: n }); const u = async () => { let h; try { if (n) { const f = await o(n); const p = (h = f == null ? void 0 : f.files) == null ? void 0 : h.find(m => m.name.includes('.mp4') || m.name.includes('.mkv') || m.name.includes('.avi')); p != null && r(`${sA}/video/stream/${n}/${p.name}`) } } catch (f) { console.error(f) } }; const c = () => { r(''), e('') }; const d = () => { l == null || l.close(), n && a(n), c() }; return k.useEffect(() => () => { l == null || l.close() }, [l]), B.jsxs('div', { className: fr.container, children: [B.jsx('h4', { className: fr.header, children: 'Torrent Stream' }), B.jsxs('div', { className: fr.main, children: [B.jsxs('div', { className: fr.controls, children: [B.jsx('input', { className: fr.input, type: 'text', value: n, placeholder: 'Past magnet', onChange: h => e(h.target.value) }), B.jsxs('div', { className: fr.buttons, children: [B.jsx('button', { onClick: u, children: 'Play' }), B.jsx('button', { onClick: c, children: 'Cancel' }), B.jsx('button', { onClick: d, children: 'Stop' })] }), i && B.jsxs('div', { children: [B.jsxs('p', { children: ['Download speed: ', (i.speed / 1048576).toFixed(2) || '', ' mb/s'] }), B.jsxs('p', { children: ['Progress: ', (i.progress * 100).toFixed(1) || '', ' %'] }), B.jsxs('p', { children: ['Ratio: ', i.ratio || ''] })] })] }), B.jsx('div', { style: { width: '700px', height: '400px' }, children: B.jsx(Xy, { className: fr.video, url: t, controls: !0, playing: !0 }) })] })] }) }; var Js = (n => (n.GetPlaylist = 'GetPlaylist', n.GetUpdateTvStreams = 'GetUpdateTvStreams', n.GetScanSearchMovie = 'GetScanSearchMovie', n))(Js || {}); var jc = (n => (n.ru = 'ru', n.en = 'en', n.nsfw = 'nsfw', n.noname = 'noname', n))(jc || {}); function aA (n) { const { isError: e, isLoading: t, data: r, refetch: i } = hh({ queryKey: [`${Js.GetPlaylist}/${n}`], queryFn: async () => { if (n) return await CL(n) }, refetchOnWindowFocus: !1 }); return k.useMemo(() => ({ isError: e, isLoading: t, data: r, refetch: i }), [r, e, t, i]) } const lA = '_list_1w0rq_1'; const uA = '_item_1w0rq_7'; const cA = '_active_1w0rq_26'; const du = { list: lA, item: uA, active: cA }; const dA = ({ handleChannel: n, list: e, className: t }) => { const { data: r } = aA(e); const [i, s] = k.useState(); const o = a => { n(a), s(a.url) }; return B.jsx('ul', { className: Ti(du.list, t), children: r == null ? void 0 : r.map(a => B.jsxs('li', { className: Ti(du.item, { [du.active]: a.url === i }), onClick: () => o(a), children: [a.logo && B.jsx('div', { children: B.jsx('img', { src: a.logo, alt: a.name }) }), B.jsx('p', { children: a.name })] }, a.url + a.id)) }) }; function hA () { const n = dh(); const { isError: e, isLoading: t, data: r, refetch: i, isSuccess: s } = hh({ queryKey: [Js.GetUpdateTvStreams], queryFn: IL, refetchOnWindowFocus: !1, enabled: !1 }); return k.useEffect(() => { s && (n.refetchQueries({ queryKey: ['posts'], type: 'active' }), n.invalidateQueries({ queryKey: [Js.GetPlaylist], refetchType: 'all' })) }, [s, n]), k.useMemo(() => ({ isError: e, isLoading: t, data: r, refetch: i }), [r, e, t, i]) } const fA = '_container_11o3h_1'; const pA = '_header_11o3h_7'; const mA = '_buttons_11o3h_18'; const gA = '_main_11o3h_36'; const yA = '_playlist_11o3h_42'; const vA = '_player_11o3h_47'; const pr = { container: fA, header: pA, buttons: mA, main: gA, playlist: yA, player: vA }; function EA (n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n } const Jy = { exports: {} }; (function (n, e) { (function (t) { const r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/; const i = /^(?=([^\/?#]*))\1([^]*)$/; const s = /(?:\/|^)\.(?=\/)/g; const o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g; var a = { buildAbsoluteURL: function (l, u, c) { if (c = c || {}, l = l.trim(), u = u.trim(), !u) { if (!c.alwaysNormalize) return l; const d = a.parseURL(l); if (!d) throw new Error('Error trying to parse base URL.'); return d.path = a.normalizePath(d.path), a.buildURLFromParts(d) } const h = a.parseURL(u); if (!h) throw new Error('Error trying to parse relative URL.'); if (h.scheme) return c.alwaysNormalize ? (h.path = a.normalizePath(h.path), a.buildURLFromParts(h)) : u; const f = a.parseURL(l); if (!f) throw new Error('Error trying to parse base URL.'); if (!f.netLoc && f.path && f.path[0] !== '/') { const p = i.exec(f.path); f.netLoc = p[1], f.path = p[2] }f.netLoc && !f.path && (f.path = '/'); const m = { scheme: f.scheme, netLoc: h.netLoc, path: null, params: h.params, query: h.query, fragment: h.fragment }; if (!h.netLoc && (m.netLoc = f.netLoc, h.path[0] !== '/')) if (!h.path)m.path = f.path, h.params || (m.params = f.params, h.query || (m.query = f.query)); else { const y = f.path; const g = y.substring(0, y.lastIndexOf('/') + 1) + h.path; m.path = a.normalizePath(g) } return m.path === null && (m.path = c.alwaysNormalize ? a.normalizePath(h.path) : h.path), a.buildURLFromParts(m) }, parseURL: function (l) { const u = r.exec(l); return u ? { scheme: u[1] || '', netLoc: u[2] || '', path: u[3] || '', params: u[4] || '', query: u[5] || '', fragment: u[6] || '' } : null }, normalizePath: function (l) { for (l = l.split('').reverse().join('').replace(s, ''); l.length !== (l = l.replace(o, '')).length;);return l.split('').reverse().join('') }, buildURLFromParts: function (l) { return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment } }; n.exports = a })() })(Jy); const Eh = Jy.exports; function mp (n, e) { const t = Object.keys(n); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable })), t.push.apply(t, r) } return t } function $e (n) { for (let e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? mp(Object(t), !0).forEach(function (r) { xA(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : mp(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function SA (n, e) { if (typeof n !== 'object' || !n) return n; const t = n[Symbol.toPrimitive]; if (t !== void 0) { const r = t.call(n, e || 'default'); if (typeof r !== 'object') return r; throw new TypeError('@@toPrimitive must return a primitive value.') } return (e === 'string' ? String : Number)(n) } function TA (n) { const e = SA(n, 'string'); return typeof e === 'symbol' ? e : String(e) } function xA (n, e, t) { return e = TA(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function De () { return De = Object.assign ? Object.assign.bind() : function (n) { for (let e = 1; e < arguments.length; e++) { const t = arguments[e]; for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, De.apply(this, arguments) } const K = Number.isFinite || function (n) { return typeof n === 'number' && isFinite(n) }; const LA = Number.isSafeInteger || function (n) { return typeof n === 'number' && Math.abs(n) <= RA }; const RA = Number.MAX_SAFE_INTEGER || 9007199254740991; const S = (function (n) { return n.MEDIA_ATTACHING = 'hlsMediaAttaching', n.MEDIA_ATTACHED = 'hlsMediaAttached', n.MEDIA_DETACHING = 'hlsMediaDetaching', n.MEDIA_DETACHED = 'hlsMediaDetached', n.BUFFER_RESET = 'hlsBufferReset', n.BUFFER_CODECS = 'hlsBufferCodecs', n.BUFFER_CREATED = 'hlsBufferCreated', n.BUFFER_APPENDING = 'hlsBufferAppending', n.BUFFER_APPENDED = 'hlsBufferAppended', n.BUFFER_EOS = 'hlsBufferEos', n.BUFFER_FLUSHING = 'hlsBufferFlushing', n.BUFFER_FLUSHED = 'hlsBufferFlushed', n.MANIFEST_LOADING = 'hlsManifestLoading', n.MANIFEST_LOADED = 'hlsManifestLoaded', n.MANIFEST_PARSED = 'hlsManifestParsed', n.LEVEL_SWITCHING = 'hlsLevelSwitching', n.LEVEL_SWITCHED = 'hlsLevelSwitched', n.LEVEL_LOADING = 'hlsLevelLoading', n.LEVEL_LOADED = 'hlsLevelLoaded', n.LEVEL_UPDATED = 'hlsLevelUpdated', n.LEVEL_PTS_UPDATED = 'hlsLevelPtsUpdated', n.LEVELS_UPDATED = 'hlsLevelsUpdated', n.AUDIO_TRACKS_UPDATED = 'hlsAudioTracksUpdated', n.AUDIO_TRACK_SWITCHING = 'hlsAudioTrackSwitching', n.AUDIO_TRACK_SWITCHED = 'hlsAudioTrackSwitched', n.AUDIO_TRACK_LOADING = 'hlsAudioTrackLoading', n.AUDIO_TRACK_LOADED = 'hlsAudioTrackLoaded', n.SUBTITLE_TRACKS_UPDATED = 'hlsSubtitleTracksUpdated', n.SUBTITLE_TRACKS_CLEARED = 'hlsSubtitleTracksCleared', n.SUBTITLE_TRACK_SWITCH = 'hlsSubtitleTrackSwitch', n.SUBTITLE_TRACK_LOADING = 'hlsSubtitleTrackLoading', n.SUBTITLE_TRACK_LOADED = 'hlsSubtitleTrackLoaded', n.SUBTITLE_FRAG_PROCESSED = 'hlsSubtitleFragProcessed', n.CUES_PARSED = 'hlsCuesParsed', n.NON_NATIVE_TEXT_TRACKS_FOUND = 'hlsNonNativeTextTracksFound', n.INIT_PTS_FOUND = 'hlsInitPtsFound', n.FRAG_LOADING = 'hlsFragLoading', n.FRAG_LOAD_EMERGENCY_ABORTED = 'hlsFragLoadEmergencyAborted', n.FRAG_LOADED = 'hlsFragLoaded', n.FRAG_DECRYPTED = 'hlsFragDecrypted', n.FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment', n.FRAG_PARSING_USERDATA = 'hlsFragParsingUserdata', n.FRAG_PARSING_METADATA = 'hlsFragParsingMetadata', n.FRAG_PARSED = 'hlsFragParsed', n.FRAG_BUFFERED = 'hlsFragBuffered', n.FRAG_CHANGED = 'hlsFragChanged', n.FPS_DROP = 'hlsFpsDrop', n.FPS_DROP_LEVEL_CAPPING = 'hlsFpsDropLevelCapping', n.MAX_AUTO_LEVEL_UPDATED = 'hlsMaxAutoLevelUpdated', n.ERROR = 'hlsError', n.DESTROYING = 'hlsDestroying', n.KEY_LOADING = 'hlsKeyLoading', n.KEY_LOADED = 'hlsKeyLoaded', n.LIVE_BACK_BUFFER_REACHED = 'hlsLiveBackBufferReached', n.BACK_BUFFER_REACHED = 'hlsBackBufferReached', n.STEERING_MANIFEST_LOADED = 'hlsSteeringManifestLoaded', n }({})); const J = (function (n) { return n.NETWORK_ERROR = 'networkError', n.MEDIA_ERROR = 'mediaError', n.KEY_SYSTEM_ERROR = 'keySystemError', n.MUX_ERROR = 'muxError', n.OTHER_ERROR = 'otherError', n }({})); const D = (function (n) { return n.KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys', n.KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess', n.KEY_SYSTEM_NO_SESSION = 'keySystemNoSession', n.KEY_SYSTEM_NO_CONFIGURED_LICENSE = 'keySystemNoConfiguredLicense', n.KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed', n.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = 'keySystemServerCertificateRequestFailed', n.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = 'keySystemServerCertificateUpdateFailed', n.KEY_SYSTEM_SESSION_UPDATE_FAILED = 'keySystemSessionUpdateFailed', n.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = 'keySystemStatusOutputRestricted', n.KEY_SYSTEM_STATUS_INTERNAL_ERROR = 'keySystemStatusInternalError', n.MANIFEST_LOAD_ERROR = 'manifestLoadError', n.MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut', n.MANIFEST_PARSING_ERROR = 'manifestParsingError', n.MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError', n.LEVEL_EMPTY_ERROR = 'levelEmptyError', n.LEVEL_LOAD_ERROR = 'levelLoadError', n.LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut', n.LEVEL_PARSING_ERROR = 'levelParsingError', n.LEVEL_SWITCH_ERROR = 'levelSwitchError', n.AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError', n.AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut', n.SUBTITLE_LOAD_ERROR = 'subtitleTrackLoadError', n.SUBTITLE_TRACK_LOAD_TIMEOUT = 'subtitleTrackLoadTimeOut', n.FRAG_LOAD_ERROR = 'fragLoadError', n.FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut', n.FRAG_DECRYPT_ERROR = 'fragDecryptError', n.FRAG_PARSING_ERROR = 'fragParsingError', n.FRAG_GAP = 'fragGap', n.REMUX_ALLOC_ERROR = 'remuxAllocError', n.KEY_LOAD_ERROR = 'keyLoadError', n.KEY_LOAD_TIMEOUT = 'keyLoadTimeOut', n.BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError', n.BUFFER_INCOMPATIBLE_CODECS_ERROR = 'bufferIncompatibleCodecsError', n.BUFFER_APPEND_ERROR = 'bufferAppendError', n.BUFFER_APPENDING_ERROR = 'bufferAppendingError', n.BUFFER_STALLED_ERROR = 'bufferStalledError', n.BUFFER_FULL_ERROR = 'bufferFullError', n.BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole', n.BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall', n.INTERNAL_EXCEPTION = 'internalException', n.INTERNAL_ABORTED = 'aborted', n.UNKNOWN = 'unknown', n }({})); const vr = function () {}; const zc = { trace: vr, debug: vr, log: vr, warn: vr, info: vr, error: vr }; let Ds = zc; function AA (n) { const e = self.console[n]; return e ? e.bind(self.console, `[${n}] >`) : vr } function wA (n, ...e) { e.forEach(function (t) { Ds[t] = n[t] ? n[t].bind(n) : AA(t) }) } function CA (n, e) { if (typeof console === 'object' && n === !0 || typeof n === 'object') { wA(n, 'debug', 'log', 'info', 'warn', 'error'); try { Ds.log(`Debug logs enabled for "${e}" in hls.js version 1.5.8`) } catch { Ds = zc } } else Ds = zc } const C = Ds; const IA = /^(\d+)x(\d+)$/; const gp = /(.+?)=(".*?"|.*?)(?:,|$)/g; class ve {constructor (e) { typeof e === 'string' && (e = ve.parseAttrList(e)), De(this, e) } get clientAttrs () { return Object.keys(this).filter(e => e.substring(0, 2) === 'X-') }decimalInteger (e) { const t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t }hexadecimalInteger (e) { if (this[e]) { let t = (this[e] || '0x').slice(2); t = (t.length & 1 ? '0' : '') + t; const r = new Uint8Array(t.length / 2); for (let i = 0; i < t.length / 2; i++)r[i] = parseInt(t.slice(i * 2, i * 2 + 2), 16); return r } else return null }hexadecimalIntegerAsNumber (e) { const t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t }decimalFloatingPoint (e) { return parseFloat(this[e]) }optionalFloat (e, t) { const r = this[e]; return r ? parseFloat(r) : t }enumeratedString (e) { return this[e] }bool (e) { return this[e] === 'YES' }decimalResolution (e) { const t = IA.exec(this[e]); if (t !== null) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) } } static parseAttrList (e) { let t; const r = {}; const i = '"'; for (gp.lastIndex = 0; (t = gp.exec(e)) !== null;) { let s = t[2]; s.indexOf(i) === 0 && s.lastIndexOf(i) === s.length - 1 && (s = s.slice(1, -1)); const o = t[1].trim(); r[o] = s } return r }} function _A (n) { return n !== 'ID' && n !== 'CLASS' && n !== 'START-DATE' && n !== 'DURATION' && n !== 'END-DATE' && n !== 'END-ON-NEXT' } function DA (n) { return n === 'SCTE35-OUT' || n === 'SCTE35-IN' } class Zy {constructor (e, t) { if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) { const r = t.attr; for (const i in r) if (Object.prototype.hasOwnProperty.call(e, i) && e[i] !== r[i]) { C.warn(`DATERANGE tag attribute: "${i}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = i; break }e = De(new ve({}), r, e) } if (this.attr = e, this._startDate = new Date(e['START-DATE']), 'END-DATE' in this.attr) { const r = new Date(this.attr['END-DATE']); K(r.getTime()) && (this._endDate = r) } } get id () { return this.attr.ID } get class () { return this.attr.CLASS } get startDate () { return this._startDate } get endDate () { if (this._endDate) return this._endDate; const e = this.duration; return e !== null ? new Date(this._startDate.getTime() + e * 1e3) : null } get duration () { if ('DURATION' in this.attr) { const e = this.attr.decimalFloatingPoint('DURATION'); if (K(e)) return e } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3; return null } get plannedDuration () { return 'PLANNED-DURATION' in this.attr ? this.attr.decimalFloatingPoint('PLANNED-DURATION') : null } get endOnNext () { return this.attr.bool('END-ON-NEXT') } get isValid () { return !!this.id && !this._badValueForSameId && K(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) }} class Il {constructor () { this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 } }} const ae = { AUDIO: 'audio', VIDEO: 'video', AUDIOVIDEO: 'audiovideo' }; class ev {constructor (e) { this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = { [ae.AUDIO]: null, [ae.VIDEO]: null, [ae.AUDIOVIDEO]: null }, this.baseurl = e }setByteRange (e, t) { const r = e.split('@', 2); let i; r.length === 1 ? i = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : i = parseInt(r[1]), this._byteRange = [i, parseInt(r[0]) + i] } get byteRange () { return this._byteRange ? this._byteRange : [] } get byteRangeStartOffset () { return this.byteRange[0] } get byteRangeEndOffset () { return this.byteRange[1] } get url () { return !this._url && this.baseurl && this.relurl && (this._url = Eh.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url || '' } set url (e) { this._url = e }} class hu extends ev {constructor (e, t) { super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new Il(), this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e } get decryptdata () { const { levelkeys: e } = this; if (!e && !this._decryptdata) return null; if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) { const t = this.levelkeys.identity; if (t) this._decryptdata = t.getDecryptData(this.sn); else { const r = Object.keys(this.levelkeys); if (r.length === 1) return this._decryptdata = this.levelkeys[r[0]].getDecryptData(this.sn) } } return this._decryptdata } get end () { return this.start + this.duration } get endProgramDateTime () { if (this.programDateTime === null || !K(this.programDateTime)) return null; const e = K(this.duration) ? this.duration : 0; return this.programDateTime + e * 1e3 } get encrypted () { let e; if ((e = this._decryptdata) != null && e.encrypted) return !0; if (this.levelkeys) { const t = Object.keys(this.levelkeys); const r = t.length; if (r > 1 || r === 1 && this.levelkeys[t[0]].encrypted) return !0 } return !1 }setKeyFormat (e) { if (this.levelkeys) { const t = this.levelkeys[e]; t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn)) } }abortRequests () { let e, t; (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort() }setElementaryStreamInfo (e, t, r, i, s, o = !1) { const { elementaryStreams: a } = this; const l = a[e]; if (!l) { a[e] = { startPTS: t, endPTS: r, startDTS: i, endDTS: s, partial: o }; return }l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, r), l.startDTS = Math.min(l.startDTS, i), l.endDTS = Math.max(l.endDTS, s) }clearElementaryStreamInfo () { const { elementaryStreams: e } = this; e[ae.AUDIO] = null, e[ae.VIDEO] = null, e[ae.AUDIOVIDEO] = null }} class kA extends ev {constructor (e, t, r, i, s) { super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new Il(), this.duration = e.decimalFloatingPoint('DURATION'), this.gap = e.bool('GAP'), this.independent = e.bool('INDEPENDENT'), this.relurl = e.enumeratedString('URI'), this.fragment = t, this.index = i; const o = e.enumeratedString('BYTERANGE'); o && this.setByteRange(o, s), s && (this.fragOffset = s.fragOffset + s.duration) } get start () { return this.fragment.start + this.fragOffset } get end () { return this.start + this.duration } get loaded () { const { elementaryStreams: e } = this; return !!(e.audio || e.video || e.audiovideo) }} const PA = 10; class bA {constructor (e) { this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = '', this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e }reloaded (e) { if (!e) { this.advanced = !0, this.updated = !0; return } const t = this.lastPartSn - e.lastPartSn; const r = this.lastPartIndex - e.lastPartIndex; this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay } get hasProgramDateTime () { return this.fragments.length ? K(this.fragments[this.fragments.length - 1].programDateTime) : !1 } get levelTargetDuration () { return this.averagetargetduration || this.targetduration || PA } get drift () { const e = this.driftEndTime - this.driftStartTime; return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1 } get edge () { return this.partEnd || this.fragmentEnd } get partEnd () { let e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd } get fragmentEnd () { let e; return (e = this.fragments) != null && e.length ? this.fragments[this.fragments.length - 1].end : 0 } get age () { return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0 } get lastPartIndex () { let e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1 } get lastPartSn () { let e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN }} function Sh (n) { return Uint8Array.from(atob(n), e => e.charCodeAt(0)) } function OA (n) { const e = Wc(n).subarray(0, 16); const t = new Uint8Array(16); return t.set(e, 16 - e.length), t } function FA (n) { const e = function (r, i, s) { const o = r[i]; r[i] = r[s], r[s] = o }; e(n, 0, 3), e(n, 1, 2), e(n, 4, 5), e(n, 6, 7) } function MA (n) { const e = n.split(':'); let t = null; if (e[0] === 'data' && e.length === 2) { const r = e[1].split(';'); const i = r[r.length - 1].split(','); if (i.length === 2) { const s = i[0] === 'base64'; const o = i[1]; s ? (r.splice(-1, 1), t = Sh(o)) : t = OA(o) } } return t } function Wc (n) { return Uint8Array.from(unescape(encodeURIComponent(n)), e => e.charCodeAt(0)) } const Wi = typeof self < 'u' ? self : void 0; const ye = { CLEARKEY: 'org.w3.clearkey', FAIRPLAY: 'com.apple.fps', PLAYREADY: 'com.microsoft.playready', WIDEVINE: 'com.widevine.alpha' }; const gt = { CLEARKEY: 'org.w3.clearkey', FAIRPLAY: 'com.apple.streamingkeydelivery', PLAYREADY: 'com.microsoft.playready', WIDEVINE: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed' }; function yp (n) { switch (n) { case gt.FAIRPLAY:return ye.FAIRPLAY; case gt.PLAYREADY:return ye.PLAYREADY; case gt.WIDEVINE:return ye.WIDEVINE; case gt.CLEARKEY:return ye.CLEARKEY } } const tv = { WIDEVINE: 'edef8ba979d64acea3c827dcd51d21ed' }; function NA (n) { if (n === tv.WIDEVINE) return ye.WIDEVINE } function vp (n) { switch (n) { case ye.FAIRPLAY:return gt.FAIRPLAY; case ye.PLAYREADY:return gt.PLAYREADY; case ye.WIDEVINE:return gt.WIDEVINE; case ye.CLEARKEY:return gt.CLEARKEY } } function fu (n) { const { drmSystems: e, widevineLicenseUrl: t } = n; const r = e ? [ye.FAIRPLAY, ye.WIDEVINE, ye.PLAYREADY, ye.CLEARKEY].filter(i => !!e[i]) : []; return !r[ye.WIDEVINE] && t && r.push(ye.WIDEVINE), r } const nv = (function (n) { return Wi != null && (n = Wi.navigator) != null && n.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null }()); function UA (n, e, t, r) { let i; switch (n) { case ye.FAIRPLAY:i = ['cenc', 'sinf']; break; case ye.WIDEVINE:case ye.PLAYREADY:i = ['cenc']; break; case ye.CLEARKEY:i = ['cenc', 'keyids']; break; default:throw new Error(`Unknown key-system: ${n}`) } return BA(i, e, t, r) } function BA (n, e, t, r) { return [{ initDataTypes: n, persistentState: r.persistentState || 'optional', distinctiveIdentifier: r.distinctiveIdentifier || 'optional', sessionTypes: r.sessionTypes || [r.sessionType || 'temporary'], audioCapabilities: e.map(s => ({ contentType: `audio/mp4; codecs="${s}"`, robustness: r.audioRobustness || '', encryptionScheme: r.audioEncryptionScheme || null })), videoCapabilities: t.map(s => ({ contentType: `video/mp4; codecs="${s}"`, robustness: r.videoRobustness || '', encryptionScheme: r.videoEncryptionScheme || null })) }] } function br (n, e, t) { return Uint8Array.prototype.slice ? n.slice(e, t) : new Uint8Array(Array.prototype.slice.call(n, e, t)) } const Th = (n, e) => e + 10 <= n.length && n[e] === 73 && n[e + 1] === 68 && n[e + 2] === 51 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128; const rv = (n, e) => e + 10 <= n.length && n[e] === 51 && n[e + 1] === 68 && n[e + 2] === 73 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128; const Zs = (n, e) => { const t = e; let r = 0; for (;Th(n, e);) { r += 10; const i = _l(n, e + 6); r += i, rv(n, e + 10) && (r += 10), e += r } if (r > 0) return n.subarray(t, t + r) }; const _l = (n, e) => { let t = 0; return t = (n[e] & 127) << 21, t |= (n[e + 1] & 127) << 14, t |= (n[e + 2] & 127) << 7, t |= n[e + 3] & 127, t }; const $A = (n, e) => Th(n, e) && _l(n, e + 6) + 10 <= n.length - e; const xh = n => { const e = sv(n); for (let t = 0; t < e.length; t++) { const r = e[t]; if (iv(r)) return zA(r) } }; const iv = n => n && n.key === 'PRIV' && n.info === 'com.apple.streaming.transportStreamTimestamp'; const GA = n => { const e = String.fromCharCode(n[0], n[1], n[2], n[3]); const t = _l(n, 4); const r = 10; return { type: e, size: t, data: n.subarray(r, r + t) } }; const sv = n => { let e = 0; const t = []; for (;Th(n, e);) { const r = _l(n, e + 6); e += 10; const i = e + r; for (;e + 8 < i;) { const s = GA(n.subarray(e)); const o = VA(s); o && t.push(o), e += s.size + 10 }rv(n, e) && (e += 10) } return t }; const VA = n => n.type === 'PRIV' ? HA(n) : n.type[0] === 'W' ? jA(n) : KA(n); const HA = n => { if (n.size < 2) return; const e = fn(n.data, !0); const t = new Uint8Array(n.data.subarray(e.length + 1)); return { key: n.type, info: e, data: t.buffer } }; const KA = n => { if (n.size < 2) return; if (n.type === 'TXXX') { let t = 1; const r = fn(n.data.subarray(t), !0); t += r.length + 1; const i = fn(n.data.subarray(t)); return { key: n.type, info: r, data: i } } const e = fn(n.data.subarray(1)); return { key: n.type, data: e } }; const jA = n => { if (n.type === 'WXXX') { if (n.size < 2) return; let t = 1; const r = fn(n.data.subarray(t), !0); t += r.length + 1; const i = fn(n.data.subarray(t)); return { key: n.type, info: r, data: i } } const e = fn(n.data); return { key: n.type, data: e } }; const zA = n => { if (n.data.byteLength === 8) { const e = new Uint8Array(n.data); const t = e[3] & 1; let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7]; return r /= 45, t && (r += 4772185884e-2), Math.round(r) } }; const fn = (n, e = !1) => { const t = WA(); if (t) { const u = t.decode(n); if (e) { const c = u.indexOf('\0'); return c !== -1 ? u.substring(0, c) : u } return u.replace(/\0/g, '') } const r = n.length; let i; let s; let o; let a = ''; let l = 0; for (;l < r;) { if (i = n[l++], i === 0 && e) return a; if (i === 0 || i === 3) continue; switch (i >> 4) { case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:a += String.fromCharCode(i); break; case 12:case 13:s = n[l++], a += String.fromCharCode((i & 31) << 6 | s & 63); break; case 14:s = n[l++], o = n[l++], a += String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | (o & 63) << 0); break } } return a }; let pu; function WA () { if (!navigator.userAgent.includes('PlayStation 4')) return !pu && typeof self.TextDecoder < 'u' && (pu = new self.TextDecoder('utf-8')), pu } const tn = { hexDump: function (n) { let e = ''; for (let t = 0; t < n.length; t++) { let r = n[t].toString(16); r.length < 2 && (r = '0' + r), e += r } return e } }; const qa = Math.pow(2, 32) - 1; const YA = [].push; const ov = { video: 1, audio: 2, id3: 3, text: 4 }; function Pe (n) { return String.fromCharCode.apply(null, n) } function av (n, e) { const t = n[e] << 8 | n[e + 1]; return t < 0 ? 65536 + t : t } function Q (n, e) { const t = lv(n, e); return t < 0 ? 4294967296 + t : t } function Ep (n, e) { let t = Q(n, e); return t *= Math.pow(2, 32), t += Q(n, e + 4), t } function lv (n, e) { return n[e] << 24 | n[e + 1] << 16 | n[e + 2] << 8 | n[e + 3] } function mu (n, e, t) { n[e] = t >> 24, n[e + 1] = t >> 16 & 255, n[e + 2] = t >> 8 & 255, n[e + 3] = t & 255 } function qA (n) { const e = n.byteLength; for (let t = 0; t < e;) { const r = Q(n, t); if (r > 8 && n[t + 4] === 109 && n[t + 5] === 111 && n[t + 6] === 111 && n[t + 7] === 102) return !0; t = r > 1 ? t + r : e } return !1 } function ee (n, e) { const t = []; if (!e.length) return t; const r = n.byteLength; for (let i = 0; i < r;) { const s = Q(n, i); const o = Pe(n.subarray(i + 4, i + 8)); const a = s > 1 ? i + s : r; if (o === e[0]) if (e.length === 1)t.push(n.subarray(i + 8, a)); else { const l = ee(n.subarray(i + 8, a), e.slice(1)); l.length && YA.apply(t, l) }i = a } return t } function QA (n) { const e = []; const t = n[0]; let r = 8; const i = Q(n, r); r += 4; let s = 0; let o = 0; t === 0 ? (s = Q(n, r), o = Q(n, r + 4), r += 8) : (s = Ep(n, r), o = Ep(n, r + 8), r += 16), r += 2; let a = n.length + o; const l = av(n, r); r += 2; for (let u = 0; u < l; u++) { let c = r; const d = Q(n, c); c += 4; const h = d & 2147483647; if ((d & 2147483648) >>> 31 === 1) return C.warn('SIDX has hierarchical references (not supported)'), null; const p = Q(n, c); c += 4, e.push({ referenceSize: h, subsegmentDuration: p, info: { duration: p / i, start: a, end: a + h - 1 } }), a += h, c += 4, r = c } return { earliestPresentationTime: s, timescale: i, version: t, referencesCount: l, references: e } } function uv (n) { const e = []; const t = ee(n, ['moov', 'trak']); for (let i = 0; i < t.length; i++) { const s = t[i]; const o = ee(s, ['tkhd'])[0]; if (o) { let a = o[0]; const l = Q(o, a === 0 ? 12 : 20); const u = ee(s, ['mdia', 'mdhd'])[0]; if (u) { a = u[0]; const c = Q(u, a === 0 ? 12 : 20); const d = ee(s, ['mdia', 'hdlr'])[0]; if (d) { const h = Pe(d.subarray(8, 12)); const f = { soun: ae.AUDIO, vide: ae.VIDEO }[h]; if (f) { const p = ee(s, ['mdia', 'minf', 'stbl', 'stsd'])[0]; const m = XA(p); e[l] = { timescale: c, type: f }, e[f] = $e({ timescale: c, id: l }, m) } } } } } return ee(n, ['moov', 'mvex', 'trex']).forEach(i => { const s = Q(i, 4); const o = e[s]; o && (o.default = { duration: Q(i, 12), flags: Q(i, 20) }) }), e } function XA (n) { const e = n.subarray(8); const t = e.subarray(86); const r = Pe(e.subarray(4, 8)); let i = r; const s = r === 'enca' || r === 'encv'; if (s) { const a = ee(e, [r])[0].subarray(r === 'enca' ? 28 : 78); ee(a, ['sinf']).forEach(u => { const c = ee(u, ['schm'])[0]; if (c) { const d = Pe(c.subarray(4, 8)); if (d === 'cbcs' || d === 'cenc') { const h = ee(u, ['frma'])[0]; h && (i = Pe(h)) } } }) } switch (i) { case 'avc1':case 'avc2':case 'avc3':case 'avc4':{ const o = ee(t, ['avcC'])[0]; i += '.' + Vo(o[1]) + Vo(o[2]) + Vo(o[3]); break } case 'mp4a':{ const o = ee(e, [r])[0]; const a = ee(o.subarray(28), ['esds'])[0]; if (a && a.length > 12) { let l = 4; if (a[l++] !== 3) break; l = gu(a, l), l += 2; const u = a[l++]; if (u & 128 && (l += 2), u & 64 && (l += a[l++]), a[l++] !== 4) break; l = gu(a, l); const c = a[l++]; if (c === 64)i += '.' + Vo(c); else break; if (l += 12, a[l++] !== 5) break; l = gu(a, l); const d = a[l++]; let h = (d & 248) >> 3; h === 31 && (h += 1 + ((d & 7) << 3) + ((a[l] & 224) >> 5)), i += '.' + h } break } case 'hvc1':case 'hev1':{ const o = ee(t, ['hvcC'])[0]; const a = o[1]; const l = ['', 'A', 'B', 'C'][a >> 6]; const u = a & 31; const c = Q(o, 2); const d = (a & 32) >> 5 ? 'H' : 'L'; const h = o[12]; const f = o.subarray(6, 12); i += '.' + l + u, i += '.' + c.toString(16).toUpperCase(), i += '.' + d + h; let p = ''; for (let m = f.length; m--;) { const y = f[m]; (y || p) && (p = '.' + y.toString(16).toUpperCase() + p) }i += p; break } case 'dvh1':case 'dvhe':{ const o = ee(t, ['dvcC'])[0]; const a = o[2] >> 1 & 127; const l = o[2] << 5 & 32 | o[3] >> 3 & 31; i += '.' + Zt(a) + '.' + Zt(l); break } case 'vp09':{ const o = ee(t, ['vpcC'])[0]; const a = o[4]; const l = o[5]; const u = o[6] >> 4 & 15; i += '.' + Zt(a) + '.' + Zt(l) + '.' + Zt(u); break } case 'av01':{ const o = ee(t, ['av1C'])[0]; const a = o[1] >>> 5; const l = o[1] & 31; const u = o[2] >>> 7 ? 'H' : 'M'; const c = (o[2] & 64) >> 6; const d = (o[2] & 32) >> 5; const h = a === 2 && c ? d ? 12 : 10 : c ? 10 : 8; const f = (o[2] & 16) >> 4; const p = (o[2] & 8) >> 3; const m = (o[2] & 4) >> 2; const y = o[2] & 3; i += '.' + a + '.' + Zt(l) + u + '.' + Zt(h) + '.' + f + '.' + p + m + y + '.' + Zt(1) + '.' + Zt(1) + '.' + Zt(1) + '.' + 0; break } } return { codec: i, encrypted: s } } function gu (n, e) { const t = e + 5; for (;n[e++] & 128 && e < t;);return e } function Vo (n) { return ('0' + n.toString(16).toUpperCase()).slice(-2) } function Zt (n) { return (n < 10 ? '0' : '') + n } function JA (n, e) { if (!n || !e) return n; const t = e.keyId; return t && e.isCommonEncryption && ee(n, ['moov', 'trak']).forEach(i => { const o = ee(i, ['mdia', 'minf', 'stbl', 'stsd'])[0].subarray(8); let a = ee(o, ['enca']); const l = a.length > 0; l || (a = ee(o, ['encv'])), a.forEach(u => { const c = l ? u.subarray(28) : u.subarray(78); ee(c, ['sinf']).forEach(h => { const f = cv(h); if (f) { const p = f.subarray(8, 24); p.some(m => m !== 0) || (C.log(`[eme] Patching keyId in 'enc${l ? 'a' : 'v'}>sinf>>tenc' box: ${tn.hexDump(p)} -> ${tn.hexDump(t)}`), f.set(t, 8)) } }) }) }), n } function cv (n) { const e = ee(n, ['schm'])[0]; if (e) { const t = Pe(e.subarray(4, 8)); if (t === 'cbcs' || t === 'cenc') return ee(n, ['schi', 'tenc'])[0] } return C.error("[eme] missing 'schm' box"), null } function ZA (n, e) { return ee(e, ['moof', 'traf']).reduce((t, r) => { const i = ee(r, ['tfdt'])[0]; const s = i[0]; const o = ee(r, ['tfhd']).reduce((a, l) => { const u = Q(l, 4); const c = n[u]; if (c) { let d = Q(i, 4); if (s === 1) { if (d === qa) return C.warn('[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time'), a; d *= qa + 1, d += Q(i, 8) } const h = c.timescale || 9e4; const f = d / h; if (K(f) && (a === null || f < a)) return f } return a }, null); return o !== null && K(o) && (t === null || o < t) ? o : t }, null) } function ew (n, e) { let t = 0; let r = 0; let i = 0; const s = ee(n, ['moof', 'traf']); for (let o = 0; o < s.length; o++) { const a = s[o]; const l = ee(a, ['tfhd'])[0]; const u = Q(l, 4); const c = e[u]; if (!c) continue; const d = c.default; const h = Q(l, 0) | (d == null ? void 0 : d.flags); let f = d == null ? void 0 : d.duration; h & 8 && (h & 2 ? f = Q(l, 12) : f = Q(l, 8)); const p = c.timescale || 9e4; const m = ee(a, ['trun']); for (let y = 0; y < m.length; y++) { if (t = tw(m[y]), !t && f) { const g = Q(m[y], 4); t = f * g }c.type === ae.VIDEO ? r += t / p : c.type === ae.AUDIO && (i += t / p) } } if (r === 0 && i === 0) { let o = 1 / 0; let a = 0; let l = 0; const u = ee(n, ['sidx']); for (let c = 0; c < u.length; c++) { const d = QA(u[c]); if (d != null && d.references) { o = Math.min(o, d.earliestPresentationTime / d.timescale); const h = d.references.reduce((f, p) => f + p.info.duration || 0, 0); a = Math.max(a, h + d.earliestPresentationTime / d.timescale), l = a - o } } if (l && K(l)) return l } return r || i } function tw (n) { const e = Q(n, 0); let t = 8; e & 1 && (t += 4), e & 4 && (t += 4); let r = 0; const i = Q(n, 4); for (let s = 0; s < i; s++) { if (e & 256) { const o = Q(n, t); r += o, t += 4 }e & 512 && (t += 4), e & 1024 && (t += 4), e & 2048 && (t += 4) } return r } function nw (n, e, t) { ee(e, ['moof', 'traf']).forEach(r => { ee(r, ['tfhd']).forEach(i => { const s = Q(i, 4); const o = n[s]; if (!o) return; const a = o.timescale || 9e4; ee(r, ['tfdt']).forEach(l => { const u = l[0]; const c = t * a; if (c) { let d = Q(l, 4); if (u === 0)d -= c, d = Math.max(d, 0), mu(l, 4, d); else { d *= Math.pow(2, 32), d += Q(l, 8), d -= c, d = Math.max(d, 0); const h = Math.floor(d / (qa + 1)); const f = Math.floor(d % (qa + 1)); mu(l, 4, h), mu(l, 8, f) } } }) }) }) } function rw (n) { const e = { valid: null, remainder: null }; const t = ee(n, ['moof']); if (t.length < 2) return e.remainder = n, e; const r = t[t.length - 1]; return e.valid = br(n, 0, r.byteOffset - 8), e.remainder = br(n, r.byteOffset - 8), e } function $t (n, e) { const t = new Uint8Array(n.length + e.length); return t.set(n), t.set(e, n.length), t } function Sp (n, e) { const t = []; const r = e.samples; const i = e.timescale; const s = e.id; let o = !1; return ee(r, ['moof']).map(l => { const u = l.byteOffset - 8; ee(l, ['traf']).map(d => { const h = ee(d, ['tfdt']).map(f => { const p = f[0]; let m = Q(f, 4); return p === 1 && (m *= Math.pow(2, 32), m += Q(f, 8)), m / i })[0]; return h !== void 0 && (n = h), ee(d, ['tfhd']).map(f => { const p = Q(f, 4); const m = Q(f, 0) & 16777215; const y = (m & 1) !== 0; const g = (m & 2) !== 0; const v = (m & 8) !== 0; let E = 0; const x = (m & 16) !== 0; let T = 0; const w = (m & 32) !== 0; let L = 8; p === s && (y && (L += 8), g && (L += 4), v && (E = Q(f, L), L += 4), x && (T = Q(f, L), L += 4), w && (L += 4), e.type === 'video' && (o = iw(e.codec)), ee(d, ['trun']).map(A => { const P = A[0]; const _ = Q(A, 0) & 16777215; const F = (_ & 1) !== 0; let $ = 0; const G = (_ & 4) !== 0; const W = (_ & 256) !== 0; let Z = 0; const Y = (_ & 512) !== 0; let re = 0; const N = (_ & 1024) !== 0; const M = (_ & 2048) !== 0; let b = 0; const q = Q(A, 4); let z = 8; F && ($ = Q(A, z), z += 4), G && (z += 4); let ie = $ + u; for (let ue = 0; ue < q; ue++) { if (W ? (Z = Q(A, z), z += 4) : Z = E, Y ? (re = Q(A, z), z += 4) : re = T, N && (z += 4), M && (P === 0 ? b = Q(A, z) : b = lv(A, z), z += 4), e.type === ae.VIDEO) { let xe = 0; for (;xe < re;) { const fe = Q(r, ie); if (ie += 4, sw(o, r[ie])) { const Ge = r.subarray(ie, ie + fe); dv(Ge, o ? 2 : 1, n + b / i, t) }ie += fe, xe += fe + 4 } }n += Z / i } })) }) }) }), t } function iw (n) { if (!n) return !1; const e = n.indexOf('.'); const t = e < 0 ? n : n.substring(0, e); return t === 'hvc1' || t === 'hev1' || t === 'dvh1' || t === 'dvhe' } function sw (n, e) { if (n) { const t = e >> 1 & 63; return t === 39 || t === 40 } else return (e & 31) === 6 } function dv (n, e, t, r) { const i = hv(n); let s = 0; s += e; let o = 0; let a = 0; let l = 0; for (;s < i.length;) { o = 0; do { if (s >= i.length) break; l = i[s++], o += l } while (l === 255); a = 0; do { if (s >= i.length) break; l = i[s++], a += l } while (l === 255); const u = i.length - s; let c = s; if (a < u)s += a; else if (a > u) { C.error(`Malformed SEI payload. ${a} is too small, only ${u} bytes left to parse.`); break } if (o === 4) { if (i[c++] === 181) { const h = av(i, c); if (c += 2, h === 49) { const f = Q(i, c); if (c += 4, f === 1195456820) { const p = i[c++]; if (p === 3) { const m = i[c++]; const y = 31 & m; const g = 64 & m; const v = g ? 2 + y * 3 : 0; const E = new Uint8Array(v); if (g) { E[0] = m; for (let x = 1; x < v; x++)E[x] = i[c++] }r.push({ type: p, payloadType: o, pts: t, bytes: E }) } } } } } else if (o === 5 && a > 16) { const d = []; for (let p = 0; p < 16; p++) { const m = i[c++].toString(16); d.push(m.length == 1 ? '0' + m : m), (p === 3 || p === 5 || p === 7 || p === 9) && d.push('-') } const h = a - 16; const f = new Uint8Array(h); for (let p = 0; p < h; p++)f[p] = i[c++]; r.push({ payloadType: o, pts: t, uuid: d.join(''), userData: fn(f), userDataBytes: f }) } } } function hv (n) { const e = n.byteLength; const t = []; let r = 1; for (;r < e - 2;)n[r] === 0 && n[r + 1] === 0 && n[r + 2] === 3 ? (t.push(r + 2), r += 2) : r++; if (t.length === 0) return n; const i = e - t.length; const s = new Uint8Array(i); let o = 0; for (r = 0; r < i; o++, r++)o === t[0] && (o++, t.shift()), s[r] = n[o]; return s } function ow (n) { const e = n[0]; let t = ''; let r = ''; let i = 0; let s = 0; let o = 0; let a = 0; let l = 0; let u = 0; if (e === 0) { for (;Pe(n.subarray(u, u + 1)) !== '\0';)t += Pe(n.subarray(u, u + 1)), u += 1; for (t += Pe(n.subarray(u, u + 1)), u += 1; Pe(n.subarray(u, u + 1)) !== '\0';)r += Pe(n.subarray(u, u + 1)), u += 1; r += Pe(n.subarray(u, u + 1)), u += 1, i = Q(n, 12), s = Q(n, 16), a = Q(n, 20), l = Q(n, 24), u = 28 } else if (e === 1) { u += 4, i = Q(n, u), u += 4; const d = Q(n, u); u += 4; const h = Q(n, u); for (u += 4, o = 2 ** 32 * d + h, LA(o) || (o = Number.MAX_SAFE_INTEGER, C.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box')), a = Q(n, u), u += 4, l = Q(n, u), u += 4; Pe(n.subarray(u, u + 1)) !== '\0';)t += Pe(n.subarray(u, u + 1)), u += 1; for (t += Pe(n.subarray(u, u + 1)), u += 1; Pe(n.subarray(u, u + 1)) !== '\0';)r += Pe(n.subarray(u, u + 1)), u += 1; r += Pe(n.subarray(u, u + 1)), u += 1 } const c = n.subarray(u, n.byteLength); return { schemeIdUri: t, value: r, timeScale: i, presentationTime: o, presentationTimeDelta: s, eventDuration: a, id: l, payload: c } } function aw (n, ...e) { const t = e.length; let r = 8; let i = t; for (;i--;)r += e[i].byteLength; const s = new Uint8Array(r); for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = r & 255, s.set(n, 4), i = 0, r = 8; i < t; i++)s.set(e[i], r), r += e[i].byteLength; return s } function lw (n, e, t) { if (n.byteLength !== 16) throw new RangeError('Invalid system id'); let r, i; r = 0, i = new Uint8Array(); let s; r > 0 ? (s = new Uint8Array(4), e.length > 0 && new DataView(s.buffer).setUint32(0, e.length, !1)) : s = new Uint8Array(); const o = new Uint8Array(4); return t && t.byteLength > 0 && new DataView(o.buffer).setUint32(0, t.byteLength, !1), aw([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), n, s, i, o, t || new Uint8Array()) } function uw (n) { if (!(n instanceof ArrayBuffer) || n.byteLength < 32) return null; const e = { version: 0, systemId: '', kids: null, data: null }; const t = new DataView(n); const r = t.getUint32(0); if (n.byteLength !== r && r > 44 || t.getUint32(4) !== 1886614376 || (e.version = t.getUint32(8) >>> 24, e.version > 1)) return null; e.systemId = tn.hexDump(new Uint8Array(n, 12, 16)); const s = t.getUint32(28); if (e.version === 0) { if (r - 32 < s) return null; e.data = new Uint8Array(n, 32, s) } else if (e.version === 1) { e.kids = []; for (let o = 0; o < s; o++)e.kids.push(new Uint8Array(n, 32 + o * 16, 16)) } return e } let Ho = {}; class eo {static clearKeyUriToKeyIdMap () { Ho = {} }constructor (e, t, r, i = [1], s = null) { this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = i, this.iv = s, this.encrypted = e ? e !== 'NONE' : !1, this.isCommonEncryption = this.encrypted && e !== 'AES-128' }isSupported () { if (this.method) { if (this.method === 'AES-128' || this.method === 'NONE') return !0; if (this.keyFormat === 'identity') return this.method === 'SAMPLE-AES'; switch (this.keyFormat) { case gt.FAIRPLAY:case gt.WIDEVINE:case gt.PLAYREADY:case gt.CLEARKEY:return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1 } } return !1 }getDecryptData (e) { if (!this.encrypted || !this.uri) return null; if (this.method === 'AES-128' && this.uri && !this.iv) { typeof e !== 'number' && (this.method === 'AES-128' && !this.iv && C.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0); const r = cw(e); return new eo(this.method, this.uri, 'identity', this.keyFormatVersions, r) } const t = MA(this.uri); if (t) switch (this.keyFormat) { case gt.WIDEVINE:this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6)); break; case gt.PLAYREADY:{ const r = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]); this.pssh = lw(r, null, t); const i = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2); const s = String.fromCharCode.apply(null, Array.from(i)); const o = s.substring(s.indexOf('<'), s.length); const u = new DOMParser().parseFromString(o, 'text/xml').getElementsByTagName('KID')[0]; if (u) { const c = u.childNodes[0] ? u.childNodes[0].nodeValue : u.getAttribute('VALUE'); if (c) { const d = Sh(c).subarray(0, 16); FA(d), this.keyId = d } } break } default:{ let r = t.subarray(0, 16); if (r.length !== 16) { const i = new Uint8Array(16); i.set(r, 16 - r.length), r = i } this.keyId = r; break } } if (!this.keyId || this.keyId.byteLength !== 16) { let r = Ho[this.uri]; if (!r) { const i = Object.keys(Ho).length % Number.MAX_SAFE_INTEGER; r = new Uint8Array(16), new DataView(r.buffer, 12, 4).setUint32(0, i), Ho[this.uri] = r } this.keyId = r } return this }} function cw (n) { const e = new Uint8Array(16); for (let t = 12; t < 16; t++)e[t] = n >> 8 * (15 - t) & 255; return e } const fv = /\{\$([a-zA-Z0-9-_]+)\}/g; function Tp (n) { return fv.test(n) } function dt (n, e, t) { if (n.variableList !== null || n.hasVariableRefs) for (let r = t.length; r--;) { const i = t[r]; const s = e[i]; s && (e[i] = Yc(n, s)) } } function Yc (n, e) { if (n.variableList !== null || n.hasVariableRefs) { const t = n.variableList; return e.replace(fv, r => { const i = r.substring(2, r.length - 1); const s = t == null ? void 0 : t[i]; return s === void 0 ? (n.playlistParsingError || (n.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${i}"`)), r) : s }) } return e } function xp (n, e, t) { let r = n.variableList; r || (n.variableList = r = {}); let i, s; if ('QUERYPARAM' in e) { i = e.QUERYPARAM; try { const o = new self.URL(t).searchParams; if (o.has(i))s = o.get(i); else throw new Error(`"${i}" does not match any query parameter in URI: "${t}"`) } catch (o) { n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${o.message}`)) } } else i = e.NAME, s = e.VALUE; i in r ? n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${i}"`)) : r[i] = s || '' } function dw (n, e, t) { const r = e.IMPORT; if (t && r in t) { let i = n.variableList; i || (n.variableList = i = {}), i[r] = t[r] } else n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`)) } function $r (n = !0) { return typeof self > 'u' ? void 0 : (n || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource } function hw (n) { return typeof self < 'u' && n === self.ManagedMediaSource } const Qa = { audio: { a3ds: 1, 'ac-3': 0.95, 'ac-4': 1, alac: 0.9, alaw: 1, dra1: 1, 'dts+': 1, 'dts-': 1, dtsc: 1, dtse: 1, dtsh: 1, 'ec-3': 0.9, enca: 1, fLaC: 0.9, flac: 0.9, FLAC: 0.9, g719: 1, g726: 1, m4ae: 1, mha1: 1, mha2: 1, mhm1: 1, mhm2: 1, mlpa: 1, mp4a: 1, 'raw ': 1, Opus: 1, opus: 1, samr: 1, sawb: 1, sawp: 1, sevc: 1, sqcp: 1, ssmv: 1, twos: 1, ulaw: 1 }, video: { avc1: 1, avc2: 1, avc3: 1, avc4: 1, avcp: 1, av01: 0.8, drac: 1, dva1: 1, dvav: 1, dvh1: 0.7, dvhe: 0.7, encv: 1, hev1: 0.75, hvc1: 0.75, mjp2: 1, mp4v: 1, mvc1: 1, mvc2: 1, mvc3: 1, mvc4: 1, resv: 1, rv60: 1, s263: 1, svc1: 1, svc2: 1, 'vc-1': 1, vp08: 1, vp09: 0.9 }, text: { stpp: 1, wvtt: 1 } }; function fw (n, e) { const t = Qa[e]; return !!t && !!t[n.slice(0, 4)] } function yu (n, e, t = !0) { return !n.split(',').some(r => !pv(r, e, t)) } function pv (n, e, t = !0) { let r; const i = $r(t); return (r = i == null ? void 0 : i.isTypeSupported(to(n, e))) != null ? r : !1 } function to (n, e) { return `${e}/mp4;codecs="${n}"` } function Lp (n) { if (n) { const e = n.substring(0, 4); return Qa.video[e] } return 2 } function Xa (n) { return n.split(',').reduce((e, t) => { const r = Qa.video[t]; return r ? (r * 2 + e) / (e ? 3 : 2) : (Qa.audio[t] + e) / (e ? 2 : 1) }, 0) } const vu = {}; function pw (n, e = !0) { if (vu[n]) return vu[n]; const t = { flac: ['flac', 'fLaC', 'FLAC'], opus: ['opus', 'Opus'] }[n]; for (let r = 0; r < t.length; r++) if (pv(t[r], 'audio', e)) return vu[n] = t[r], t[r]; return n } const mw = /flac|opus/i; function Ja (n, e = !0) { return n.replace(mw, t => pw(t.toLowerCase(), e)) } function Rp (n, e) { return n && n !== 'mp4a' ? n : e && e.split(',')[0] } function gw (n) { const e = n.split('.'); if (e.length > 2) { let t = e.shift() + '.'; return t += parseInt(e.shift()).toString(16), t += ('000' + parseInt(e.shift()).toString(16)).slice(-4), t } return n } const Ap = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g; const wp = /#EXT-X-MEDIA:(.*)/g; const yw = /^#EXT(?:INF|-X-TARGETDURATION):/m; const Cp = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join('|'), 'g'); const vw = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join('|')); class un {static findGroup (e, t) { for (let r = 0; r < e.length; r++) { const i = e[r]; if (i.id === t) return i } } static resolve (e, t) { return Eh.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) } static isMediaPlaylist (e) { return yw.test(e) } static parseMasterPlaylist (e, t) { const r = Tp(e); const i = { contentSteering: null, levels: [], playlistParsingError: null, sessionData: null, sessionKeys: null, startTimeOffset: null, variableList: null, hasVariableRefs: r }; const s = []; Ap.lastIndex = 0; let o; for (;(o = Ap.exec(e)) != null;) if (o[1]) { var a; const u = new ve(o[1]); dt(i, u, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']); const c = Yc(i, o[2]); const d = { attrs: u, bitrate: u.decimalInteger('BANDWIDTH') || u.decimalInteger('AVERAGE-BANDWIDTH'), name: u.NAME, url: un.resolve(c, t) }; const h = u.decimalResolution('RESOLUTION'); h && (d.width = h.width, d.height = h.height), Ew(u.CODECS, d), (a = d.unknownCodecs) != null && a.length || s.push(d), i.levels.push(d) } else if (o[3]) { const u = o[3]; const c = o[4]; switch (u) { case 'SESSION-DATA':{ const d = new ve(c); dt(i, d, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']); const h = d['DATA-ID']; h && (i.sessionData === null && (i.sessionData = {}), i.sessionData[h] = d); break } case 'SESSION-KEY':{ const d = Ip(c, t, i); d.encrypted && d.isSupported() ? (i.sessionKeys === null && (i.sessionKeys = []), i.sessionKeys.push(d)) : C.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${c}"`); break } case 'DEFINE':{ { const d = new ve(c); dt(i, d, ['NAME', 'VALUE', 'QUERYPARAM']), xp(i, d, t) } break } case 'CONTENT-STEERING':{ const d = new ve(c); dt(i, d, ['SERVER-URI', 'PATHWAY-ID']), i.contentSteering = { uri: un.resolve(d['SERVER-URI'], t), pathwayId: d['PATHWAY-ID'] || '.' }; break } case 'START':{ i.startTimeOffset = _p(c); break } } } const l = s.length > 0 && s.length < i.levels.length; return i.levels = l ? s : i.levels, i.levels.length === 0 && (i.playlistParsingError = new Error('no levels found in manifest')), i } static parseMasterPlaylistMedia (e, t, r) { let i; const s = {}; const o = r.levels; const a = { AUDIO: o.map(u => ({ id: u.attrs.AUDIO, audioCodec: u.audioCodec })), SUBTITLES: o.map(u => ({ id: u.attrs.SUBTITLES, textCodec: u.textCodec })), 'CLOSED-CAPTIONS': [] }; let l = 0; for (wp.lastIndex = 0; (i = wp.exec(e)) !== null;) { const u = new ve(i[1]); const c = u.TYPE; if (c) { const d = a[c]; const h = s[c] || []; s[c] = h, dt(r, u, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']); const f = u.LANGUAGE; const p = u['ASSOC-LANGUAGE']; const m = u.CHANNELS; const y = u.CHARACTERISTICS; const g = u['INSTREAM-ID']; const v = { attrs: u, bitrate: 0, id: l++, groupId: u['GROUP-ID'] || '', name: u.NAME || f || '', type: c, default: u.bool('DEFAULT'), autoselect: u.bool('AUTOSELECT'), forced: u.bool('FORCED'), lang: f, url: u.URI ? un.resolve(u.URI, t) : '' }; if (p && (v.assocLang = p), m && (v.channels = m), y && (v.characteristics = y), g && (v.instreamId = g), d != null && d.length) { const E = un.findGroup(d, v.groupId) || d[0]; Dp(v, E, 'audioCodec'), Dp(v, E, 'textCodec') }h.push(v) } } return s } static parseLevelPlaylist (e, t, r, i, s, o) { const a = new bA(t); const l = a.fragments; let u = null; let c = 0; let d = 0; let h = 0; let f = 0; let p = null; let m = new hu(i, t); let y; let g; let v; let E = -1; let x = !1; let T = null; for (Cp.lastIndex = 0, a.m3u8 = e, a.hasVariableRefs = Tp(e); (y = Cp.exec(e)) !== null;) { x && (x = !1, m = new hu(i, t), m.start = h, m.sn = c, m.cc = f, m.level = r, u && (m.initSegment = u, m.rawProgramDateTime = u.rawProgramDateTime, u.rawProgramDateTime = null, T && (m.setByteRange(T), T = null))); const P = y[1]; if (P) { m.duration = parseFloat(P); const _ = (' ' + y[2]).slice(1); m.title = _ || null, m.tagList.push(_ ? ['INF', P, _] : ['INF', P]) } else if (y[3]) { if (K(m.duration)) { m.start = h, v && bp(m, v, a), m.sn = c, m.level = r, m.cc = f, l.push(m); const _ = (' ' + y[3]).slice(1); m.relurl = Yc(a, _), kp(m, p), p = m, h += m.duration, c++, d = 0, x = !0 } } else if (y[4]) { const _ = (' ' + y[4]).slice(1); p ? m.setByteRange(_, p) : m.setByteRange(_) } else if (y[5])m.rawProgramDateTime = (' ' + y[5]).slice(1), m.tagList.push(['PROGRAM-DATE-TIME', m.rawProgramDateTime]), E === -1 && (E = l.length); else { if (y = y[0].match(vw), !y) { C.warn('No matches on slow regex match for level playlist!'); continue } for (g = 1; g < y.length && !(typeof y[g] < 'u'); g++);const _ = (' ' + y[g]).slice(1); const F = (' ' + y[g + 1]).slice(1); const $ = y[g + 2] ? (' ' + y[g + 2]).slice(1) : ''; switch (_) { case 'PLAYLIST-TYPE':a.type = F.toUpperCase(); break; case 'MEDIA-SEQUENCE':c = a.startSN = parseInt(F); break; case 'SKIP':{ const G = new ve(F); dt(a, G, ['RECENTLY-REMOVED-DATERANGES']); const W = G.decimalInteger('SKIPPED-SEGMENTS'); if (K(W)) { a.skippedSegments = W; for (let Y = W; Y--;)l.unshift(null); c += W } const Z = G.enumeratedString('RECENTLY-REMOVED-DATERANGES'); Z && (a.recentlyRemovedDateranges = Z.split('	')); break } case 'TARGETDURATION':a.targetduration = Math.max(parseInt(F), 1); break; case 'VERSION':a.version = parseInt(F); break; case 'INDEPENDENT-SEGMENTS':case 'EXTM3U':break; case 'ENDLIST':a.live = !1; break; case '#':(F || $) && m.tagList.push($ ? [F, $] : [F]); break; case 'DISCONTINUITY':f++, m.tagList.push(['DIS']); break; case 'GAP':m.gap = !0, m.tagList.push([_]); break; case 'BITRATE':m.tagList.push([_, F]); break; case 'DATERANGE':{ const G = new ve(F); dt(a, G, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']), dt(a, G, G.clientAttrs); const W = new Zy(G, a.dateRanges[G.ID]); W.isValid || a.skippedSegments ? a.dateRanges[W.id] = W : C.warn(`Ignoring invalid DATERANGE tag: "${F}"`), m.tagList.push(['EXT-X-DATERANGE', F]); break } case 'DEFINE':{ { const G = new ve(F); dt(a, G, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']), 'IMPORT' in G ? dw(a, G, o) : xp(a, G, t) } break } case 'DISCONTINUITY-SEQUENCE':f = parseInt(F); break; case 'KEY':{ const G = Ip(F, t, a); if (G.isSupported()) { if (G.method === 'NONE') { v = void 0; break }v || (v = {}), v[G.keyFormat] && (v = De({}, v)), v[G.keyFormat] = G } else C.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${F}"`); break } case 'START':a.startTimeOffset = _p(F); break; case 'MAP':{ const G = new ve(F); if (dt(a, G, ['BYTERANGE', 'URI']), m.duration) { const W = new hu(i, t); Pp(W, G, r, v), u = W, m.initSegment = u, u.rawProgramDateTime && !m.rawProgramDateTime && (m.rawProgramDateTime = u.rawProgramDateTime) } else { const W = m.byteRangeEndOffset; if (W) { const Z = m.byteRangeStartOffset; T = `${W - Z}@${Z}` } else T = null; Pp(m, G, r, v), u = m, x = !0 } break } case 'SERVER-CONTROL':{ const G = new ve(F); a.canBlockReload = G.bool('CAN-BLOCK-RELOAD'), a.canSkipUntil = G.optionalFloat('CAN-SKIP-UNTIL', 0), a.canSkipDateRanges = a.canSkipUntil > 0 && G.bool('CAN-SKIP-DATERANGES'), a.partHoldBack = G.optionalFloat('PART-HOLD-BACK', 0), a.holdBack = G.optionalFloat('HOLD-BACK', 0); break } case 'PART-INF':{ const G = new ve(F); a.partTarget = G.decimalFloatingPoint('PART-TARGET'); break } case 'PART':{ let G = a.partList; G || (G = a.partList = []); const W = d > 0 ? G[G.length - 1] : void 0; const Z = d++; const Y = new ve(F); dt(a, Y, ['BYTERANGE', 'URI']); const re = new kA(Y, m, t, Z, W); G.push(re), m.duration += re.duration; break } case 'PRELOAD-HINT':{ const G = new ve(F); dt(a, G, ['URI']), a.preloadHint = G; break } case 'RENDITION-REPORT':{ const G = new ve(F); dt(a, G, ['URI']), a.renditionReports = a.renditionReports || [], a.renditionReports.push(G); break } default:C.warn(`line parsed but not handled: ${y}`); break } } }p && !p.relurl ? (l.pop(), h -= p.duration, a.partList && (a.fragmentHint = p)) : a.partList && (kp(m, p), m.cc = f, a.fragmentHint = m, v && bp(m, v, a)); const w = l.length; const L = l[0]; const A = l[w - 1]; if (h += a.skippedSegments * a.targetduration, h > 0 && w && A) { a.averagetargetduration = h / w; const P = A.sn; a.endSN = P !== 'initSegment' ? P : 0, a.live || (A.endList = !0), L && (a.startCC = L.cc) } else a.endSN = 0, a.startCC = 0; return a.fragmentHint && (h += a.fragmentHint.duration), a.totalduration = h, a.endCC = f, E > 0 && Sw(l, E), a }} function Ip (n, e, t) { let r, i; const s = new ve(n); dt(t, s, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']); const o = (r = s.METHOD) != null ? r : ''; const a = s.URI; const l = s.hexadecimalInteger('IV'); const u = s.KEYFORMATVERSIONS; const c = (i = s.KEYFORMAT) != null ? i : 'identity'; a && s.IV && !l && C.error(`Invalid IV: ${s.IV}`); const d = a ? un.resolve(a, e) : ''; const h = (u || '1').split('/').map(Number).filter(Number.isFinite); return new eo(o, d, c, h, l) } function _p (n) { const t = new ve(n).decimalFloatingPoint('TIME-OFFSET'); return K(t) ? t : null } function Ew (n, e) { let t = (n || '').split(/[ ,]+/).filter(r => r); ['video', 'audio', 'text'].forEach(r => { const i = t.filter(s => fw(s, r)); i.length && (e[`${r}Codec`] = i.join(','), t = t.filter(s => i.indexOf(s) === -1)) }), e.unknownCodecs = t } function Dp (n, e, t) { const r = e[t]; r && (n[t] = r) } function Sw (n, e) { let t = n[e]; for (let r = e; r--;) { const i = n[r]; if (!i) return; i.programDateTime = t.programDateTime - i.duration * 1e3, t = i } } function kp (n, e) { n.rawProgramDateTime ? n.programDateTime = Date.parse(n.rawProgramDateTime) : e != null && e.programDateTime && (n.programDateTime = e.endProgramDateTime), K(n.programDateTime) || (n.programDateTime = null, n.rawProgramDateTime = null) } function Pp (n, e, t, r) { n.relurl = e.URI, e.BYTERANGE && n.setByteRange(e.BYTERANGE), n.level = t, n.sn = 'initSegment', r && (n.levelkeys = r), n.initSegment = null } function bp (n, e, t) { n.levelkeys = e; const { encryptedFragments: r } = t; (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some(i => e[i].isCommonEncryption) && r.push(n) } const se = { MANIFEST: 'manifest', LEVEL: 'level', AUDIO_TRACK: 'audioTrack', SUBTITLE_TRACK: 'subtitleTrack' }; const X = { MAIN: 'main', AUDIO: 'audio', SUBTITLE: 'subtitle' }; function Op (n) { const { type: e } = n; switch (e) { case se.AUDIO_TRACK:return X.AUDIO; case se.SUBTITLE_TRACK:return X.SUBTITLE; default:return X.MAIN } } function Eu (n, e) { let t = n.url; return (t === void 0 || t.indexOf('data:') === 0) && (t = e.url), t } class Tw {constructor (e) { this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners() }startLoad (e) {}stopLoad () { this.destroyInternalLoaders() }registerListeners () { const { hls: e } = this; e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.LEVEL_LOADING, this.onLevelLoading, this), e.on(S.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(S.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) }unregisterListeners () { const { hls: e } = this; e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.LEVEL_LOADING, this.onLevelLoading, this), e.off(S.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(S.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) }createInternalLoader (e) { const t = this.hls.config; const r = t.pLoader; const i = t.loader; const s = r || i; const o = new s(t); return this.loaders[e.type] = o, o }getInternalLoader (e) { return this.loaders[e.type] }resetInternalLoader (e) { this.loaders[e] && delete this.loaders[e] }destroyInternalLoaders () { for (const e in this.loaders) { const t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } }destroy () { this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders() }onManifestLoading (e, t) { const { url: r } = t; this.variableList = null, this.load({ id: null, level: 0, responseType: 'text', type: se.MANIFEST, url: r, deliveryDirectives: null }) }onLevelLoading (e, t) { const { id: r, level: i, pathwayId: s, url: o, deliveryDirectives: a } = t; this.load({ id: r, level: i, pathwayId: s, responseType: 'text', type: se.LEVEL, url: o, deliveryDirectives: a }) }onAudioTrackLoading (e, t) { const { id: r, groupId: i, url: s, deliveryDirectives: o } = t; this.load({ id: r, groupId: i, level: null, responseType: 'text', type: se.AUDIO_TRACK, url: s, deliveryDirectives: o }) }onSubtitleTrackLoading (e, t) { const { id: r, groupId: i, url: s, deliveryDirectives: o } = t; this.load({ id: r, groupId: i, level: null, responseType: 'text', type: se.SUBTITLE_TRACK, url: s, deliveryDirectives: o }) }load (e) { let t; const r = this.hls.config; let i = this.getInternalLoader(e); if (i) { const u = i.context; if (u && u.url === e.url && u.level === e.level) { C.trace('[playlist-loader]: playlist request ongoing'); return }C.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort() } let s; if (e.type === se.MANIFEST ? s = r.manifestLoadPolicy.default : s = De({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null }), i = this.createInternalLoader(e), K((t = e.deliveryDirectives) == null ? void 0 : t.part)) { let u; if (e.type === se.LEVEL && e.level !== null ? u = this.hls.levels[e.level].details : e.type === se.AUDIO_TRACK && e.id !== null ? u = this.hls.audioTracks[e.id].details : e.type === se.SUBTITLE_TRACK && e.id !== null && (u = this.hls.subtitleTracks[e.id].details), u) { const c = u.partTarget; const d = u.targetduration; if (c && d) { const h = Math.max(c * 3, d * 0.8) * 1e3; s = De({}, s, { maxTimeToFirstByteMs: Math.min(h, s.maxTimeToFirstByteMs), maxLoadTimeMs: Math.min(h, s.maxTimeToFirstByteMs) }) } } } const o = s.errorRetry || s.timeoutRetry || {}; const a = { loadPolicy: s, timeout: s.maxLoadTimeMs, maxRetry: o.maxNumRetry || 0, retryDelay: o.retryDelayMs || 0, maxRetryDelay: o.maxRetryDelayMs || 0 }; const l = { onSuccess: (u, c, d, h) => { const f = this.getInternalLoader(d); this.resetInternalLoader(d.type); const p = u.data; if (p.indexOf('#EXTM3U') !== 0) { this.handleManifestParsingError(u, d, new Error('no EXTM3U delimiter'), h || null, c); return }c.parsing.start = performance.now(), un.isMediaPlaylist(p) ? this.handleTrackOrLevelPlaylist(u, c, d, h || null, f) : this.handleMasterPlaylist(u, c, d, h) }, onError: (u, c, d, h) => { this.handleNetworkError(c, d, !1, u, h) }, onTimeout: (u, c, d) => { this.handleNetworkError(c, d, !0, void 0, u) } }; i.load(e, a, l) }handleMasterPlaylist (e, t, r, i) { const s = this.hls; const o = e.data; const a = Eu(e, r); const l = un.parseMasterPlaylist(o, a); if (l.playlistParsingError) { this.handleManifestParsingError(e, r, l.playlistParsingError, i, t); return } const { contentSteering: u, levels: c, sessionData: d, sessionKeys: h, startTimeOffset: f, variableList: p } = l; this.variableList = p; const { AUDIO: m = [], SUBTITLES: y, 'CLOSED-CAPTIONS': g } = un.parseMasterPlaylistMedia(o, a, l); m.length && !m.some(E => !E.url) && c[0].audioCodec && !c[0].attrs.AUDIO && (C.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one'), m.unshift({ type: 'main', name: 'main', groupId: 'main', default: !1, autoselect: !1, forced: !1, id: -1, attrs: new ve({}), bitrate: 0, url: '' })), s.trigger(S.MANIFEST_LOADED, { levels: c, audioTracks: m, subtitles: y, captions: g, contentSteering: u, url: a, stats: t, networkDetails: i, sessionData: d, sessionKeys: h, startTimeOffset: f, variableList: p }) }handleTrackOrLevelPlaylist (e, t, r, i, s) { const o = this.hls; const { id: a, level: l, type: u } = r; const c = Eu(e, r); const d = 0; const h = K(l) ? l : K(a) ? a : 0; const f = Op(r); const p = un.parseLevelPlaylist(e.data, c, h, f, d, this.variableList); if (u === se.MANIFEST) { const m = { attrs: new ve({}), bitrate: 0, details: p, name: '', url: c }; o.trigger(S.MANIFEST_LOADED, { levels: [m], audioTracks: [], url: c, stats: t, networkDetails: i, sessionData: null, sessionKeys: null, contentSteering: null, startTimeOffset: null, variableList: null }) }t.parsing.end = performance.now(), r.levelDetails = p, this.handlePlaylistLoaded(p, e, t, r, i, s) }handleManifestParsingError (e, t, r, i, s) { this.hls.trigger(S.ERROR, { type: J.NETWORK_ERROR, details: D.MANIFEST_PARSING_ERROR, fatal: t.type === se.MANIFEST, url: e.url, err: r, error: r, reason: r.message, response: e, context: t, networkDetails: i, stats: s }) }handleNetworkError (e, t, r = !1, i, s) { let o = `A network ${r ? 'timeout' : 'error' + (i ? ' (status ' + i.code + ')' : '')} occurred while loading ${e.type}`; e.type === se.LEVEL ? o += `: ${e.level} id: ${e.id}` : (e.type === se.AUDIO_TRACK || e.type === se.SUBTITLE_TRACK) && (o += ` id: ${e.id} group-id: "${e.groupId}"`); const a = new Error(o); C.warn(`[playlist-loader]: ${o}`); let l = D.UNKNOWN; let u = !1; const c = this.getInternalLoader(e); switch (e.type) { case se.MANIFEST:l = r ? D.MANIFEST_LOAD_TIMEOUT : D.MANIFEST_LOAD_ERROR, u = !0; break; case se.LEVEL:l = r ? D.LEVEL_LOAD_TIMEOUT : D.LEVEL_LOAD_ERROR, u = !1; break; case se.AUDIO_TRACK:l = r ? D.AUDIO_TRACK_LOAD_TIMEOUT : D.AUDIO_TRACK_LOAD_ERROR, u = !1; break; case se.SUBTITLE_TRACK:l = r ? D.SUBTITLE_TRACK_LOAD_TIMEOUT : D.SUBTITLE_LOAD_ERROR, u = !1; break }c && this.resetInternalLoader(e.type); const d = { type: J.NETWORK_ERROR, details: l, fatal: u, url: e.url, loader: c, context: e, error: a, networkDetails: t, stats: s }; if (i) { const h = (t == null ? void 0 : t.url) || e.url; d.response = $e({ url: h, data: void 0 }, i) } this.hls.trigger(S.ERROR, d) }handlePlaylistLoaded (e, t, r, i, s, o) { const a = this.hls; const { type: l, level: u, id: c, groupId: d, deliveryDirectives: h } = i; const f = Eu(t, i); const p = Op(i); const m = typeof i.level === 'number' && p === X.MAIN ? u : void 0; if (!e.fragments.length) { const g = new Error('No Segments found in Playlist'); a.trigger(S.ERROR, { type: J.NETWORK_ERROR, details: D.LEVEL_EMPTY_ERROR, fatal: !1, url: f, error: g, reason: g.message, response: t, context: i, level: m, parent: p, networkDetails: s, stats: r }); return }e.targetduration || (e.playlistParsingError = new Error('Missing Target Duration')); const y = e.playlistParsingError; if (y) { a.trigger(S.ERROR, { type: J.NETWORK_ERROR, details: D.LEVEL_PARSING_ERROR, fatal: !1, url: f, error: y, reason: y.message, response: t, context: i, level: m, parent: p, networkDetails: s, stats: r }); return } switch (e.live && o && (o.getCacheAge && (e.ageHeader = o.getCacheAge() || 0), (!o.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), l) { case se.MANIFEST:case se.LEVEL:a.trigger(S.LEVEL_LOADED, { details: e, level: m || 0, id: c || 0, stats: r, networkDetails: s, deliveryDirectives: h }); break; case se.AUDIO_TRACK:a.trigger(S.AUDIO_TRACK_LOADED, { details: e, id: c || 0, groupId: d || '', stats: r, networkDetails: s, deliveryDirectives: h }); break; case se.SUBTITLE_TRACK:a.trigger(S.SUBTITLE_TRACK_LOADED, { details: e, id: c || 0, groupId: d || '', stats: r, networkDetails: s, deliveryDirectives: h }); break } }} function mv (n, e) { let t; try { t = new Event('addtrack') } catch { t = document.createEvent('Event'), t.initEvent('addtrack', !1, !1) }t.track = n, e.dispatchEvent(t) } function gv (n, e) { const t = n.mode; if (t === 'disabled' && (n.mode = 'hidden'), n.cues && !n.cues.getCueById(e.id)) try { if (n.addCue(e), !n.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`) } catch (r) { C.debug(`[texttrack-utils]: ${r}`); try { const i = new self.TextTrackCue(e.startTime, e.endTime, e.text); i.id = e.id, n.addCue(i) } catch (i) { C.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${i}`) } }t === 'disabled' && (n.mode = t) } function pi (n) { const e = n.mode; if (e === 'disabled' && (n.mode = 'hidden'), n.cues) for (let t = n.cues.length; t--;)n.removeCue(n.cues[t]); e === 'disabled' && (n.mode = e) } function qc (n, e, t, r) { const i = n.mode; if (i === 'disabled' && (n.mode = 'hidden'), n.cues && n.cues.length > 0) { const s = Lw(n.cues, e, t); for (let o = 0; o < s.length; o++)(!r || r(s[o])) && n.removeCue(s[o]) }i === 'disabled' && (n.mode = i) } function xw (n, e) { if (e < n[0].startTime) return 0; const t = n.length - 1; if (e > n[t].endTime) return -1; let r = 0; let i = t; for (;r <= i;) { const s = Math.floor((i + r) / 2); if (e < n[s].startTime)i = s - 1; else if (e > n[s].startTime && r < t)r = s + 1; else return s } return n[r].startTime - e < e - n[i].startTime ? r : i } function Lw (n, e, t) { const r = []; const i = xw(n, e); if (i > -1) for (let s = i, o = n.length; s < o; s++) { const a = n[s]; if (a.startTime >= e && a.endTime <= t)r.push(a); else if (a.startTime > t) return r } return r } function fa (n) { const e = []; for (let t = 0; t < n.length; t++) { const r = n[t]; (r.kind === 'subtitles' || r.kind === 'captions') && r.label && e.push(n[t]) } return e } const Yt = { audioId3: 'org.id3', dateRange: 'com.apple.quicktime.HLS', emsg: 'https://aomedia.org/emsg/ID3' }; const Rw = 0.25; function Qc () { if (!(typeof self > 'u')) return self.VTTCue || self.TextTrackCue } function Fp (n, e, t, r, i) { let s = new n(e, t, ''); try { s.value = r, i && (s.type = i) } catch { s = new n(e, t, JSON.stringify(i ? $e({ type: i }, r) : r)) } return s } const Ko = (() => { const n = Qc(); try { n && new n(0, Number.POSITIVE_INFINITY, '') } catch { return Number.MAX_VALUE } return Number.POSITIVE_INFINITY })(); function Su (n, e) { return n.getTime() / 1e3 - e } function Aw (n) { return Uint8Array.from(n.replace(/^0x/, '').replace(/([\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer } class ww {constructor (e) { this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners() }destroy () { this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null }_registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this) }onMediaAttached (e, t) { this.media = t.media }onMediaDetaching () { this.id3Track && (pi(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}) }onManifestLoading () { this.dateRangeCuesAppended = {} }createTrack (e) { const t = this.getID3Track(e.textTracks); return t.mode = 'hidden', t }getID3Track (e) { if (this.media) { for (let t = 0; t < e.length; t++) { const r = e[t]; if (r.kind === 'metadata' && r.label === 'id3') return mv(r, this.media), r } return this.media.addTextTrack('metadata', 'id3') } }onFragParsingMetadata (e, t) { if (!this.media) return; const { hls: { config: { enableEmsgMetadataCues: r, enableID3MetadataCues: i } } } = this; if (!r && !i) return; const { samples: s } = t; this.id3Track || (this.id3Track = this.createTrack(this.media)); const o = Qc(); if (o) for (let a = 0; a < s.length; a++) { const l = s[a].type; if (l === Yt.emsg && !r || !i) continue; const u = sv(s[a].data); if (u) { const c = s[a].pts; let d = c + s[a].duration; d > Ko && (d = Ko), d - c <= 0 && (d = c + Rw); for (let f = 0; f < u.length; f++) { const p = u[f]; if (!iv(p)) { this.updateId3CueEnds(c, l); const m = Fp(o, c, d, p, l); m && this.id3Track.addCue(m) } } } } }updateId3CueEnds (e, t) { let r; const i = (r = this.id3Track) == null ? void 0 : r.cues; if (i) for (let s = i.length; s--;) { const o = i[s]; o.type === t && o.startTime < e && o.endTime === Ko && (o.endTime = e) } }onBufferFlushing (e, { startOffset: t, endOffset: r, type: i }) { const { id3Track: s, hls: o } = this; if (!o) return; const { config: { enableEmsgMetadataCues: a, enableID3MetadataCues: l } } = o; if (s && (a || l)) { let u; i === 'audio' ? u = c => c.type === Yt.audioId3 && l : i === 'video' ? u = c => c.type === Yt.emsg && a : u = c => c.type === Yt.audioId3 && l || c.type === Yt.emsg && a, qc(s, t, r, u) } }onLevelUpdated (e, { details: t }) { if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return; const { dateRangeCuesAppended: r, id3Track: i } = this; const { dateRanges: s } = t; const o = Object.keys(s); if (i) { const c = Object.keys(r).filter(d => !o.includes(d)); for (let d = c.length; d--;) { const h = c[d]; Object.keys(r[h].cues).forEach(f => { i.removeCue(r[h].cues[f]) }), delete r[h] } } const a = t.fragments[t.fragments.length - 1]; if (o.length === 0 || !K(a == null ? void 0 : a.programDateTime)) return; this.id3Track || (this.id3Track = this.createTrack(this.media)); const l = a.programDateTime / 1e3 - a.start; const u = Qc(); for (let c = 0; c < o.length; c++) { const d = o[c]; const h = s[d]; const f = Su(h.startDate, l); const p = r[d]; const m = (p == null ? void 0 : p.cues) || {}; let y = (p == null ? void 0 : p.durationKnown) || !1; let g = Ko; const v = h.endDate; if (v)g = Su(v, l), y = !0; else if (h.endOnNext && !y) { const x = o.reduce((T, w) => { if (w !== h.id) { const L = s[w]; if (L.class === h.class && L.startDate > h.startDate && (!T || h.startDate < T.startDate)) return L } return T }, null); x && (g = Su(x.startDate, l), y = !0) } const E = Object.keys(h.attr); for (let x = 0; x < E.length; x++) { const T = E[x]; if (!_A(T)) continue; const w = m[T]; if (w)y && !p.durationKnown && (w.endTime = g); else if (u) { let L = h.attr[T]; DA(T) && (L = Aw(L)); const A = Fp(u, f, g, { key: T, data: L }, Yt.dateRange); A && (A.id = d, this.id3Track.addCue(A), m[T] = A) } }r[d] = { cues: m, dateRange: h, durationKnown: y } } }} class Cw {constructor (e) { this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners() } get latency () { return this._latency || 0 } get maxLatency () { const { config: e, levelDetails: t } = this; return e.liveMaxLatencyDuration !== void 0 ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0 } get targetLatency () { const { levelDetails: e } = this; if (e === null) return null; const { holdBack: t, partHoldBack: r, targetduration: i } = e; const { liveSyncDuration: s, liveSyncDurationCount: o, lowLatencyMode: a } = this.config; const l = this.hls.userConfig; let u = a && r || t; (l.liveSyncDuration || l.liveSyncDurationCount || u === 0) && (u = s !== void 0 ? s : o * i); const c = i; return u + Math.min(this.stallCount * 1, c) } get liveSyncPosition () { const e = this.estimateLiveEdge(); const t = this.targetLatency; const r = this.levelDetails; if (e === null || t === null || r === null) return null; const i = r.edge; const s = e - t - this.edgeStalled; const o = i - r.totalduration; const a = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration); return Math.min(Math.max(o, s), a) } get drift () { const { levelDetails: e } = this; return e === null ? 1 : e.drift } get edgeStalled () { const { levelDetails: e } = this; if (e === null) return 0; const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3; return Math.max(e.age - t, 0) } get forwardBufferLength () { const { media: e, levelDetails: t } = this; if (!e || !t) return 0; const r = e.buffered.length; return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime }destroy () { this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null }registerListeners () { this.hls.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(S.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(S.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(S.ERROR, this.onError, this) }unregisterListeners () { this.hls.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(S.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(S.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(S.ERROR, this.onError, this) }onMediaAttached (e, t) { this.media = t.media, this.media.addEventListener('timeupdate', this.timeupdateHandler) }onMediaDetaching () { this.media && (this.media.removeEventListener('timeupdate', this.timeupdateHandler), this.media = null) }onManifestLoading () { this.levelDetails = null, this._latency = null, this.stallCount = 0 }onLevelUpdated (e, { details: t }) { this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener('timeupdate', this.timeupdateHandler) }onError (e, t) { let r; t.details === D.BUFFER_STALLED_ERROR && (this.stallCount++, (r = this.levelDetails) != null && r.live && C.warn('[playback-rate-controller]: Stall detected, adjusting target latency')) }timeupdate () { const { media: e, levelDetails: t } = this; if (!e || !t) return; this.currentTime = e.currentTime; const r = this.computeLatency(); if (r === null) return; this._latency = r; const { lowLatencyMode: i, maxLiveSyncPlaybackRate: s } = this.config; if (!i || s === 1 || !t.live) return; const o = this.targetLatency; if (o === null) return; const a = r - o; const l = Math.min(this.maxLatency, o + t.targetduration); if (a < l && a > 0.05 && this.forwardBufferLength > 1) { const c = Math.min(2, Math.max(1, s)); const d = Math.round(2 / (1 + Math.exp(-0.75 * a - this.edgeStalled)) * 20) / 20; e.playbackRate = Math.min(c, Math.max(1, d)) } else e.playbackRate !== 1 && e.playbackRate !== 0 && (e.playbackRate = 1) }estimateLiveEdge () { const { levelDetails: e } = this; return e === null ? null : e.edge + e.age }computeLatency () { const e = this.estimateLiveEdge(); return e === null ? null : e - this.currentTime }} const Xc = ['NONE', 'TYPE-0', 'TYPE-1', null]; function Iw (n) { return Xc.indexOf(n) > -1 } const Za = ['SDR', 'PQ', 'HLG']; function _w (n) { return !!n && Za.indexOf(n) > -1 } const pa = { No: '', Yes: 'YES', v2: 'v2' }; function Mp (n) { const { canSkipUntil: e, canSkipDateRanges: t, age: r } = n; const i = r < e / 2; return e && i ? t ? pa.v2 : pa.Yes : pa.No } class Np {constructor (e, t, r) { this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r }addDirectives (e) { const t = new self.URL(e); return this.msn !== void 0 && t.searchParams.set('_HLS_msn', this.msn.toString()), this.part !== void 0 && t.searchParams.set('_HLS_part', this.part.toString()), this.skip && t.searchParams.set('_HLS_skip', this.skip), t.href }} class Yi {constructor (e) { this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat('FRAME-RATE', 0), this._avgBitrate = e.attrs.decimalInteger('AVERAGE-BANDWIDTH'), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter(t => !!t).map(t => t.substring(0, 4)).join(','), this.addGroupId('audio', e.attrs.AUDIO), this.addGroupId('text', e.attrs.SUBTITLES) } get maxBitrate () { return Math.max(this.realBitrate, this.bitrate) } get averageBitrate () { return this._avgBitrate || this.realBitrate || this.bitrate } get attrs () { return this._attrs[0] } get codecs () { return this.attrs.CODECS || '' } get pathwayId () { return this.attrs['PATHWAY-ID'] || '.' } get videoRange () { return this.attrs['VIDEO-RANGE'] || 'SDR' } get score () { return this.attrs.optionalFloat('SCORE', 0) } get uri () { return this.url[0] || '' }hasAudioGroup (e) { return Up(this._audioGroups, e) }hasSubtitleGroup (e) { return Up(this._subtitleGroups, e) } get audioGroups () { return this._audioGroups } get subtitleGroups () { return this._subtitleGroups }addGroupId (e, t) { if (t) { if (e === 'audio') { let r = this._audioGroups; r || (r = this._audioGroups = []), r.indexOf(t) === -1 && r.push(t) } else if (e === 'text') { let r = this._subtitleGroups; r || (r = this._subtitleGroups = []), r.indexOf(t) === -1 && r.push(t) } } } get urlId () { return 0 } set urlId (e) {} get audioGroupIds () { return this.audioGroups ? [this.audioGroupId] : void 0 } get textGroupIds () { return this.subtitleGroups ? [this.textGroupId] : void 0 } get audioGroupId () { let e; return (e = this.audioGroups) == null ? void 0 : e[0] } get textGroupId () { let e; return (e = this.subtitleGroups) == null ? void 0 : e[0] }addFallback () {}} function Up (n, e) { return !e || !n ? !1 : n.indexOf(e) !== -1 } function Tu (n, e) { const t = e.startPTS; if (K(t)) { let r = 0; let i; e.sn > n.sn ? (r = t - n.start, i = n) : (r = n.start - t, i = e), i.duration !== r && (i.duration = r) } else e.sn > n.sn ? n.cc === e.cc && n.minEndPTS ? e.start = n.start + (n.minEndPTS - n.start) : e.start = n.start + n.duration : e.start = Math.max(n.start - e.duration, 0) } function yv (n, e, t, r, i, s) { r - t <= 0 && (C.warn('Fragment should have a positive duration', e), r = t + e.duration, s = i + e.duration); let a = t; let l = r; const u = e.startPTS; const c = e.endPTS; if (K(u)) { const y = Math.abs(u - t); K(e.deltaPTS) ? e.deltaPTS = Math.max(y, e.deltaPTS) : e.deltaPTS = y, a = Math.max(t, u), t = Math.min(t, u), i = Math.min(i, e.startDTS), l = Math.min(r, c), r = Math.max(r, c), s = Math.max(s, e.endDTS) } const d = t - e.start; e.start !== 0 && (e.start = t), e.duration = r - e.start, e.startPTS = t, e.maxStartPTS = a, e.startDTS = i, e.endPTS = r, e.minEndPTS = l, e.endDTS = s; const h = e.sn; if (!n || h < n.startSN || h > n.endSN) return 0; let f; const p = h - n.startSN; const m = n.fragments; for (m[p] = e, f = p; f > 0; f--)Tu(m[f], m[f - 1]); for (f = p; f < m.length - 1; f++)Tu(m[f], m[f + 1]); return n.fragmentHint && Tu(m[m.length - 1], n.fragmentHint), n.PTSKnown = n.alignedSliding = !0, d } function Dw (n, e) { let t = null; const r = n.fragments; for (let l = r.length - 1; l >= 0; l--) { const u = r[l].initSegment; if (u) { t = u; break } }n.fragmentHint && delete n.fragmentHint.endPTS; let i = 0; let s; if (bw(n, e, (l, u) => { l.relurl && (i = l.cc - u.cc), K(l.startPTS) && K(l.endPTS) && (u.start = u.startPTS = l.startPTS, u.startDTS = l.startDTS, u.maxStartPTS = l.maxStartPTS, u.endPTS = l.endPTS, u.endDTS = l.endDTS, u.minEndPTS = l.minEndPTS, u.duration = l.endPTS - l.startPTS, u.duration && (s = u), e.PTSKnown = e.alignedSliding = !0), u.elementaryStreams = l.elementaryStreams, u.loader = l.loader, u.stats = l.stats, l.initSegment && (u.initSegment = l.initSegment, t = l.initSegment) }), t && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach(u => { let c; u && (!u.initSegment || u.initSegment.relurl === ((c = t) == null ? void 0 : c.relurl)) && (u.initSegment = t) }), e.skippedSegments) if (e.deltaUpdateFailed = e.fragments.some(l => !l), e.deltaUpdateFailed) { C.warn('[level-helper] Previous playlist missing segments skipped in delta playlist'); for (let l = e.skippedSegments; l--;)e.fragments.shift(); e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc } else e.canSkipDateRanges && (e.dateRanges = kw(n.dateRanges, e.dateRanges, e.recentlyRemovedDateranges)); const o = e.fragments; if (i) { C.warn('discontinuity sliding from playlist, take drift into account'); for (let l = 0; l < o.length; l++)o[l].cc += i }e.skippedSegments && (e.startCC = e.fragments[0].cc), Pw(n.partList, e.partList, (l, u) => { u.elementaryStreams = l.elementaryStreams, u.stats = l.stats }), s ? yv(e, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS) : vv(n, e), o.length && (e.totalduration = e.edge - o[0].start), e.driftStartTime = n.driftStartTime, e.driftStart = n.driftStart; const a = e.advancedDateTime; if (e.advanced && a) { const l = e.edge; e.driftStart || (e.driftStartTime = a, e.driftStart = l), e.driftEndTime = a, e.driftEnd = l } else e.driftEndTime = n.driftEndTime, e.driftEnd = n.driftEnd, e.advancedDateTime = n.advancedDateTime } function kw (n, e, t) { const r = De({}, n); return t && t.forEach(i => { delete r[i] }), Object.keys(e).forEach(i => { const s = new Zy(e[i].attr, r[i]); s.isValid ? r[i] = s : C.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[i].attr)}"`) }), r } function Pw (n, e, t) { if (n && e) { let r = 0; for (let i = 0, s = n.length; i <= s; i++) { const o = n[i]; const a = e[i + r]; o && a && o.index === a.index && o.fragment.sn === a.fragment.sn ? t(o, a) : r-- } } } function bw (n, e, t) { const r = e.skippedSegments; const i = Math.max(n.startSN, e.startSN) - e.startSN; const s = (n.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(n.endSN, e.endSN)) - e.startSN; const o = e.startSN - n.startSN; const a = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments; const l = n.fragmentHint ? n.fragments.concat(n.fragmentHint) : n.fragments; for (let u = i; u <= s; u++) { const c = l[o + u]; let d = a[u]; r && !d && u < r && (d = e.fragments[u] = c), c && d && t(c, d) } } function vv (n, e) { const t = e.startSN + e.skippedSegments - n.startSN; const r = n.fragments; t < 0 || t >= r.length || Jc(e, r[t].start) } function Jc (n, e) { if (e) { const t = n.fragments; for (let r = n.skippedSegments; r < t.length; r++)t[r].start += e; n.fragmentHint && (n.fragmentHint.start += e) } } function Ow (n, e = 1 / 0) { let t = 1e3 * n.targetduration; if (n.updated) { const r = n.fragments; if (r.length && t * 4 > e) { const s = r[r.length - 1].duration * 1e3; s < t && (t = s) } } else t /= 2; return Math.round(t) } function Fw (n, e, t) { if (!(n != null && n.details)) return null; const r = n.details; let i = r.fragments[e - r.startSN]; return i || (i = r.fragmentHint, i && i.sn === e) ? i : e < r.startSN && t && t.sn === e ? t : null } function Bp (n, e, t) { let r; return n != null && n.details ? Ev((r = n.details) == null ? void 0 : r.partList, e, t) : null } function Ev (n, e, t) { if (n) for (let r = n.length; r--;) { const i = n[r]; if (i.index === t && i.fragment.sn === e) return i } return null } function Sv (n) { n.forEach((e, t) => { const { details: r } = e; r != null && r.fragments && r.fragments.forEach(i => { i.level = t }) }) } function el (n) { switch (n.details) { case D.FRAG_LOAD_TIMEOUT:case D.KEY_LOAD_TIMEOUT:case D.LEVEL_LOAD_TIMEOUT:case D.MANIFEST_LOAD_TIMEOUT:return !0 } return !1 } function $p (n, e) { const t = el(e); return n.default[`${t ? 'timeout' : 'error'}Retry`] } function Lh (n, e) { const t = n.backoff === 'linear' ? 1 : Math.pow(2, e); return Math.min(t * n.retryDelayMs, n.maxRetryDelayMs) } function Gp (n) { return $e($e({}, n), { errorRetry: null, timeoutRetry: null }) } function tl (n, e, t, r) { if (!n) return !1; const i = r == null ? void 0 : r.code; const s = e < n.maxNumRetry && (Mw(i) || !!t); return n.shouldRetry ? n.shouldRetry(n, e, t, r, s) : s } function Mw (n) { return n === 0 && navigator.onLine === !1 || !!n && (n < 400 || n > 499) } const Tv = { search: function (n, e) { let t = 0; let r = n.length - 1; let i = null; let s = null; for (;t <= r;) { i = (t + r) / 2 | 0, s = n[i]; const o = e(s); if (o > 0)t = i + 1; else if (o < 0)r = i - 1; else return s } return null } }; function Nw (n, e, t) { if (e === null || !Array.isArray(n) || !n.length || !K(e)) return null; const r = n[0].programDateTime; if (e < (r || 0)) return null; const i = n[n.length - 1].endProgramDateTime; if (e >= (i || 0)) return null; t = t || 0; for (let s = 0; s < n.length; ++s) { const o = n[s]; if (Uw(e, t, o)) return o } return null } function nl (n, e, t = 0, r = 0) { let i = null; if (n) { i = e[n.sn - e[0].sn + 1] || null; const o = n.endDTS - t; o > 0 && o < 15e-7 && (t += 15e-7) } else t === 0 && e[0].start === 0 && (i = e[0]); if (i && (!n || n.level === i.level) && Zc(t, r, i) === 0) return i; const s = Tv.search(e, Zc.bind(null, t, r)); return s && (s !== n || !i) ? s : i } function Zc (n = 0, e = 0, t) { if (t.start <= n && t.start + t.duration > n) return 0; const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)); return t.start + t.duration - r <= n ? 1 : t.start - r > n && t.start ? -1 : 0 } function Uw (n, e, t) { const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3; return (t.endProgramDateTime || 0) - r > n } function Bw (n, e) { return Tv.search(n, t => t.cc < e ? 1 : t.cc > e ? -1 : 0) } const je = { DoNothing: 0, SendEndCallback: 1, SendAlternateToPenaltyBox: 2, RemoveAlternatePermanently: 3, InsertDiscontinuity: 4, RetryRequest: 5 }; const Vt = { None: 0, MoveAllAlternatesMatchingHost: 1, MoveAllAlternatesMatchingHDCP: 2, SwitchToSDR: 4 }; class $w {constructor (e) { this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = C.log.bind(C, '[info]:'), this.warn = C.warn.bind(C, '[warning]:'), this.error = C.error.bind(C, '[error]:'), this.registerListeners() }registerListeners () { const e = this.hls; e.on(S.ERROR, this.onError, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this) }unregisterListeners () { const e = this.hls; e && (e.off(S.ERROR, this.onError, this), e.off(S.ERROR, this.onErrorOut, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this)) }destroy () { this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {} }startLoad (e) {}stopLoad () { this.playlistError = 0 }getVariantLevelIndex (e) { return (e == null ? void 0 : e.type) === X.MAIN ? e.level : this.hls.loadLevel }onManifestLoading () { this.playlistError = 0, this.penalizedRenditions = {} }onLevelUpdated () { this.playlistError = 0 }onError (e, t) { let r, i; if (t.fatal) return; const s = this.hls; const o = t.context; switch (t.details) { case D.FRAG_LOAD_ERROR:case D.FRAG_LOAD_TIMEOUT:case D.KEY_LOAD_ERROR:case D.KEY_LOAD_TIMEOUT:t.errorAction = this.getFragRetryOrSwitchAction(t); return; case D.FRAG_PARSING_ERROR:if ((r = t.frag) != null && r.gap) { t.errorAction = { action: je.DoNothing, flags: Vt.None }; return } case D.FRAG_GAP:case D.FRAG_DECRYPT_ERROR:{ t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = je.SendAlternateToPenaltyBox; return } case D.LEVEL_EMPTY_ERROR:case D.LEVEL_PARSING_ERROR:{ let a, l; const u = t.parent === X.MAIN ? t.level : s.loadLevel; t.details === D.LEVEL_EMPTY_ERROR && ((a = t.context) != null && (l = a.levelDetails) != null && l.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, u) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, u)) } return; case D.LEVEL_LOAD_ERROR:case D.LEVEL_LOAD_TIMEOUT:typeof (o == null ? void 0 : o.level) === 'number' && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, o.level)); return; case D.AUDIO_TRACK_LOAD_ERROR:case D.AUDIO_TRACK_LOAD_TIMEOUT:case D.SUBTITLE_LOAD_ERROR:case D.SUBTITLE_TRACK_LOAD_TIMEOUT:if (o) { const u = s.levels[s.loadLevel]; if (u && (o.type === se.AUDIO_TRACK && u.hasAudioGroup(o.groupId) || o.type === se.SUBTITLE_TRACK && u.hasSubtitleGroup(o.groupId))) { t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.loadLevel), t.errorAction.action = je.SendAlternateToPenaltyBox, t.errorAction.flags = Vt.MoveAllAlternatesMatchingHost; return } } return; case D.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:{ const u = s.levels[s.loadLevel]; const c = u == null ? void 0 : u.attrs['HDCP-LEVEL']; c ? t.errorAction = { action: je.SendAlternateToPenaltyBox, flags: Vt.MoveAllAlternatesMatchingHDCP, hdcpLevel: c } : this.keySystemError(t) } return; case D.BUFFER_ADD_CODEC_ERROR:case D.REMUX_ALLOC_ERROR:case D.BUFFER_APPEND_ERROR:t.errorAction = this.getLevelSwitchAction(t, (i = t.level) != null ? i : s.loadLevel); return; case D.INTERNAL_EXCEPTION:case D.BUFFER_APPENDING_ERROR:case D.BUFFER_FULL_ERROR:case D.LEVEL_SWITCH_ERROR:case D.BUFFER_STALLED_ERROR:case D.BUFFER_SEEK_OVER_HOLE:case D.BUFFER_NUDGE_ON_STALL:t.errorAction = { action: je.DoNothing, flags: Vt.None }; return }t.type === J.KEY_SYSTEM_ERROR && this.keySystemError(t) }keySystemError (e) { const t = this.getVariantLevelIndex(e.frag); e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t) }getPlaylistRetryOrSwitchAction (e, t) { const r = this.hls; const i = $p(r.config.playlistLoadPolicy, e); const s = this.playlistError++; if (tl(i, s, el(e), e.response)) return { action: je.RetryRequest, flags: Vt.None, retryConfig: i, retryCount: s }; const a = this.getLevelSwitchAction(e, t); return i && (a.retryConfig = i, a.retryCount = s), a }getFragRetryOrSwitchAction (e) { const t = this.hls; const r = this.getVariantLevelIndex(e.frag); const i = t.levels[r]; const { fragLoadPolicy: s, keyLoadPolicy: o } = t.config; const a = $p(e.details.startsWith('key') ? o : s, e); const l = t.levels.reduce((c, d) => c + d.fragmentError, 0); if (i && (e.details !== D.FRAG_GAP && i.fragmentError++, tl(a, l, el(e), e.response))) return { action: je.RetryRequest, flags: Vt.None, retryConfig: a, retryCount: l }; const u = this.getLevelSwitchAction(e, r); return a && (u.retryConfig = a, u.retryCount = l), u }getLevelSwitchAction (e, t) { const r = this.hls; t == null && (t = r.loadLevel); const i = this.hls.levels[t]; if (i) { let s, o; const u = e.details; i.loadError++, u === D.BUFFER_APPEND_ERROR && i.fragmentError++; let c = -1; const { levels: d, loadLevel: h, minAutoLevel: f, maxAutoLevel: p } = r; r.autoLevelEnabled || (r.loadLevel = -1); const m = (s = e.frag) == null ? void 0 : s.type; const g = (m === X.AUDIO && u === D.FRAG_PARSING_ERROR || e.sourceBufferName === 'audio' && (u === D.BUFFER_ADD_CODEC_ERROR || u === D.BUFFER_APPEND_ERROR)) && d.some(({ audioCodec: w }) => i.audioCodec !== w); const E = e.sourceBufferName === 'video' && (u === D.BUFFER_ADD_CODEC_ERROR || u === D.BUFFER_APPEND_ERROR) && d.some(({ codecSet: w, audioCodec: L }) => i.codecSet !== w && i.audioCodec === L); const { type: x, groupId: T } = (o = e.context) != null ? o : {}; for (let w = d.length; w--;) { const L = (w + h) % d.length; if (L !== h && L >= f && L <= p && d[L].loadError === 0) { var a, l; const A = d[L]; if (u === D.FRAG_GAP && e.frag) { const P = d[L].details; if (P) { const _ = nl(e.frag, P.fragments, e.frag.start); if (_ != null && _.gap) continue } } else { if (x === se.AUDIO_TRACK && A.hasAudioGroup(T) || x === se.SUBTITLE_TRACK && A.hasSubtitleGroup(T)) continue; if (m === X.AUDIO && (a = i.audioGroups) != null && a.some(P => A.hasAudioGroup(P)) || m === X.SUBTITLE && (l = i.subtitleGroups) != null && l.some(P => A.hasSubtitleGroup(P)) || g && i.audioCodec === A.audioCodec || !g && i.audioCodec !== A.audioCodec || E && i.codecSet === A.codecSet) continue }c = L; break } } if (c > -1 && r.loadLevel !== c) return e.levelRetry = !0, this.playlistError = 0, { action: je.SendAlternateToPenaltyBox, flags: Vt.None, nextAutoLevel: c } } return { action: je.SendAlternateToPenaltyBox, flags: Vt.MoveAllAlternatesMatchingHost } }onErrorOut (e, t) { let r; switch ((r = t.errorAction) == null ? void 0 : r.action) { case je.DoNothing:break; case je.SendAlternateToPenaltyBox:this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== D.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()); break } if (t.fatal) { this.hls.stopLoad() } }sendAlternateToPenaltyBox (e) { const t = this.hls; const r = e.errorAction; if (!r) return; const { flags: i, hdcpLevel: s, nextAutoLevel: o } = r; switch (i) { case Vt.None:this.switchLevel(e, o); break; case Vt.MoveAllAlternatesMatchingHDCP:s && (t.maxHdcpLevel = Xc[Xc.indexOf(s) - 1], r.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`); break }r.resolved || this.switchLevel(e, o) }switchLevel (e, t) { t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel) }} class Rh {constructor (e, t) { this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = C.log.bind(C, `${t}:`), this.warn = C.warn.bind(C, `${t}:`), this.hls = e }destroy () { this.clearTimer(), this.hls = this.log = this.warn = null }clearTimer () { this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1) }startLoad () { this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist() }stopLoad () { this.canLoad = !1, this.clearTimer() }switchParams (e, t, r) { const i = t == null ? void 0 : t.renditionReports; if (i) { let s = -1; for (let o = 0; o < i.length; o++) { const a = i[o]; let l; try { l = new self.URL(a.URI, t.url).href } catch (u) { C.warn(`Could not construct new URL for Rendition Report: ${u}`), l = a.URI || '' } if (l === e) { s = o; break } else l === e.substring(0, l.length) && (s = o) } if (s !== -1) { const o = i[s]; const a = parseInt(o['LAST-MSN']) || (t == null ? void 0 : t.lastPartSn); let l = parseInt(o['LAST-PART']) || (t == null ? void 0 : t.lastPartIndex); if (this.hls.config.lowLatencyMode) { const c = Math.min(t.age - t.partTarget, t.targetduration); l >= 0 && c > t.partTarget && (l += 1) } const u = r && Mp(r); return new Np(a, l >= 0 ? l : void 0, u) } } }loadPlaylist (e) { this.requestScheduled === -1 && (this.requestScheduled = self.performance.now()) }shouldLoadPlaylist (e) { return this.canLoad && !!e && !!e.url && (!e.details || e.details.live) }shouldReloadPlaylist (e) { return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(e) }playlistLoaded (e, t, r) { const { details: i, stats: s } = t; const o = self.performance.now(); const a = s.loading.first ? Math.max(0, o - s.loading.first) : 0; if (i.advancedDateTime = Date.now() - a, i.live || r != null && r.live) { if (i.reloaded(r), r && this.log(`live playlist ${e} ${i.advanced ? 'REFRESHED ' + i.lastPartSn + '-' + i.lastPartIndex : i.updated ? 'UPDATED' : 'MISSED'}`), r && i.fragments.length > 0 && Dw(r, i), !this.canLoad || !i.live) return; let l, u, c; if (i.canBlockReload && i.endSN && i.advanced) { const y = this.hls.config.lowLatencyMode; const g = i.lastPartSn; const v = i.endSN; const E = i.lastPartIndex; const x = E !== -1; const T = g === v; const w = y ? 0 : E; x ? (u = T ? v + 1 : g, c = T ? w : E + 1) : u = v + 1; const L = i.age; const A = L + i.ageHeader; let P = Math.min(A - i.partTarget, i.targetduration * 1.5); if (P > 0) { if (r && P > r.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${P} with playlist age: ${i.age}`), P = 0; else { const _ = Math.floor(P / i.targetduration); if (u += _, c !== void 0) { const F = Math.round(P % i.targetduration / i.partTarget); c += F } this.log(`CDN Tune-in age: ${i.ageHeader}s last advanced ${L.toFixed(2)}s goal: ${P} skip sn ${_} to part ${c}`) }i.tuneInGoal = P } if (l = this.getDeliveryDirectives(i, t.deliveryDirectives, u, c), y || !T) { this.loadPlaylist(l); return } } else (i.canBlockReload || i.canSkipUntil) && (l = this.getDeliveryDirectives(i, t.deliveryDirectives, u, c)); const d = this.hls.mainForwardBufferInfo; const h = d ? d.end - d.len : 0; const f = (i.edge - h) * 1e3; const p = Ow(i, f); i.updated && o > this.requestScheduled + p && (this.requestScheduled = s.loading.start), u !== void 0 && i.canBlockReload ? this.requestScheduled = s.loading.first + p - (i.partTarget * 1e3 || 1e3) : this.requestScheduled === -1 || this.requestScheduled + p < o ? this.requestScheduled = o : this.requestScheduled - o <= 0 && (this.requestScheduled += p); let m = this.requestScheduled - o; m = Math.max(0, m), this.log(`reload live playlist ${e} in ${Math.round(m)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(l), m) } else this.clearTimer() }getDeliveryDirectives (e, t, r, i) { let s = Mp(e); return t != null && t.skip && e.deltaUpdateFailed && (r = t.msn, i = t.part, s = pa.No), new Np(r, i, s) }checkRetry (e) { const t = e.details; const r = el(e); const i = e.errorAction; const { action: s, retryCount: o = 0, retryConfig: a } = i || {}; const l = !!i && !!a && (s === je.RetryRequest || !i.resolved && s === je.SendAlternateToPenaltyBox); if (l) { let u; if (this.requestScheduled = -1, o >= a.maxNumRetry) return !1; if (r && (u = e.context) != null && u.deliveryDirectives) this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else { const c = Lh(a, o); this.timer = self.setTimeout(() => this.loadPlaylist(), c), this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" in ${c}ms`) }e.levelRetry = !0, i.resolved = !0 } return l }} class Yr {constructor (e, t = 0, r = 0) { this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r }sample (e, t) { const r = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e }getTotalWeight () { return this.totalWeight_ }getEstimate () { if (this.alpha_) { const e = 1 - Math.pow(this.alpha_, this.totalWeight_); if (e) return this.estimate_ / e } return this.estimate_ }} class Gw {constructor (e, t, r, i = 100) { this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 0.001, this.minDelayMs_ = 50, this.slow_ = new Yr(e), this.fast_ = new Yr(t), this.defaultTTFB_ = i, this.ttfb_ = new Yr(e) }update (e, t) { const { slow_: r, fast_: i, ttfb_: s } = this; r.halfLife !== e && (this.slow_ = new Yr(e, r.getEstimate(), r.getTotalWeight())), i.halfLife !== t && (this.fast_ = new Yr(t, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new Yr(e, s.getEstimate(), s.getTotalWeight())) }sample (e, t) { e = Math.max(e, this.minDelayMs_); const r = 8 * t; const i = e / 1e3; const s = r / i; this.fast_.sample(i, s), this.slow_.sample(i, s) }sampleTTFB (e) { const t = e / 1e3; const r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2); this.ttfb_.sample(r, Math.max(e, 5)) }canEstimate () { return this.fast_.getTotalWeight() >= this.minWeight_ }getEstimate () { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ }getEstimateTTFB () { return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_ }destroy () {}} const xv = { supported: !0, configurations: [], decodingInfoResults: [{ supported: !0, powerEfficient: !0, smooth: !0 }] }; const Vp = {}; function Vw (n, e, t, r, i, s) { const o = n.audioCodec ? n.audioGroups : null; const a = s == null ? void 0 : s.audioCodec; const l = s == null ? void 0 : s.channels; const u = l ? parseInt(l) : a ? 1 / 0 : 2; let c = null; if (o != null && o.length) try { o.length === 1 && o[0] ? c = e.groups[o[0]].channels : c = o.reduce((d, h) => { if (h) { const f = e.groups[h]; if (!f) throw new Error(`Audio track group ${h} not found`); Object.keys(f.channels).forEach(p => { d[p] = (d[p] || 0) + f.channels[p] }) } return d }, { 2: 0 }) } catch { return !0 } return n.videoCodec !== void 0 && (n.width > 1920 && n.height > 1088 || n.height > 1920 && n.width > 1088 || n.frameRate > Math.max(r, 30) || n.videoRange !== 'SDR' && n.videoRange !== t || n.bitrate > Math.max(i, 8e6)) || !!c && K(u) && Object.keys(c).some(d => parseInt(d) > u) } function Hw (n, e, t) { const r = n.videoCodec; const i = n.audioCodec; if (!r || !i || !t) return Promise.resolve(xv); const s = { width: n.width, height: n.height, bitrate: Math.ceil(Math.max(n.bitrate * 0.9, n.averageBitrate)), framerate: n.frameRate || 30 }; const o = n.videoRange; o !== 'SDR' && (s.transferFunction = o.toLowerCase()); const a = r.split(',').map(l => ({ type: 'media-source', video: $e($e({}, s), {}, { contentType: to(l, 'video') }) })); return i && n.audioGroups && n.audioGroups.forEach(l => { let u; l && ((u = e.groups[l]) == null || u.tracks.forEach(c => { if (c.groupId === l) { const d = c.channels || ''; const h = parseFloat(d); K(h) && h > 2 && a.push.apply(a, i.split(',').map(f => ({ type: 'media-source', audio: { contentType: to(f, 'audio'), channels: '' + h } }))) } })) }), Promise.all(a.map(l => { const u = Kw(l); return Vp[u] || (Vp[u] = t.decodingInfo(l)) })).then(l => ({ supported: !l.some(u => !u.supported), configurations: a, decodingInfoResults: l })).catch(l => ({ supported: !1, configurations: a, decodingInfoResults: [], error: l })) } function Kw (n) { const { audio: e, video: t } = n; const r = t || e; if (r) { const i = r.contentType.split('"')[1]; if (t) return `r${t.height}x${t.width}f${Math.ceil(t.framerate)}${t.transferFunction || 'sd'}_${i}_${Math.ceil(t.bitrate / 1e5)}`; if (e) return `c${e.channels}${e.spatialRendering ? 's' : 'n'}_${i}` } return '' } function jw () { if (typeof matchMedia === 'function') { const n = matchMedia('(dynamic-range: high)'); const e = matchMedia('bad query'); if (n.media !== e.media) return n.matches === !0 } return !1 } function zw (n, e) { let t = !1; let r = []; return n && (t = n !== 'SDR', r = [n]), e && (r = e.allowedVideoRanges || Za.slice(0), t = e.preferHDR !== void 0 ? e.preferHDR : jw(), t ? r = r.filter(i => i !== 'SDR') : r = ['SDR']), { preferHDR: t, allowedVideoRanges: r } } function Ww (n, e, t, r, i) { const s = Object.keys(n); const o = r == null ? void 0 : r.channels; const a = r == null ? void 0 : r.audioCodec; const l = o && parseInt(o) === 2; let u = !0; let c = !1; let d = 1 / 0; let h = 1 / 0; let f = 1 / 0; let p = 0; let m = []; const { preferHDR: y, allowedVideoRanges: g } = zw(e, i); for (let T = s.length; T--;) { const w = n[s[T]]; u = w.channels[2] > 0, d = Math.min(d, w.minHeight), h = Math.min(h, w.minFramerate), f = Math.min(f, w.minBitrate); const L = g.filter(A => w.videoRanges[A] > 0); L.length > 0 && (c = !0, m = L) }d = K(d) ? d : 0, h = K(h) ? h : 0; const v = Math.max(1080, d); const E = Math.max(30, h); return f = K(f) ? f : t, t = Math.max(f, t), c || (e = void 0, m = []), { codecSet: s.reduce((T, w) => { const L = n[w]; if (w === T) return T; if (L.minBitrate > t) return mn(w, `min bitrate of ${L.minBitrate} > current estimate of ${t}`), T; if (!L.hasDefaultAudio) return mn(w, 'no renditions with default or auto-select sound found'), T; if (a && w.indexOf(a.substring(0, 4)) % 5 !== 0) return mn(w, `audio codec preference "${a}" not found`), T; if (o && !l) { if (!L.channels[o]) return mn(w, `no renditions with ${o} channel sound found (channels options: ${Object.keys(L.channels)})`), T } else if ((!a || l) && u && L.channels[2] === 0) return mn(w, 'no renditions with stereo sound found'), T; return L.minHeight > v ? (mn(w, `min resolution of ${L.minHeight} > maximum of ${v}`), T) : L.minFramerate > E ? (mn(w, `min framerate of ${L.minFramerate} > maximum of ${E}`), T) : m.some(A => L.videoRanges[A] > 0) ? L.maxScore < p ? (mn(w, `max score of ${L.maxScore} < selected max of ${p}`), T) : T && (Xa(w) >= Xa(T) || L.fragmentError > n[T].fragmentError) ? T : (p = L.maxScore, w) : (mn(w, `no variants with VIDEO-RANGE of ${JSON.stringify(m)} found`), T) }, void 0), videoRanges: m, preferHDR: y, minFramerate: h, minBitrate: f } } function mn (n, e) { C.log(`[abr] start candidates with "${n}" ignored because ${e}`) } function Yw (n) { return n.reduce((e, t) => { let r = e.groups[t.groupId]; r || (r = e.groups[t.groupId] = { tracks: [], channels: { 2: 0 }, hasDefault: !1, hasAutoSelect: !1 }), r.tracks.push(t); const i = t.channels || '2'; return r.channels[i] = (r.channels[i] || 0) + 1, r.hasDefault = r.hasDefault || t.default, r.hasAutoSelect = r.hasAutoSelect || t.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e }, { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} }) } function qw (n, e, t, r) { return n.slice(t, r + 1).reduce((i, s) => { if (!s.codecSet) return i; const o = s.audioGroups; let a = i[s.codecSet]; a || (i[s.codecSet] = a = { minBitrate: 1 / 0, minHeight: 1 / 0, minFramerate: 1 / 0, maxScore: 0, videoRanges: { SDR: 0 }, channels: { 2: 0 }, hasDefaultAudio: !o, fragmentError: 0 }), a.minBitrate = Math.min(a.minBitrate, s.bitrate); const l = Math.min(s.height, s.width); return a.minHeight = Math.min(a.minHeight, l), a.minFramerate = Math.min(a.minFramerate, s.frameRate), a.maxScore = Math.max(a.maxScore, s.score), a.fragmentError += s.fragmentError, a.videoRanges[s.videoRange] = (a.videoRanges[s.videoRange] || 0) + 1, o && o.forEach(u => { if (!u) return; const c = e.groups[u]; c && (a.hasDefaultAudio = a.hasDefaultAudio || e.hasDefaultAudio ? c.hasDefault : c.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(c.channels).forEach(d => { a.channels[d] = (a.channels[d] || 0) + c.channels[d] })) }), i }, {}) } function cn (n, e, t) { if ('attrs' in n) { const r = e.indexOf(n); if (r !== -1) return r } for (let r = 0; r < e.length; r++) { const i = e[r]; if (xi(n, i, t)) return r } return -1 } function xi (n, e, t) { const { groupId: r, name: i, lang: s, assocLang: o, characteristics: a, default: l } = n; const u = n.forced; return (r === void 0 || e.groupId === r) && (i === void 0 || e.name === i) && (s === void 0 || e.lang === s) && (s === void 0 || e.assocLang === o) && (l === void 0 || e.default === l) && (u === void 0 || e.forced === u) && (a === void 0 || Qw(a, e.characteristics)) && (t === void 0 || t(n, e)) } function Qw (n, e = '') { const t = n.split(','); const r = e.split(','); return t.length === r.length && !t.some(i => r.indexOf(i) === -1) } function qr (n, e) { const { audioCodec: t, channels: r } = n; return (t === void 0 || (e.audioCodec || '').substring(0, 4) === t.substring(0, 4)) && (r === void 0 || r === (e.channels || '2')) } function Xw (n, e, t, r, i) { const s = e[r]; const a = e.reduce((h, f, p) => { const m = f.uri; return (h[m] || (h[m] = [])).push(p), h }, {})[s.uri]; a.length > 1 && (r = Math.max.apply(Math, a)); const l = s.videoRange; const u = s.frameRate; const c = s.codecSet.substring(0, 4); const d = Hp(e, r, h => { if (h.videoRange !== l || h.frameRate !== u || h.codecSet.substring(0, 4) !== c) return !1; const f = h.audioGroups; const p = t.filter(m => !f || f.indexOf(m.groupId) !== -1); return cn(n, p, i) > -1 }); return d > -1 ? d : Hp(e, r, h => { const f = h.audioGroups; const p = t.filter(m => !f || f.indexOf(m.groupId) !== -1); return cn(n, p, i) > -1 }) } function Hp (n, e, t) { for (let r = e; r; r--) if (t(n[r])) return r; for (let r = e + 1; r < n.length; r++) if (t(n[r])) return r; return -1 } class Jw {
  constructor (e) {
    this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = '', this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = () => {
      const { fragCurrent: t, partCurrent: r, hls: i } = this; const { autoLevelEnabled: s, media: o } = i; if (!t || !o) return; const a = performance.now(); const l = r ? r.stats : t.stats; const u = r ? r.duration : t.duration; const c = a - l.loading.start; const d = i.minAutoLevel; if (l.aborted || l.loaded && l.loaded === l.total || t.level <= d) { this.clearTimer(), this._nextAutoLevel = -1; return } if (!s || o.paused || !o.playbackRate || !o.readyState) return; const h = i.mainForwardBufferInfo; if (h === null) return; const f = this.bwEstimator.getEstimateTTFB(); const p = Math.abs(o.playbackRate); if (c <= Math.max(f, 1e3 * (u / (p * 2)))) return; const m = h.len / p; const y = l.loading.first ? l.loading.first - l.loading.start : -1; const g = l.loaded && y > -1; const v = this.getBwEstimate(); const E = i.levels; const x = E[t.level]; const T = l.total || Math.max(l.loaded, Math.round(u * x.averageBitrate / 8)); let w = g ? c - y : c; w < 1 && g && (w = Math.min(c, l.loaded * 8 / v)); const L = g ? l.loaded * 1e3 / w : 0; const A = L ? (T - l.loaded) / L : T * 8 / v + f / 1e3; if (A <= m) return; const P = L ? L * 8 : v; let _ = Number.POSITIVE_INFINITY; let F; for (F = t.level - 1; F > d; F--) { const G = E[F].maxBitrate; if (_ = this.getTimeToLoadFrag(f / 1e3, P, u * G, !E[F].details), _ < m) break } if (_ >= A || _ > u * 10) return; i.nextLoadLevel = i.nextAutoLevel = F, g ? this.bwEstimator.sample(c - Math.min(f, y), l.loaded) : this.bwEstimator.sampleTTFB(c); const $ = E[F].maxBitrate; this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > $ && this.resetEstimator($), this.clearTimer(), C.warn(`[abr] Fragment ${t.sn}${r ? ' part ' + r.index : ''} of level ${t.level} is loading too slowly;
      Time to underbuffer: ${m.toFixed(3)} s
      Estimated load time for current fragment: ${A.toFixed(3)} s
      Estimated load time for down switch fragment: ${_.toFixed(3)} s
      TTFB estimate: ${y | 0} ms
      Current BW estimate: ${K(v) ? v | 0 : 'Unknown'} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${F} @ ${$ | 0} bps`), i.trigger(S.FRAG_LOAD_EMERGENCY_ABORTED, { frag: t, part: r, stats: l })
    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners()
  }

  resetEstimator (e) { e && (C.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator() }initEstimator () { const e = this.hls.config; return new Gw(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate) }registerListeners () { const { hls: e } = this; e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.FRAG_LOADING, this.onFragLoading, this), e.on(S.FRAG_LOADED, this.onFragLoaded, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this), e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(S.LEVEL_LOADED, this.onLevelLoaded, this), e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(S.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(S.ERROR, this.onError, this) }unregisterListeners () { const { hls: e } = this; e && (e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.FRAG_LOADING, this.onFragLoading, this), e.off(S.FRAG_LOADED, this.onFragLoaded, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this), e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(S.LEVEL_LOADED, this.onLevelLoaded, this), e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(S.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(S.ERROR, this.onError, this)) }destroy () { this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null }onManifestLoading (e, t) { this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer() }onLevelsUpdated () { this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null }onMaxAutoLevelUpdated () { this.firstSelection = -1, this.nextAutoLevelKey = '' }onFragLoading (e, t) { const r = t.frag; if (!this.ignoreFragment(r)) { if (!r.bitrateTest) { let i; this.fragCurrent = r, this.partCurrent = (i = t.part) != null ? i : null } this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100) } }onLevelSwitching (e, t) { this.clearTimer() }onError (e, t) { if (!t.fatal) switch (t.details) { case D.BUFFER_ADD_CODEC_ERROR:case D.BUFFER_APPEND_ERROR:this.lastLoadedFragLevel = -1, this.firstSelection = -1; break; case D.FRAG_LOAD_TIMEOUT:{ const r = t.frag; const { fragCurrent: i, partCurrent: s } = this; if (r && i && r.sn === i.sn && r.level === i.level) { const o = performance.now(); const a = s ? s.stats : r.stats; const l = o - a.loading.start; const u = a.loading.first ? a.loading.first - a.loading.start : -1; if (a.loaded && u > -1) { const d = this.bwEstimator.getEstimateTTFB(); this.bwEstimator.sample(l - Math.min(d, u), a.loaded) } else this.bwEstimator.sampleTTFB(l) } break } } }getTimeToLoadFrag (e, t, r, i) { const s = e + r / t; const o = i ? this.lastLevelLoadSec : 0; return s + o }onLevelLoaded (e, t) { const r = this.hls.config; const { loading: i } = t.stats; const s = i.end - i.start; K(s) && (this.lastLevelLoadSec = s / 1e3), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD) }onFragLoaded (e, { frag: t, part: r }) { const i = r ? r.stats : t.stats; if (t.type === X.MAIN && this.bwEstimator.sampleTTFB(i.loading.first - i.loading.start), !this.ignoreFragment(t)) { if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) { const s = r ? r.duration : t.duration; const o = this.hls.levels[t.level]; const a = (o.loaded ? o.loaded.bytes : 0) + i.loaded; const l = (o.loaded ? o.loaded.duration : 0) + s; o.loaded = { bytes: a, duration: l }, o.realBitrate = Math.round(8 * a / l) } if (t.bitrateTest) { const s = { stats: i, frag: t, part: r, id: t.type }; this.onFragBuffered(S.FRAG_BUFFERED, s), t.bitrateTest = !1 } else this.lastLoadedFragLevel = t.level } }onFragBuffered (e, t) { const { frag: r, part: i } = t; const s = i != null && i.stats.loaded ? i.stats : r.stats; if (s.aborted || this.ignoreFragment(r)) return; const o = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB()); this.bwEstimator.sample(o, s.loaded), s.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = o / 1e3 : this.bitrateTestDelay = 0 }ignoreFragment (e) { return e.type !== X.MAIN || e.sn === 'initSegment' }clearTimer () { this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1) } get firstAutoLevel () { const { maxAutoLevel: e, minAutoLevel: t } = this.hls; const r = this.getBwEstimate(); const i = this.hls.config.maxStarvationDelay; const s = this.findBestLevel(r, t, e, 0, i, 1, 1); if (s > -1) return s; const o = this.hls.firstLevel; const a = Math.min(Math.max(o, t), e); return C.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${o} clamped to ${a}`), a } get forcedAutoLevel () { return this.nextAutoLevelKey ? -1 : this._nextAutoLevel } get nextAutoLevel () { const e = this.forcedAutoLevel; const r = this.bwEstimator.canEstimate(); const i = this.lastLoadedFragLevel > -1; if (e !== -1 && (!r || !i || this.nextAutoLevelKey === this.getAutoLevelKey())) return e; const s = r && i ? this.getNextABRAutoLevel() : this.firstAutoLevel; if (e !== -1) { const o = this.hls.levels; if (o.length > Math.max(e, s) && o[e].loadError <= o[s].loadError) return e } return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s }getAutoLevelKey () { return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}` }getNextABRAutoLevel () { const { fragCurrent: e, partCurrent: t, hls: r } = this; const { maxAutoLevel: i, config: s, minAutoLevel: o } = r; const a = t ? t.duration : e ? e.duration : 0; const l = this.getBwEstimate(); const u = this.getStarvationDelay(); let c = s.abrBandWidthFactor; let d = s.abrBandWidthUpFactor; if (u) { const y = this.findBestLevel(l, o, i, u, 0, c, d); if (y >= 0) return y } let h = a ? Math.min(a, s.maxStarvationDelay) : s.maxStarvationDelay; if (!u) { const y = this.bitrateTestDelay; y && (h = (a ? Math.min(a, s.maxLoadingDelay) : s.maxLoadingDelay) - y, C.info(`[abr] bitrate test took ${Math.round(1e3 * y)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * h)} ms`), c = d = 1) } const f = this.findBestLevel(l, o, i, u, h, c, d); if (C.info(`[abr] ${u ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${f}`), f > -1) return f; const p = r.levels[o]; const m = r.levels[r.loadLevel]; return (p == null ? void 0 : p.bitrate) < (m == null ? void 0 : m.bitrate) ? o : r.loadLevel }getStarvationDelay () { const e = this.hls; const t = e.media; if (!t) return 1 / 0; const r = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1; const i = e.mainForwardBufferInfo; return (i ? i.len : 0) / r }getBwEstimate () { return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate }findBestLevel (e, t, r, i, s, o, a) { let l; const u = i + s; const c = this.lastLoadedFragLevel; const d = c === -1 ? this.hls.firstLevel : c; const { fragCurrent: h, partCurrent: f } = this; const { levels: p, allAudioTracks: m, loadLevel: y, config: g } = this.hls; if (p.length === 1) return 0; const v = p[d]; const E = !!(v != null && (l = v.details) != null && l.live); const x = y === -1 || c === -1; let T; let w = 'SDR'; let L = (v == null ? void 0 : v.frameRate) || 0; const { audioPreference: A, videoPreference: P } = g; const _ = this.audioTracksByGroup || (this.audioTracksByGroup = Yw(m)); if (x) { if (this.firstSelection !== -1) return this.firstSelection; const Z = this.codecTiers || (this.codecTiers = qw(p, _, t, r)); const Y = Ww(Z, w, e, A, P); const { codecSet: re, videoRanges: N, minFramerate: M, minBitrate: b, preferHDR: q } = Y; T = re, w = q ? N[N.length - 1] : N[0], L = M, e = Math.max(e, b), C.log(`[abr] picked start tier ${JSON.stringify(Y)}`) } else T = v == null ? void 0 : v.codecSet, w = v == null ? void 0 : v.videoRange; const F = f ? f.duration : h ? h.duration : 0; const $ = this.bwEstimator.getEstimateTTFB() / 1e3; const G = []; for (let Z = r; Z >= t; Z--) { var W; const Y = p[Z]; const re = Z > d; if (!Y) continue; if (g.useMediaCapabilities && !Y.supportedResult && !Y.supportedPromise) { const ue = navigator.mediaCapabilities; typeof (ue == null ? void 0 : ue.decodingInfo) === 'function' && Vw(Y, _, w, L, e, A) ? (Y.supportedPromise = Hw(Y, _, ue), Y.supportedPromise.then(xe => { if (!this.hls) return; Y.supportedResult = xe; const fe = this.hls.levels; const Ge = fe.indexOf(Y); xe.error ? C.warn(`[abr] MediaCapabilities decodingInfo error: "${xe.error}" for level ${Ge} ${JSON.stringify(xe)}`) : xe.supported || (C.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${Ge} ${JSON.stringify(xe)}`), Ge > -1 && fe.length > 1 && (C.log(`[abr] Removing unsupported level ${Ge}`), this.hls.removeLevel(Ge))) })) : Y.supportedResult = xv } if (T && Y.codecSet !== T || w && Y.videoRange !== w || re && L > Y.frameRate || !re && L > 0 && L < Y.frameRate || Y.supportedResult && !((W = Y.supportedResult.decodingInfoResults) != null && W[0].smooth)) { G.push(Z); continue } const N = Y.details; const M = (f ? N == null ? void 0 : N.partTarget : N == null ? void 0 : N.averagetargetduration) || F; let b; re ? b = a * e : b = o * e; const q = F && i >= F * 2 && s === 0 ? p[Z].averageBitrate : p[Z].maxBitrate; const z = this.getTimeToLoadFrag($, b, q * M, N === void 0); if (b >= q && (Z === c || Y.loadError === 0 && Y.fragmentError === 0) && (z <= $ || !K(z) || E && !this.bitrateTestDelay || z < u)) { const ue = this.forcedAutoLevel; return Z !== y && (ue === -1 || ue !== y) && (G.length && C.trace(`[abr] Skipped level(s) ${G.join(',')} of ${r} max with CODECS and VIDEO-RANGE:"${p[G[0]].codecs}" ${p[G[0]].videoRange}; not compatible with "${v.codecs}" ${w}`), C.info(`[abr] switch candidate:${d}->${Z} adjustedbw(${Math.round(b)})-bitrate=${Math.round(b - q)} ttfb:${$.toFixed(1)} avgDuration:${M.toFixed(1)} maxFetchDuration:${u.toFixed(1)} fetchDuration:${z.toFixed(1)} firstSelection:${x} codecSet:${T} videoRange:${w} hls.loadLevel:${y}`)), x && (this.firstSelection = Z), Z } } return -1 } set nextAutoLevel (e) { const { maxAutoLevel: t, minAutoLevel: r } = this.hls; const i = Math.min(Math.max(e, r), t); this._nextAutoLevel !== i && (this.nextAutoLevelKey = '', this._nextAutoLevel = i) }
} class Zw {constructor () { this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this) }destroy () { this.onHandlerDestroying(), this.onHandlerDestroyed() }onHandlerDestroying () { this.clearNextTick(), this.clearInterval() }onHandlerDestroyed () {}hasInterval () { return !!this._tickInterval }hasNextTick () { return !!this._tickTimer }setInterval (e) { return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0) }clearInterval () { return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1 }clearNextTick () { return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1 }tick () { this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0) }tickImmediate () { this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0) }doTick () {}} const Ue = { NOT_LOADED: 'NOT_LOADED', APPENDING: 'APPENDING', PARTIAL: 'PARTIAL', OK: 'OK' }; class eC {constructor (e) { this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners() }_registerListeners () { const { hls: e } = this; e.on(S.BUFFER_APPENDED, this.onBufferAppended, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this), e.on(S.FRAG_LOADED, this.onFragLoaded, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.BUFFER_APPENDED, this.onBufferAppended, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this), e.off(S.FRAG_LOADED, this.onFragLoaded, this) }destroy () { this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null }getAppendedFrag (e, t) { const r = this.activePartLists[t]; if (r) for (let i = r.length; i--;) { const s = r[i]; if (!s) break; const o = s.end; if (s.start <= e && o !== null && e <= o) return s } return this.getBufferedFrag(e, t) }getBufferedFrag (e, t) { const { fragments: r } = this; const i = Object.keys(r); for (let s = i.length; s--;) { const o = r[i[s]]; if ((o == null ? void 0 : o.body.type) === t && o.buffered) { const a = o.body; if (a.start <= e && e <= a.end) return a } } return null }detectEvictedFragments (e, t, r, i) { this.timeRanges && (this.timeRanges[e] = t); const s = (i == null ? void 0 : i.fragment.sn) || -1; Object.keys(this.fragments).forEach(o => { const a = this.fragments[o]; if (!a || s >= a.body.sn) return; if (!a.buffered && !a.loaded) { a.body.type === r && this.removeFragment(a.body); return } const l = a.range[e]; l && l.time.some(u => { const c = !this.isTimeBuffered(u.startPTS, u.endPTS, t); return c && this.removeFragment(a.body), c }) }) }detectPartialFragments (e) { const t = this.timeRanges; const { frag: r, part: i } = e; if (!t || r.sn === 'initSegment') return; const s = Qr(r); const o = this.fragments[s]; if (!o || o.buffered && r.gap) return; const a = !r.relurl; Object.keys(t).forEach(l => { const u = r.elementaryStreams[l]; if (!u) return; const c = t[l]; const d = a || u.partial === !0; o.range[l] = this.getBufferedTimes(r, i, d, c) }), o.loaded = null, Object.keys(o.range).length ? (o.buffered = !0, (o.body.endList = r.endList || o.body.endList) && (this.endListFragments[o.body.type] = o), jo(o) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(o.body) }removeParts (e, t) { const r = this.activePartLists[t]; r && (this.activePartLists[t] = r.filter(i => i.fragment.sn >= e)) }fragBuffered (e, t) { const r = Qr(e); let i = this.fragments[r]; !i && t && (i = this.fragments[r] = { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0) }getBufferedTimes (e, t, r, i) { const s = { time: [], partial: r }; const o = e.start; const a = e.end; const l = e.minEndPTS || a; const u = e.maxStartPTS || o; for (let c = 0; c < i.length; c++) { const d = i.start(c) - this.bufferPadding; const h = i.end(c) + this.bufferPadding; if (u >= d && l <= h) { s.time.push({ startPTS: Math.max(o, i.start(c)), endPTS: Math.min(a, i.end(c)) }); break } else if (o < h && a > d) { const f = Math.max(o, i.start(c)); const p = Math.min(a, i.end(c)); p > f && (s.partial = !0, s.time.push({ startPTS: f, endPTS: p })) } else if (a <= d) break } return s }getPartialFragment (e) { let t = null; let r; let i; let s; let o = 0; const { bufferPadding: a, fragments: l } = this; return Object.keys(l).forEach(u => { const c = l[u]; c && jo(c) && (i = c.body.start - a, s = c.body.end + a, e >= i && e <= s && (r = Math.min(e - i, s - e), o <= r && (t = c.body, o = r))) }), t }isEndListAppended (e) { const t = this.endListFragments[e]; return t !== void 0 && (t.buffered || jo(t)) }getState (e) { const t = Qr(e); const r = this.fragments[t]; return r ? r.buffered ? jo(r) ? Ue.PARTIAL : Ue.OK : Ue.APPENDING : Ue.NOT_LOADED }isTimeBuffered (e, t, r) { let i, s; for (let o = 0; o < r.length; o++) { if (i = r.start(o) - this.bufferPadding, s = r.end(o) + this.bufferPadding, e >= i && t <= s) return !0; if (t <= i) return !1 } return !1 }onFragLoaded (e, t) { const { frag: r, part: i } = t; if (r.sn === 'initSegment' || r.bitrateTest) return; const s = i ? null : t; const o = Qr(r); this.fragments[o] = { body: r, appendedPTS: null, loaded: s, buffered: !1, range: Object.create(null) } }onBufferAppended (e, t) { const { frag: r, part: i, timeRanges: s } = t; if (r.sn === 'initSegment') return; const o = r.type; if (i) { let a = this.activePartLists[o]; a || (this.activePartLists[o] = a = []), a.push(i) } this.timeRanges = s, Object.keys(s).forEach(a => { const l = s[a]; this.detectEvictedFragments(a, l, o, i) }) }onFragBuffered (e, t) { this.detectPartialFragments(t) }hasFragment (e) { const t = Qr(e); return !!this.fragments[t] }hasParts (e) { let t; return !!((t = this.activePartLists[e]) != null && t.length) }removeFragmentsInRange (e, t, r, i, s) { i && !this.hasGaps || Object.keys(this.fragments).forEach(o => { const a = this.fragments[o]; if (!a) return; const l = a.body; l.type !== r || i && !l.gap || l.start < t && l.end > e && (a.buffered || s) && this.removeFragment(l) }) }removeFragment (e) { const t = Qr(e); e.stats.loaded = 0, e.clearElementaryStreamInfo(); const r = this.activePartLists[e.type]; if (r) { const i = e.sn; this.activePartLists[e.type] = r.filter(s => s.fragment.sn !== i) } delete this.fragments[t], e.endList && delete this.endListFragments[e.type] }removeAllFragments () { this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1 }} function jo (n) { let e, t, r; return n.buffered && (n.body.gap || ((e = n.range.video) == null ? void 0 : e.partial) || ((t = n.range.audio) == null ? void 0 : t.partial) || ((r = n.range.audiovideo) == null ? void 0 : r.partial)) } function Qr (n) { return `${n.type}_${n.level}_${n.sn}` } const tC = { length: 0, start: () => 0, end: () => 0 }; class de {static isBuffered (e, t) { try { if (e) { const r = de.getBuffered(e); for (let i = 0; i < r.length; i++) if (t >= r.start(i) && t <= r.end(i)) return !0 } } catch {} return !1 } static bufferInfo (e, t, r) { try { if (e) { const i = de.getBuffered(e); const s = []; let o; for (o = 0; o < i.length; o++)s.push({ start: i.start(o), end: i.end(o) }); return this.bufferedInfo(s, t, r) } } catch {} return { len: 0, start: t, end: t, nextStart: void 0 } } static bufferedInfo (e, t, r) { t = Math.max(0, t), e.sort(function (u, c) { const d = u.start - c.start; return d || c.end - u.end }); let i = []; if (r) for (let u = 0; u < e.length; u++) { const c = i.length; if (c) { const d = i[c - 1].end; e[u].start - d < r ? e[u].end > d && (i[c - 1].end = e[u].end) : i.push(e[u]) } else i.push(e[u]) } else i = e; let s = 0; let o; let a = t; let l = t; for (let u = 0; u < i.length; u++) { const c = i[u].start; const d = i[u].end; if (t + r >= c && t < d)a = c, l = d, s = l - t; else if (t + r < c) { o = c; break } } return { len: s, start: a || 0, end: l || 0, nextStart: o } } static getBuffered (e) { try { return e.buffered } catch (t) { return C.log('failed to get media.buffered', t), tC } }} class Ah {constructor (e, t, r, i = 0, s = -1, o = !1) { this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = zo(), this.buffering = { audio: zo(), video: zo(), audiovideo: zo() }, this.level = e, this.sn = t, this.id = r, this.size = i, this.part = s, this.partial = o }} function zo () { return { start: 0, executeStart: 0, executeEnd: 0, end: 0 } } function ma (n, e) { for (let r = 0, i = n.length; r < i; r++) { var t; if (((t = n[r]) == null ? void 0 : t.cc) === e) return n[r] } return null } function nC (n, e, t) { return !!(e && (t.endCC > t.startCC || n && n.cc < t.startCC)) } function rC (n, e) { const t = n.fragments; const r = e.fragments; if (!r.length || !t.length) { C.log('No fragments to align'); return } const i = ma(t, r[0].cc); if (!i || i && !i.startPTS) { C.log('No frag in previous level to align on'); return } return i } function Kp (n, e) { if (n) { const t = n.start + e; n.start = n.startPTS = t, n.endPTS = t + n.duration } } function Lv (n, e) { const t = e.fragments; for (let r = 0, i = t.length; r < i; r++)Kp(t[r], n); e.fragmentHint && Kp(e.fragmentHint, n), e.alignedSliding = !0 } function iC (n, e, t) { e && (sC(n, t, e), !t.alignedSliding && e && rl(t, e), !t.alignedSliding && e && !t.skippedSegments && vv(e, t)) } function sC (n, e, t) { if (nC(n, t, e)) { const r = rC(t, e); r && K(r.start) && (C.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`), Lv(r.start, e)) } } function rl (n, e) { if (!n.hasProgramDateTime || !e.hasProgramDateTime) return; const t = n.fragments; const r = e.fragments; if (!t.length || !r.length) return; let i, s; const o = Math.min(e.endCC, n.endCC); e.startCC < o && n.startCC < o && (i = ma(r, o), s = ma(t, o)), (!i || !s) && (i = r[Math.floor(r.length / 2)], s = ma(t, i.cc) || t[Math.floor(t.length / 2)]); const a = i.programDateTime; const l = s.programDateTime; if (!a || !l) return; const u = (l - a) / 1e3 - (s.start - i.start); Lv(u, n) } const jp = Math.pow(2, 17); class oC {constructor (e) { this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e }destroy () { this.loader && (this.loader.destroy(), this.loader = null) }abort () { this.loader && this.loader.abort() }load (e, t) { const r = e.url; if (!r) return Promise.reject(new En({ type: J.NETWORK_ERROR, details: D.FRAG_LOAD_ERROR, fatal: !1, frag: e, error: new Error(`Fragment does not have a ${r ? 'part list' : 'url'}`), networkDetails: null })); this.abort(); const i = this.config; const s = i.fLoader; const o = i.loader; return new Promise((a, l) => { if (this.loader && this.loader.destroy(), e.gap) if (e.tagList.some(f => f[0] === 'GAP')) { l(Wp(e)); return } else e.gap = !1; const u = this.loader = e.loader = s ? new s(i) : new o(i); const c = zp(e); const d = Gp(i.fragLoadPolicy.default); const h = { loadPolicy: d, timeout: d.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: e.sn === 'initSegment' ? 1 / 0 : jp }; e.stats = u.stats, u.load(c, h, { onSuccess: (f, p, m, y) => { this.resetLoader(e, u); let g = f.data; m.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(g.slice(0, 16)), g = g.slice(16)), a({ frag: e, part: null, payload: g, networkDetails: y }) }, onError: (f, p, m, y) => { this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.FRAG_LOAD_ERROR, fatal: !1, frag: e, response: $e({ url: r, data: void 0 }, f), error: new Error(`HTTP Error ${f.code} ${f.text}`), networkDetails: m, stats: y })) }, onAbort: (f, p, m) => { this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.INTERNAL_ABORTED, fatal: !1, frag: e, error: new Error('Aborted'), networkDetails: m, stats: f })) }, onTimeout: (f, p, m) => { this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, error: new Error(`Timeout after ${h.timeout}ms`), networkDetails: m, stats: f })) }, onProgress: (f, p, m, y) => { t && t({ frag: e, part: null, payload: m, networkDetails: y }) } }) }) }loadPart (e, t, r) { this.abort(); const i = this.config; const s = i.fLoader; const o = i.loader; return new Promise((a, l) => { if (this.loader && this.loader.destroy(), e.gap || t.gap) { l(Wp(e, t)); return } const u = this.loader = e.loader = s ? new s(i) : new o(i); const c = zp(e, t); const d = Gp(i.fragLoadPolicy.default); const h = { loadPolicy: d, timeout: d.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: jp }; t.stats = u.stats, u.load(c, h, { onSuccess: (f, p, m, y) => { this.resetLoader(e, u), this.updateStatsFromPart(e, t); const g = { frag: e, part: t, payload: f.data, networkDetails: y }; r(g), a(g) }, onError: (f, p, m, y) => { this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.FRAG_LOAD_ERROR, fatal: !1, frag: e, part: t, response: $e({ url: c.url, data: void 0 }, f), error: new Error(`HTTP Error ${f.code} ${f.text}`), networkDetails: m, stats: y })) }, onAbort: (f, p, m) => { e.stats.aborted = t.stats.aborted, this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.INTERNAL_ABORTED, fatal: !1, frag: e, part: t, error: new Error('Aborted'), networkDetails: m, stats: f })) }, onTimeout: (f, p, m) => { this.resetLoader(e, u), l(new En({ type: J.NETWORK_ERROR, details: D.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, part: t, error: new Error(`Timeout after ${h.timeout}ms`), networkDetails: m, stats: f })) } }) }) }updateStatsFromPart (e, t) { const r = e.stats; const i = t.stats; const s = i.total; if (r.loaded += i.loaded, s) { const l = Math.round(e.duration / t.duration); const u = Math.min(Math.round(r.loaded / s), l); const d = (l - u) * Math.round(r.loaded / u); r.total = r.loaded + d } else r.total = Math.max(r.loaded, r.total); const o = r.loading; const a = i.loading; o.start ? o.first += a.first - a.start : (o.start = a.start, o.first = a.first), o.end = a.end }resetLoader (e, t) { e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy() }} function zp (n, e = null) { const t = e || n; const r = { frag: n, part: e, responseType: 'arraybuffer', url: t.url, headers: {}, rangeStart: 0, rangeEnd: 0 }; const i = t.byteRangeStartOffset; const s = t.byteRangeEndOffset; if (K(i) && K(s)) { let o; let a = i; let l = s; if (n.sn === 'initSegment' && ((o = n.decryptdata) == null ? void 0 : o.method) === 'AES-128') { const u = s - i; u % 16 && (l = s + (16 - u % 16)), i !== 0 && (r.resetIV = !0, a = i - 16) }r.rangeStart = a, r.rangeEnd = l } return r } function Wp (n, e) { const t = new Error(`GAP ${n.gap ? 'tag' : 'attribute'} found`); const r = { type: J.MEDIA_ERROR, details: D.FRAG_GAP, fatal: !1, frag: n, error: t, networkDetails: null }; return e && (r.part = e), (e || n).stats.aborted = !0, new En(r) } class En extends Error {constructor (e) { super(e.error.message), this.data = void 0, this.data = e }} class aC {constructor (e, t) { this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t }decrypt (e, t) { return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, t, e) }} class lC {constructor (e, t) { this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t }expandKey () { return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, !1, ['encrypt', 'decrypt']) }} function uC (n) { const e = n.byteLength; const t = e && new DataView(n.buffer).getUint8(e - 1); return t ? br(n, 0, e - t) : n } class cC {constructor () { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable() }uint8ArrayToUint32Array_ (e) { const t = new DataView(e); const r = new Uint32Array(4); for (let i = 0; i < 4; i++)r[i] = t.getUint32(i * 4); return r }initTable () { const e = this.sBox; const t = this.invSBox; const r = this.subMix; const i = r[0]; const s = r[1]; const o = r[2]; const a = r[3]; const l = this.invSubMix; const u = l[0]; const c = l[1]; const d = l[2]; const h = l[3]; const f = new Uint32Array(256); let p = 0; let m = 0; let y = 0; for (y = 0; y < 256; y++)y < 128 ? f[y] = y << 1 : f[y] = y << 1 ^ 283; for (y = 0; y < 256; y++) { let g = m ^ m << 1 ^ m << 2 ^ m << 3 ^ m << 4; g = g >>> 8 ^ g & 255 ^ 99, e[p] = g, t[g] = p; const v = f[p]; const E = f[v]; const x = f[E]; let T = f[g] * 257 ^ g * 16843008; i[p] = T << 24 | T >>> 8, s[p] = T << 16 | T >>> 16, o[p] = T << 8 | T >>> 24, a[p] = T, T = x * 16843009 ^ E * 65537 ^ v * 257 ^ p * 16843008, u[g] = T << 24 | T >>> 8, c[g] = T << 16 | T >>> 16, d[g] = T << 8 | T >>> 24, h[g] = T, p ? (p = v ^ f[f[f[x ^ v]]], m ^= f[f[m]]) : p = m = 1 } }expandKey (e) { const t = this.uint8ArrayToUint32Array_(e); let r = !0; let i = 0; for (;i < t.length && r;)r = t[i] === this.key[i], i++; if (r) return; this.key = t; const s = this.keySize = t.length; if (s !== 4 && s !== 6 && s !== 8) throw new Error('Invalid aes key size=' + s); const o = this.ksRows = (s + 6 + 1) * 4; let a, l; const u = this.keySchedule = new Uint32Array(o); const c = this.invKeySchedule = new Uint32Array(o); const d = this.sBox; const h = this.rcon; const f = this.invSubMix; const p = f[0]; const m = f[1]; const y = f[2]; const g = f[3]; let v, E; for (a = 0; a < o; a++) { if (a < s) { v = u[a] = t[a]; continue }E = v, a % s === 0 ? (E = E << 8 | E >>> 24, E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255], E ^= h[a / s | 0] << 24) : s > 6 && a % s === 4 && (E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255]), u[a] = v = (u[a - s] ^ E) >>> 0 } for (l = 0; l < o; l++)a = o - l, l & 3 ? E = u[a] : E = u[a - 4], l < 4 || a <= 4 ? c[l] = E : c[l] = p[d[E >>> 24]] ^ m[d[E >>> 16 & 255]] ^ y[d[E >>> 8 & 255]] ^ g[d[E & 255]], c[l] = c[l] >>> 0 }networkToHostOrderSwap (e) { return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24 }decrypt (e, t, r) { const i = this.keySize + 6; const s = this.invKeySchedule; const o = this.invSBox; const a = this.invSubMix; const l = a[0]; const u = a[1]; const c = a[2]; const d = a[3]; const h = this.uint8ArrayToUint32Array_(r); let f = h[0]; let p = h[1]; let m = h[2]; let y = h[3]; const g = new Int32Array(e); const v = new Int32Array(g.length); let E, x, T, w, L, A, P, _, F, $, G, W, Z, Y; const re = this.networkToHostOrderSwap; for (;t < g.length;) { for (F = re(g[t]), $ = re(g[t + 1]), G = re(g[t + 2]), W = re(g[t + 3]), L = F ^ s[0], A = W ^ s[1], P = G ^ s[2], _ = $ ^ s[3], Z = 4, Y = 1; Y < i; Y++)E = l[L >>> 24] ^ u[A >> 16 & 255] ^ c[P >> 8 & 255] ^ d[_ & 255] ^ s[Z], x = l[A >>> 24] ^ u[P >> 16 & 255] ^ c[_ >> 8 & 255] ^ d[L & 255] ^ s[Z + 1], T = l[P >>> 24] ^ u[_ >> 16 & 255] ^ c[L >> 8 & 255] ^ d[A & 255] ^ s[Z + 2], w = l[_ >>> 24] ^ u[L >> 16 & 255] ^ c[A >> 8 & 255] ^ d[P & 255] ^ s[Z + 3], L = E, A = x, P = T, _ = w, Z = Z + 4; E = o[L >>> 24] << 24 ^ o[A >> 16 & 255] << 16 ^ o[P >> 8 & 255] << 8 ^ o[_ & 255] ^ s[Z], x = o[A >>> 24] << 24 ^ o[P >> 16 & 255] << 16 ^ o[_ >> 8 & 255] << 8 ^ o[L & 255] ^ s[Z + 1], T = o[P >>> 24] << 24 ^ o[_ >> 16 & 255] << 16 ^ o[L >> 8 & 255] << 8 ^ o[A & 255] ^ s[Z + 2], w = o[_ >>> 24] << 24 ^ o[L >> 16 & 255] << 16 ^ o[A >> 8 & 255] << 8 ^ o[P & 255] ^ s[Z + 3], v[t] = re(E ^ f), v[t + 1] = re(w ^ p), v[t + 2] = re(T ^ m), v[t + 3] = re(x ^ y), f = F, p = $, m = G, y = W, t = t + 4 } return v.buffer }} const dC = 16; class wh {constructor (e, { removePKCS7Padding: t = !0 } = {}) { if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try { const r = self.crypto; r && (this.subtle = r.subtle || r.webkitSubtle) } catch {} this.subtle === null && (this.useSoftware = !0) }destroy () { this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null }isSync () { return this.useSoftware }flush () { const { currentResult: e, remainderData: t } = this; if (!e || t) return this.reset(), null; const r = new Uint8Array(e); return this.reset(), this.removePKCS7Padding ? uC(r) : r }reset () { this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null) }decrypt (e, t, r) { return this.useSoftware ? new Promise((i, s) => { this.softwareDecrypt(new Uint8Array(e), t, r); const o = this.flush(); o ? i(o.buffer) : s(new Error('[softwareDecrypt] Failed to decrypt data')) }) : this.webCryptoDecrypt(new Uint8Array(e), t, r) }softwareDecrypt (e, t, r) { const { currentIV: i, currentResult: s, remainderData: o } = this; this.logOnce('JS AES decrypt'), o && (e = $t(o, e), this.remainderData = null); const a = this.getValidChunk(e); if (!a.length) return null; i && (r = i); let l = this.softwareDecrypter; l || (l = this.softwareDecrypter = new cC()), l.expandKey(t); const u = s; return this.currentResult = l.decrypt(a.buffer, 0, r), this.currentIV = br(a, -16).buffer, u || null }webCryptoDecrypt (e, t, r) { const i = this.subtle; return (this.key !== t || !this.fastAesKey) && (this.key = t, this.fastAesKey = new lC(i, t)), this.fastAesKey.expandKey().then(s => i ? (this.logOnce('WebCrypto AES decrypt'), new aC(i, new Uint8Array(r)).decrypt(e.buffer, s)) : Promise.reject(new Error('web crypto not initialized'))).catch(s => (C.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`), this.onWebCryptoError(e, t, r))) }onWebCryptoError (e, t, r) { this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r); const i = this.flush(); if (i) return i.buffer; throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data') }getValidChunk (e) { let t = e; const r = e.length - e.length % dC; return r !== e.length && (t = br(e, 0, r), this.remainderData = br(e, r)), t }logOnce (e) { this.logEnabled && (C.log(`[decrypter]: ${e}`), this.logEnabled = !1) }} const hC = { toString: function (n) { let e = ''; const t = n.length; for (let r = 0; r < t; r++)e += `[${n.start(r).toFixed(3)}-${n.end(r).toFixed(3)}]`; return e } }; const O = { STOPPED: 'STOPPED', IDLE: 'IDLE', KEY_LOADING: 'KEY_LOADING', FRAG_LOADING: 'FRAG_LOADING', FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY', WAITING_TRACK: 'WAITING_TRACK', PARSING: 'PARSING', PARSED: 'PARSED', ENDED: 'ENDED', ERROR: 'ERROR', WAITING_INIT_PTS: 'WAITING_INIT_PTS', WAITING_LEVEL: 'WAITING_LEVEL' }; class Ch extends Zw {constructor (e, t, r, i, s) { super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = O.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = '', this.log = void 0, this.warn = void 0, this.playlistType = s, this.logPrefix = i, this.log = C.log.bind(C, `${i}:`), this.warn = C.warn.bind(C, `${i}:`), this.hls = e, this.fragmentLoader = new oC(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new wh(e.config), e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this) }doTick () { this.onTickEnd() }onTickEnd () {}startLoad (e) {}stopLoad () { this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType); const e = this.fragCurrent; e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = O.STOPPED }_streamEnded (e, t) { if (t.live || e.nextStart || !e.end || !this.media) return !1; const r = t.partList; if (r != null && r.length) { const s = r[r.length - 1]; return de.isBuffered(this.media, s.start + s.duration / 2) } const i = t.fragments[t.fragments.length - 1].type; return this.fragmentTracker.isEndListAppended(i) }getLevelDetails () { if (this.levels && this.levelLastLoaded !== null) { let e; return (e = this.levelLastLoaded) == null ? void 0 : e.details } }onMediaAttached (e, t) { const r = this.media = this.mediaBuffer = t.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener('seeking', this.onvseeking), r.addEventListener('ended', this.onvended); const i = this.config; this.levels && i.autoStartLoad && this.state === O.STOPPED && this.startLoad(i.startPosition) }onMediaDetaching () { const e = this.media; e != null && e.ended && (this.log('MSE detaching and video ended, reset startPosition'), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener('seeking', this.onvseeking), e.removeEventListener('ended', this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() }onMediaSeeking () { const { config: e, fragCurrent: t, media: r, mediaBuffer: i, state: s } = this; const o = r ? r.currentTime : 0; const a = de.bufferInfo(i || r, o, e.maxBufferHole); if (this.log(`media seeking to ${K(o) ? o.toFixed(3) : o}, state: ${s}`), this.state === O.ENDED) this.resetLoadingState(); else if (t) { const l = e.maxFragLookUpTolerance; const u = t.start - l; const c = t.start + t.duration + l; if (!a.len || c < a.start || u > a.end) { const d = o > c; (o < u || d) && (d && t.loader && (this.log('seeking outside of buffer while fragment load in progress, cancel fragment load'), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null) } }r && (this.fragmentTracker.removeFragmentsInRange(o, 1 / 0, this.playlistType, !0), this.lastCurrentTime = o), !this.loadedmetadata && !a.len && (this.nextLoadPosition = this.startPosition = o), this.tickImmediate() }onMediaEnded () { this.startPosition = this.lastCurrentTime = 0 }onManifestLoaded (e, t) { this.startTimeOffset = t.startTimeOffset, this.initPTS = [] }onHandlerDestroying () { this.hls.off(S.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), super.onHandlerDestroying(), this.hls = null }onHandlerDestroyed () { this.state = O.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed() }loadFragment (e, t, r) { this._loadFragForPlayback(e, t, r) }_loadFragForPlayback (e, t, r) { const i = s => { if (this.fragContextChanged(e)) { this.warn(`Fragment ${e.sn}${s.part ? ' p: ' + s.part.index : ''} of level ${e.level} was dropped during download.`), this.fragmentTracker.removeFragment(e); return }e.stats.chunkCount++, this._handleFragmentLoadProgress(s) }; this._doFragLoad(e, t, r, i).then(s => { if (!s) return; const o = this.state; if (this.fragContextChanged(e)) { (o === O.FRAG_LOADING || !this.fragCurrent && o === O.PARSING) && (this.fragmentTracker.removeFragment(e), this.state = O.IDLE); return }'payload' in s && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(S.FRAG_LOADED, s)), this._handleFragmentLoadComplete(s) }).catch(s => { this.state === O.STOPPED || this.state === O.ERROR || (this.warn(s), this.resetFragmentLoading(e)) }) }clearTrackerIfNeeded (e) { let t; const { fragmentTracker: r } = this; if (r.getState(e) === Ue.APPENDING) { const s = e.type; const o = this.getFwdBufferInfo(this.mediaBuffer, s); const a = Math.max(e.duration, o ? o.len : this.config.maxBufferLength); this.reduceMaxBufferLength(a) && r.removeFragment(e) } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), r.getState(e) === Ue.PARTIAL && r.removeFragment(e)) }checkLiveUpdate (e) { if (e.updated && !e.live) { const t = e.fragments[e.fragments.length - 1]; this.fragmentTracker.detectPartialFragments({ frag: t, part: null, stats: t.stats, id: t.type }) }e.fragments[0] || (e.deltaUpdateFailed = !0) }flushMainBuffer (e, t, r = null) { if (!(e - t)) return; const i = { startOffset: e, endOffset: t, type: r }; this.hls.trigger(S.BUFFER_FLUSHING, i) }_loadInitSegment (e, t) { this._doFragLoad(e, t).then(r => { if (!r || this.fragContextChanged(e) || !this.levels) throw new Error('init load aborted'); return r }).then(r => { const { hls: i } = this; const { payload: s } = r; const o = e.decryptdata; if (s && s.byteLength > 0 && o != null && o.key && o.iv && o.method === 'AES-128') { const a = self.performance.now(); return this.decrypter.decrypt(new Uint8Array(s), o.key.buffer, o.iv.buffer).catch(l => { throw i.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_DECRYPT_ERROR, fatal: !1, error: l, reason: l.message, frag: e }), l }).then(l => { const u = self.performance.now(); return i.trigger(S.FRAG_DECRYPTED, { frag: e, payload: l, stats: { tstart: a, tdecrypt: u } }), r.payload = l, this.completeInitSegmentLoad(r) }) } return this.completeInitSegmentLoad(r) }).catch(r => { this.state === O.STOPPED || this.state === O.ERROR || (this.warn(r), this.resetFragmentLoading(e)) }) }completeInitSegmentLoad (e) { const { levels: t } = this; if (!t) throw new Error('init load aborted, missing levels'); const r = e.frag.stats; this.state = O.IDLE, e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick() }fragContextChanged (e) { const { fragCurrent: t } = this; return !e || !t || e.sn !== t.sn || e.level !== t.level }fragBufferedComplete (e, t) { let r, i, s, o; const a = this.mediaBuffer ? this.mediaBuffer : this.media; if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? ' part: ' + t.index : ''} of ${this.playlistType === X.MAIN ? 'level' : 'track'} ${e.level} (frag:[${((r = e.startPTS) != null ? r : NaN).toFixed(3)}-${((i = e.endPTS) != null ? i : NaN).toFixed(3)}] > buffer:${a ? hC.toString(de.getBuffered(a)) : '(detached)'})`), e.sn !== 'initSegment') { let l; if (e.type !== X.SUBTITLE) { const c = e.elementaryStreams; if (!Object.keys(c).some(d => !!c[d])) { this.state = O.IDLE; return } } const u = (l = this.levels) == null ? void 0 : l[e.level]; u != null && u.fragmentError && (this.log(`Resetting level fragment error count of ${u.fragmentError} on frag buffered`), u.fragmentError = 0) } this.state = O.IDLE, a && (!this.loadedmetadata && e.type == X.MAIN && a.buffered.length && ((s = this.fragCurrent) == null ? void 0 : s.sn) === ((o = this.fragPrevious) == null ? void 0 : o.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick()) }seekToStartPos () {}_handleFragmentLoadComplete (e) { const { transmuxer: t } = this; if (!t) return; const { frag: r, part: i, partsLoaded: s } = e; const o = !s || s.length === 0 || s.some(l => !l); const a = new Ah(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !o); t.flush(a) }_handleFragmentLoadProgress (e) {}_doFragLoad (e, t, r = null, i) { let s; const o = t == null ? void 0 : t.details; if (!this.levels || !o) throw new Error(`frag load aborted, missing level${o ? '' : ' detail'}s`); let a = null; if (e.encrypted && !((s = e.decryptdata) != null && s.key) ? (this.log(`Loading key for ${e.sn} of [${o.startSN}-${o.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${e.level}`), this.state = O.KEY_LOADING, this.fragCurrent = e, a = this.keyLoader.load(e).then(c => { if (!this.fragContextChanged(c.frag)) return this.hls.trigger(S.KEY_LOADED, c), this.state === O.KEY_LOADING && (this.state = O.IDLE), c }), this.hls.trigger(S.KEY_LOADING, { frag: e }), this.fragCurrent === null && (a = Promise.reject(new Error('frag load aborted, context changed in KEY_LOADING')))) : !e.encrypted && o.encryptedFragments.length && this.keyLoader.loadClear(e, o.encryptedFragments), r = Math.max(e.start, r || 0), this.config.lowLatencyMode && e.sn !== 'initSegment') { const c = o.partList; if (c && i) { r > e.end && o.fragmentHint && (e = o.fragmentHint); const d = this.getNextPart(c, e, r); if (d > -1) { const h = c[d]; this.log(`Loading part sn: ${e.sn} p: ${h.index} cc: ${e.cc} of playlist [${o.startSN}-${o.endSN}] parts [0-${d}-${c.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${e.level}, target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = h.start + h.duration, this.state = O.FRAG_LOADING; let f; return a ? f = a.then(p => !p || this.fragContextChanged(p.frag) ? null : this.doFragPartsLoad(e, h, t, i)).catch(p => this.handleFragLoadError(p)) : f = this.doFragPartsLoad(e, h, t, i).catch(p => this.handleFragLoadError(p)), this.hls.trigger(S.FRAG_LOADING, { frag: e, part: h, targetBufferTime: r }), this.fragCurrent === null ? Promise.reject(new Error('frag load aborted, context changed in FRAG_LOADING parts')) : f } else if (!e.url || this.loadedEndOfParts(c, r)) return Promise.resolve(null) } } this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${o ? 'of [' + o.startSN + '-' + o.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${e.level}, target: ${parseFloat(r.toFixed(3))}`), K(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = O.FRAG_LOADING; const l = this.config.progressive; let u; return l && a ? u = a.then(c => !c || this.fragContextChanged(c == null ? void 0 : c.frag) ? null : this.fragmentLoader.load(e, i)).catch(c => this.handleFragLoadError(c)) : u = Promise.all([this.fragmentLoader.load(e, l ? i : void 0), a]).then(([c]) => (!l && c && i && i(c), c)).catch(c => this.handleFragLoadError(c)), this.hls.trigger(S.FRAG_LOADING, { frag: e, targetBufferTime: r }), this.fragCurrent === null ? Promise.reject(new Error('frag load aborted, context changed in FRAG_LOADING')) : u }doFragPartsLoad (e, t, r, i) { return new Promise((s, o) => { let a; const l = []; const u = (a = r.details) == null ? void 0 : a.partList; const c = d => { this.fragmentLoader.loadPart(e, d, i).then(h => { l[d.index] = h; const f = h.part; this.hls.trigger(S.FRAG_LOADED, h); const p = Bp(r, e.sn, d.index + 1) || Ev(u, e.sn, d.index + 1); if (p)c(p); else return s({ frag: e, part: f, partsLoaded: l }) }).catch(o) }; c(t) }) }handleFragLoadError (e) { if ('data' in e) { const t = e.data; e.data && t.details === D.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(S.ERROR, t) } else this.hls.trigger(S.ERROR, { type: J.OTHER_ERROR, details: D.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 }); return null }_handleTransmuxerFlush (e) { const t = this.getCurrentContext(e); if (!t || this.state !== O.PARSING) { !this.fragCurrent && this.state !== O.STOPPED && this.state !== O.ERROR && (this.state = O.IDLE); return } const { frag: r, part: i, level: s } = t; const o = self.performance.now(); r.stats.parsing.end = o, i && (i.stats.parsing.end = o), this.updateLevelTiming(r, i, s, e.partial) }getCurrentContext (e) { const { levels: t, fragCurrent: r } = this; const { level: i, sn: s, part: o } = e; if (!(t != null && t[i])) return this.warn(`Levels object was unset while buffering fragment ${s} of level ${i}. The current chunk will not be buffered.`), null; const a = t[i]; const l = o > -1 ? Bp(a, s, o) : null; const u = l ? l.fragment : Fw(a, s, r); return u ? (r && r !== u && (u.stats = r.stats), { frag: u, part: l, level: a }) : null }bufferFragmentData (e, t, r, i, s) { let o; if (!e || this.state !== O.PARSING) return; const { data1: a, data2: l } = e; let u = a; if (a && l && (u = $t(a, l)), !((o = u) != null && o.length)) return; const c = { type: e.type, frag: t, part: r, chunkMeta: i, parent: t.type, data: u }; if (this.hls.trigger(S.BUFFER_APPENDING, c), e.dropped && e.independent && !r) { if (s) return; this.flushBufferGap(t) } }flushBufferGap (e) { const t = this.media; if (!t) return; if (!de.isBuffered(t, t.currentTime)) { this.flushMainBuffer(0, e.start); return } const r = t.currentTime; const i = de.bufferInfo(t, r, 0); const s = e.duration; const o = Math.min(this.config.maxFragLookUpTolerance * 2, s * 0.25); const a = Math.max(Math.min(e.start - o, i.end - o), r + o); e.start - a > o && this.flushMainBuffer(a, e.start) }getFwdBufferInfo (e, t) { const r = this.getLoadPosition(); return K(r) ? this.getFwdBufferInfoAtPos(e, r, t) : null }getFwdBufferInfoAtPos (e, t, r) { const { config: { maxBufferHole: i } } = this; const s = de.bufferInfo(e, t, i); if (s.len === 0 && s.nextStart !== void 0) { const o = this.fragmentTracker.getBufferedFrag(t, r); if (o && s.nextStart < o.end) return de.bufferInfo(e, t, Math.max(s.nextStart, i)) } return s }getMaxBufferLength (e) { const { config: t } = this; let r; return e ? r = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : r = t.maxBufferLength, Math.min(r, t.maxMaxBufferLength) }reduceMaxBufferLength (e) { const t = this.config; const r = e || t.maxBufferLength; return t.maxMaxBufferLength >= r ? (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0) : !1 }getAppendedFrag (e, t = X.MAIN) { const r = this.fragmentTracker.getAppendedFrag(e, X.MAIN); return r && 'fragment' in r ? r.fragment : r }getNextFragment (e, t) { const r = t.fragments; const i = r.length; if (!i) return null; const { config: s } = this; const o = r[0].start; let a; if (t.live) { const l = s.initialLiveManifestSize; if (i < l) return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${l})`), null; (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < o) && (a = this.getInitialLiveFragment(t, r), this.startPosition = this.nextLoadPosition = a ? this.hls.liveSyncPosition || a.start : e) } else e <= o && (a = r[0]); if (!a) { const l = s.lowLatencyMode ? t.partEnd : t.fragmentEnd; a = this.getFragmentAtPosition(e, l, t) } return this.mapToInitFragWhenRequired(a) }isLoopLoading (e, t) { const r = this.fragmentTracker.getState(e); return (r === Ue.OK || r === Ue.PARTIAL && !!e.gap) && this.nextLoadPosition > t }getNextFragmentLoopLoading (e, t, r, i, s) { const o = e.gap; const a = this.getNextFragment(this.nextLoadPosition, t); if (a === null) return a; if (e = a, o && e && !e.gap && r.nextStart) { const l = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, i); if (l !== null && r.len + l.len >= s) return this.log(`buffer full after gaps in "${i}" playlist starting at sn: ${e.sn}`), null } return e }mapToInitFragWhenRequired (e) { return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest ? e.initSegment : e }getNextPart (e, t, r) { let i = -1; let s = !1; let o = !0; for (let a = 0, l = e.length; a < l; a++) { const u = e[a]; if (o = o && !u.independent, i > -1 && r < u.start) break; const c = u.loaded; c ? i = -1 : (s || u.independent || o) && u.fragment === t && (i = a), s = c } return i }loadedEndOfParts (e, t) { const r = e[e.length - 1]; return r && t > r.start && r.loaded }getInitialLiveFragment (e, t) { const r = this.fragPrevious; let i = null; if (r) { if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), i = Nw(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) { const s = r.sn + 1; if (s >= e.startSN && s <= e.endSN) { const o = t[s - e.startSN]; r.cc === o.cc && (i = o, this.log(`Live playlist, switching playlist, load frag with next SN: ${i.sn}`)) }i || (i = Bw(t, r.cc), i && this.log(`Live playlist, switching playlist, load frag with same CC: ${i.sn}`)) } } else { const s = this.hls.liveSyncPosition; s !== null && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e)) } return i }getFragmentAtPosition (e, t, r) { const { config: i } = this; let { fragPrevious: s } = this; let { fragments: o, endSN: a } = r; const { fragmentHint: l } = r; const u = i.maxFragLookUpTolerance; const c = r.partList; const d = !!(i.lowLatencyMode && c != null && c.length && l); d && l && !this.bitrateTest && (o = o.concat(l), a = l.sn); let h; if (e < t) { const f = e > t - u ? 0 : u; h = nl(s, o, e, f) } else h = o[o.length - 1]; if (h) { const f = h.sn - r.startSN; const p = this.fragmentTracker.getState(h); if ((p === Ue.OK || p === Ue.PARTIAL && h.gap) && (s = h), s && h.sn === s.sn && (!d || c[0].fragment.sn > h.sn) && s && h.level === s.level) { const y = o[f + 1]; h.sn < a && this.fragmentTracker.getState(y) !== Ue.OK ? h = y : h = null } } return h }synchronizeToLiveEdge (e) { const { config: t, media: r } = this; if (!r) return; const i = this.hls.liveSyncPosition; const s = r.currentTime; const o = e.fragments[0].start; const a = e.edge; const l = s >= o - t.maxFragLookUpTolerance && s <= a; if (i !== null && r.duration > i && (s < i || !l)) { const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration; (!l && r.readyState < 4 || s < a - u) && (this.loadedmetadata || (this.nextLoadPosition = i), r.readyState && (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${i.toFixed(3)}`), r.currentTime = i)) } }alignPlaylists (e, t, r) { const i = e.fragments.length; if (!i) return this.warn('No fragments in live playlist'), 0; const s = e.fragments[0].start; const o = !t; const a = e.alignedSliding && K(s); if (o || !a && !s) { const { fragPrevious: l } = this; iC(l, r, e); const u = e.fragments[0].start; return this.log(`Live playlist sliding: ${u.toFixed(2)} start-sn: ${t ? t.startSN : 'na'}->${e.startSN} prev-sn: ${l ? l.sn : 'na'} fragments: ${i}`), u } return s }waitForCdnTuneIn (e) { return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3) }setStartPosition (e, t) { let r = this.startPosition; if (r < t && (r = -1), r === -1 || this.lastCurrentTime === -1) { const i = this.startTimeOffset !== null; const s = i ? this.startTimeOffset : e.startTimeOffset; s !== null && K(s) ? (r = t + s, s < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Start time offset ${s} found in ${i ? 'multivariant' : 'media'} playlist, adjust startPosition to ${r}`), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r } this.nextLoadPosition = r }getLoadPosition () { const { media: e } = this; let t = 0; return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t }handleFragLoadAborted (e, t) { this.transmuxer && e.sn !== 'initSegment' && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? ' part ' + t.index : ''} of level ${e.level} was aborted`), this.resetFragmentLoading(e)) }resetFragmentLoading (e) { (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== O.FRAG_LOADING_WAITING_RETRY) && (this.state = O.IDLE) }onFragmentOrKeyLoadError (e, t) { if (t.chunkMeta && !t.frag) { const c = this.getCurrentContext(t.chunkMeta); c && (t.frag = c.frag) } const r = t.frag; if (!r || r.type !== e || !this.levels) return; if (this.fragContextChanged(r)) { let i; this.warn(`Frag load error must match current frag to retry ${r.url} > ${(i = this.fragCurrent) == null ? void 0 : i.url}`); return } const s = t.details === D.FRAG_GAP; s && this.fragmentTracker.fragBuffered(r, !0); const o = t.errorAction; const { action: a, retryCount: l = 0, retryConfig: u } = o || {}; if (o && a === je.RetryRequest && u) { this.resetStartWhenNotLoaded(this.levelLastLoaded); const c = Lh(u, l); this.warn(`Fragment ${r.sn} of ${e} ${r.level} errored with ${t.details}, retrying loading ${l + 1}/${u.maxNumRetry} in ${c}ms`), o.resolved = !0, this.retryDate = self.performance.now() + c, this.state = O.FRAG_LOADING_WAITING_RETRY } else if (u && o) if (this.resetFragmentErrors(e), l < u.maxNumRetry)!s && a !== je.RemoveAlternatePermanently && (o.resolved = !0); else { C.warn(`${t.details} reached or exceeded max retry (${l})`); return } else (o == null ? void 0 : o.action) === je.SendAlternateToPenaltyBox ? this.state = O.WAITING_LEVEL : this.state = O.ERROR; this.tickImmediate() }reduceLengthAndFlushBuffer (e) { if (this.state === O.PARSING || this.state === O.PARSED) { const t = e.parent; const r = this.getFwdBufferInfo(this.mediaBuffer, t); const i = r && r.len > 0.5; i && this.reduceMaxBufferLength(r.len); const s = !i; return s && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), s } return !1 }resetFragmentErrors (e) { e === X.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== O.STOPPED && (this.state = O.IDLE) }afterBufferFlushed (e, t, r) { if (!e) return; const i = de.getBuffered(e); this.fragmentTracker.detectEvictedFragments(t, i, r), this.state === O.ENDED && this.resetLoadingState() }resetLoadingState () { this.log('Reset loading state'), this.fragCurrent = null, this.fragPrevious = null, this.state = O.IDLE }resetStartWhenNotLoaded (e) { if (!this.loadedmetadata) { this.startFragRequested = !1; const t = e ? e.details : null; t != null && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition } }resetWhenMissingContext (e) { this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState() }removeUnbufferedFrags (e = 0) { this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0) }updateLevelTiming (e, t, r, i) { let s; const o = r.details; if (!o) { this.warn('level.details undefined'); return } if (!Object.keys(e.elementaryStreams).reduce((l, u) => { const c = e.elementaryStreams[u]; if (c) { const d = c.endPTS - c.startPTS; if (d <= 0) return this.warn(`Could not parse fragment ${e.sn} ${u} duration reliably (${d})`), l || !1; const h = i ? 0 : yv(o, e, c.startPTS, c.endPTS, c.startDTS, c.endDTS); return this.hls.trigger(S.LEVEL_PTS_UPDATED, { details: o, level: r, drift: h, type: u, frag: e, start: c.startPTS, end: c.endPTS }), !0 } return l }, !1) && ((s = this.transmuxer) == null ? void 0 : s.error) === null) { const l = new Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`); if (r.fragmentError === 0 && (r.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(l.message), this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, fatal: !1, error: l, frag: e, reason: `Found no media in msn ${e.sn} of level "${r.url}"` }), !this.hls) return; this.resetTransmuxer() } this.state = O.PARSED, this.hls.trigger(S.FRAG_PARSED, { frag: e, part: t }) }resetTransmuxer () { this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null) }recoverWorkerError (e) { e.event === 'demuxerWorker' && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()) } set state (e) { const t = this._state; t !== e && (this._state = e, this.log(`${t}->${e}`)) } get state () { return this._state }} class Rv {constructor () { this.chunks = [], this.dataLength = 0 }push (e) { this.chunks.push(e), this.dataLength += e.length }flush () { const { chunks: e, dataLength: t } = this; let r; if (e.length)e.length === 1 ? r = e[0] : r = fC(e, t); else return new Uint8Array(0); return this.reset(), r }reset () { this.chunks.length = 0, this.dataLength = 0 }} function fC (n, e) { const t = new Uint8Array(e); let r = 0; for (let i = 0; i < n.length; i++) { const s = n[i]; t.set(s, r), r += s.length } return t } function pC () { return typeof __HLS_WORKER_BUNDLE__ === 'function' } function mC () { const n = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], { type: 'text/javascript' }); const e = self.URL.createObjectURL(n); return { worker: new self.Worker(e), objectURL: e } } function gC (n) { const e = new self.URL(n, self.location.href).href; return { worker: new self.Worker(e), scriptURL: e } } function an (n = '', e = 9e4) { return { type: n, id: -1, pid: -1, inputTimeScale: e, sequenceNumber: -1, samples: [], dropped: 0 } } class Ih {constructor () { this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null }resetInitSegment (e, t, r, i) { this._id3Track = { type: 'id3', id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 } }resetTimeStamp (e) { this.initPTS = e, this.resetContiguity() }resetContiguity () { this.basePTS = null, this.lastPTS = null, this.frameIndex = 0 }canParse (e, t) { return !1 }appendFrame (e, t, r) {}demux (e, t) { this.cachedData && (e = $t(this.cachedData, e), this.cachedData = null); let r = Zs(e, 0); let i = r ? r.length : 0; let s; const o = this._audioTrack; const a = this._id3Track; const l = r ? xh(r) : void 0; const u = e.length; for ((this.basePTS === null || this.frameIndex === 0 && K(l)) && (this.basePTS = yC(l, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: Yt.audioId3, duration: Number.POSITIVE_INFINITY }); i < u;) { if (this.canParse(e, i)) { const c = this.appendFrame(o, e, i); c ? (this.frameIndex++, this.lastPTS = c.sample.pts, i += c.length, s = i) : i = u } else $A(e, i) ? (r = Zs(e, i), a.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: Yt.audioId3, duration: Number.POSITIVE_INFINITY }), i += r.length, s = i) : i++; if (i === u && s !== u) { const c = br(e, s); this.cachedData ? this.cachedData = $t(this.cachedData, c) : this.cachedData = c } } return { audioTrack: o, videoTrack: an(), id3Track: a, textTrack: an() } }demuxSampleAes (e, t, r) { return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`)) }flush (e) { const t = this.cachedData; return t && (this.cachedData = null, this.demux(t, 0)), { audioTrack: this._audioTrack, videoTrack: an(), id3Track: this._id3Track, textTrack: an() } }destroy () {}} const yC = (n, e, t) => { if (K(n)) return n * 90; const r = t ? t.baseTime * 9e4 / t.timescale : 0; return e * 9e4 + r }; function vC (n, e, t, r) { let i, s, o, a; const l = navigator.userAgent.toLowerCase(); const u = r; const c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; i = ((e[t + 2] & 192) >>> 6) + 1; const d = (e[t + 2] & 60) >>> 2; if (d > c.length - 1) { const h = new Error(`invalid ADTS sampling index:${d}`); n.emit(S.ERROR, S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, fatal: !0, error: h, reason: h.message }); return } return o = (e[t + 2] & 1) << 2, o |= (e[t + 3] & 192) >>> 6, C.log(`manifest codec:${r}, ADTS type:${i}, samplingIndex:${d}`), /firefox/i.test(l) ? d >= 6 ? (i = 5, a = new Array(4), s = d - 3) : (i = 2, a = new Array(2), s = d) : l.indexOf('android') !== -1 ? (i = 2, a = new Array(2), s = d) : (i = 5, a = new Array(4), r && (r.indexOf('mp4a.40.29') !== -1 || r.indexOf('mp4a.40.5') !== -1) || !r && d >= 6 ? s = d - 3 : ((r && r.indexOf('mp4a.40.2') !== -1 && (d >= 6 && o === 1 || /vivaldi/i.test(l)) || !r && o === 1) && (i = 2, a = new Array(2)), s = d)), a[0] = i << 3, a[0] |= (d & 14) >> 1, a[1] |= (d & 1) << 7, a[1] |= o << 3, i === 5 && (a[1] |= (s & 14) >> 1, a[2] = (s & 1) << 7, a[2] |= 8, a[3] = 0), { config: a, samplerate: c[d], channelCount: o, codec: 'mp4a.40.' + i, manifestCodec: u } } function Av (n, e) { return n[e] === 255 && (n[e + 1] & 246) === 240 } function wv (n, e) { return n[e + 1] & 1 ? 7 : 9 } function _h (n, e) { return (n[e + 3] & 3) << 11 | n[e + 4] << 3 | (n[e + 5] & 224) >>> 5 } function EC (n, e) { return e + 5 < n.length } function il (n, e) { return e + 1 < n.length && Av(n, e) } function SC (n, e) { return EC(n, e) && Av(n, e) && _h(n, e) <= n.length - e } function TC (n, e) { if (il(n, e)) { const t = wv(n, e); if (e + t >= n.length) return !1; const r = _h(n, e); if (r <= t) return !1; const i = e + r; return i === n.length || il(n, i) } return !1 } function Cv (n, e, t, r, i) { if (!n.samplerate) { const s = vC(e, t, r, i); if (!s) return; n.config = s.config, n.samplerate = s.samplerate, n.channelCount = s.channelCount, n.codec = s.codec, n.manifestCodec = s.manifestCodec, C.log(`parsed codec:${n.codec}, rate:${s.samplerate}, channels:${s.channelCount}`) } } function Iv (n) { return 1024 * 9e4 / n } function xC (n, e) { const t = wv(n, e); if (e + t <= n.length) { const r = _h(n, e) - t; if (r > 0) return { headerLength: t, frameLength: r } } } function _v (n, e, t, r, i) { const s = Iv(n.samplerate); const o = r + i * s; const a = xC(e, t); let l; if (a) { const { frameLength: d, headerLength: h } = a; const f = h + d; const p = Math.max(0, t + f - e.length); p ? (l = new Uint8Array(f - h), l.set(e.subarray(t + h, e.length), 0)) : l = e.subarray(t + h, t + f); const m = { unit: l, pts: o }; return p || n.samples.push(m), { sample: m, length: f, missing: p } } const u = e.length - t; return l = new Uint8Array(u), l.set(e.subarray(t, e.length), 0), { sample: { unit: l, pts: o }, length: u, missing: -1 } } let Wo = null; const LC = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]; const RC = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3]; const AC = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]]; const wC = [0, 1, 1, 4]; function Dv (n, e, t, r, i) { if (t + 24 > e.length) return; const s = kv(e, t); if (s && t + s.frameLength <= e.length) { const o = s.samplesPerFrame * 9e4 / s.sampleRate; const a = r + i * o; const l = { unit: e.subarray(t, t + s.frameLength), pts: a, dts: a }; return n.config = [], n.channelCount = s.channelCount, n.samplerate = s.sampleRate, n.samples.push(l), { sample: l, length: s.frameLength, missing: 0 } } } function kv (n, e) { const t = n[e + 1] >> 3 & 3; const r = n[e + 1] >> 1 & 3; const i = n[e + 2] >> 4 & 15; const s = n[e + 2] >> 2 & 3; if (t !== 1 && i !== 0 && i !== 15 && s !== 3) { const o = n[e + 2] >> 1 & 1; const a = n[e + 3] >> 6; const l = t === 3 ? 3 - r : r === 3 ? 3 : 4; const u = LC[l * 14 + i - 1] * 1e3; const d = RC[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + s]; const h = a === 3 ? 1 : 2; const f = AC[t][r]; const p = wC[r]; const m = f * 8 * p; const y = Math.floor(f * u / d + o) * p; if (Wo === null) { const E = (navigator.userAgent || '').match(/Chrome\/(\d+)/i); Wo = E ? parseInt(E[1]) : 0 } return !!Wo && Wo <= 87 && r === 2 && u >= 224e3 && a === 0 && (n[e + 3] = n[e + 3] | 128), { sampleRate: d, channelCount: h, frameLength: y, samplesPerFrame: m } } } function Dh (n, e) { return n[e] === 255 && (n[e + 1] & 224) === 224 && (n[e + 1] & 6) !== 0 } function Pv (n, e) { return e + 1 < n.length && Dh(n, e) } function CC (n, e) { return Dh(n, e) && n.length - e >= 4 } function bv (n, e) { if (e + 1 < n.length && Dh(n, e)) { const r = kv(n, e); let i = 4; r != null && r.frameLength && (i = r.frameLength); const s = e + i; return s === n.length || Pv(n, s) } return !1 } class IC extends Ih {constructor (e, t) { super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t }resetInitSegment (e, t, r, i) { super.resetInitSegment(e, t, r, i), this._audioTrack = { container: 'audio/adts', type: 'audio', id: 2, pid: -1, sequenceNumber: 0, segmentCodec: 'aac', samples: [], manifestCodec: t, duration: i, inputTimeScale: 9e4, dropped: 0 } } static probe (e) { if (!e) return !1; const t = Zs(e, 0); let r = (t == null ? void 0 : t.length) || 0; if (bv(e, r)) return !1; for (let i = e.length; r < i; r++) if (TC(e, r)) return C.log('ADTS sync word found !'), !0; return !1 }canParse (e, t) { return SC(e, t) }appendFrame (e, t, r) { Cv(e, this.observer, t, r, e.manifestCodec); const i = _v(e, t, r, this.basePTS, this.frameIndex); if (i && i.missing === 0) return i }} const _C = /\/emsg[-/]ID3/i; class DC {constructor (e, t) { this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t }resetTimeStamp () {}resetInitSegment (e, t, r, i) { const s = this.videoTrack = an('video', 1); const o = this.audioTrack = an('audio', 1); const a = this.txtTrack = an('text', 1); if (this.id3Track = an('id3', 1), this.timeOffset = 0, !(e != null && e.byteLength)) return; const l = uv(e); if (l.video) { const { id: u, timescale: c, codec: d } = l.video; s.id = u, s.timescale = a.timescale = c, s.codec = d } if (l.audio) { const { id: u, timescale: c, codec: d } = l.audio; o.id = u, o.timescale = c, o.codec = d }a.id = ov.text, s.sampleDuration = 0, s.duration = o.duration = i }resetContiguity () { this.remainderData = null } static probe (e) { return qA(e) }demux (e, t) { this.timeOffset = t; let r = e; const i = this.videoTrack; const s = this.txtTrack; if (this.config.progressive) { this.remainderData && (r = $t(this.remainderData, e)); const a = rw(r); this.remainderData = a.remainder, i.samples = a.valid || new Uint8Array() } else i.samples = r; const o = this.extractID3Track(i, t); return s.samples = Sp(t, i), { videoTrack: i, audioTrack: this.audioTrack, id3Track: o, textTrack: this.txtTrack } }flush () { const e = this.timeOffset; const t = this.videoTrack; const r = this.txtTrack; t.samples = this.remainderData || new Uint8Array(), this.remainderData = null; const i = this.extractID3Track(t, this.timeOffset); return r.samples = Sp(e, t), { videoTrack: t, audioTrack: an(), id3Track: i, textTrack: an() } }extractID3Track (e, t) { const r = this.id3Track; if (e.samples.length) { const i = ee(e.samples, ['emsg']); i && i.forEach(s => { const o = ow(s); if (_C.test(o.schemeIdUri)) { const a = K(o.presentationTime) ? o.presentationTime / o.timeScale : t + o.presentationTimeDelta / o.timeScale; let l = o.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : o.eventDuration / o.timeScale; l <= 0.001 && (l = Number.POSITIVE_INFINITY); const u = o.payload; r.samples.push({ data: u, len: u.byteLength, dts: a, pts: a, type: Yt.emsg, duration: l }) } }) } return r }demuxSampleAes (e, t, r) { return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption')) }destroy () {}} const Ov = (n, e) => { let t = 0; let r = 5; e += r; const i = new Uint32Array(1); const s = new Uint32Array(1); const o = new Uint8Array(1); for (;r > 0;) { o[0] = n[e]; const a = Math.min(r, 8); const l = 8 - a; s[0] = 4278190080 >>> 24 + l << l, i[0] = (o[0] & s[0]) >> l, t = t ? t << a | i[0] : i[0], e += 1, r -= a } return t }; class kC extends Ih {constructor (e) { super(), this.observer = void 0, this.observer = e }resetInitSegment (e, t, r, i) { super.resetInitSegment(e, t, r, i), this._audioTrack = { container: 'audio/ac-3', type: 'audio', id: 2, pid: -1, sequenceNumber: 0, segmentCodec: 'ac3', samples: [], manifestCodec: t, duration: i, inputTimeScale: 9e4, dropped: 0 } }canParse (e, t) { return t + 64 < e.length }appendFrame (e, t, r) { const i = Fv(e, t, r, this.basePTS, this.frameIndex); if (i !== -1) return { sample: e.samples[e.samples.length - 1], length: i, missing: 0 } } static probe (e) { if (!e) return !1; const t = Zs(e, 0); if (!t) return !1; const r = t.length; return e[r] === 11 && e[r + 1] === 119 && xh(t) !== void 0 && Ov(e, r) < 16 }} function Fv (n, e, t, r, i) { if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119) return -1; const s = e[t + 4] >> 6; if (s >= 3) return -1; const a = [48e3, 44100, 32e3][s]; const l = e[t + 4] & 63; const c = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][l * 3 + s] * 2; if (t + c > e.length) return -1; const d = e[t + 6] >> 5; let h = 0; d === 2 ? h += 2 : (d & 1 && d !== 1 && (h += 2), d & 4 && (h += 2)); const f = (e[t + 6] << 8 | e[t + 7]) >> 12 - h & 1; const m = [2, 1, 2, 3, 3, 4, 4, 5][d] + f; const y = e[t + 5] >> 3; const g = e[t + 5] & 7; const v = new Uint8Array([s << 6 | y << 1 | g >> 2, (g & 3) << 6 | d << 3 | f << 2 | l >> 4, l << 4 & 224]); const E = 1536 / a * 9e4; const x = r + i * E; const T = e.subarray(t, t + c); return n.config = v, n.channelCount = m, n.samplerate = a, n.samples.push({ unit: T, pts: x }), c } class PC {constructor () { this.VideoSample = null }createVideoSample (e, t, r, i) { return { key: e, frame: !1, pts: t, dts: r, units: [], debug: i, length: 0 } }getLastNalUnit (e) { let t; let r = this.VideoSample; let i; if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (t = r) != null && t.units) { const s = r.units; i = s[s.length - 1] } return i }pushAccessUnit (e, t) { if (e.units.length && e.frame) { if (e.pts === void 0) { const r = t.samples; const i = r.length; if (i) { const s = r[i - 1]; e.pts = s.pts, e.dts = s.dts } else { t.dropped++; return } }t.samples.push(e) }e.debug.length && C.log(e.pts + '/' + e.dts + ':' + e.debug) }} class Yp {constructor (e) { this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 }loadWord () { const e = this.data; const t = this.bytesAvailable; const r = e.byteLength - t; const i = new Uint8Array(4); const s = Math.min(4, t); if (s === 0) throw new Error('no bytes available'); i.set(e.subarray(r, r + s)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = s * 8, this.bytesAvailable -= s }skipBits (e) { let t; e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e) }readBits (e) { let t = Math.min(this.bitsAvailable, e); const r = this.word >>> 32 - t; if (e > 32 && C.error('Cannot read more than 32 bits at a time'), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else if (this.bytesAvailable > 0) this.loadWord(); else throw new Error('no bits available'); return t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r }skipLZ () { let e; for (e = 0; e < this.bitsAvailable; ++e) if (this.word & 2147483648 >>> e) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() }skipUEG () { this.skipBits(1 + this.skipLZ()) }skipEG () { this.skipBits(1 + this.skipLZ()) }readUEG () { const e = this.skipLZ(); return this.readBits(e + 1) - 1 }readEG () { const e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }readBoolean () { return this.readBits(1) === 1 }readUByte () { return this.readBits(8) }readUShort () { return this.readBits(16) }readUInt () { return this.readBits(32) }skipScalingList (e) { let t = 8; let r = 8; let i; for (let s = 0; s < e; s++)r !== 0 && (i = this.readEG(), r = (t + i + 256) % 256), t = r === 0 ? t : r }readSPS () { let e = 0; let t = 0; let r = 0; let i = 0; let s; let o; let a; const l = this.readUByte.bind(this); const u = this.readBits.bind(this); const c = this.readUEG.bind(this); const d = this.readBoolean.bind(this); const h = this.skipBits.bind(this); const f = this.skipEG.bind(this); const p = this.skipUEG.bind(this); const m = this.skipScalingList.bind(this); l(); const y = l(); if (u(5), h(3), l(), p(), y === 100 || y === 110 || y === 122 || y === 244 || y === 44 || y === 83 || y === 86 || y === 118 || y === 128) { const w = c(); if (w === 3 && h(1), p(), p(), h(1), d()) for (o = w !== 3 ? 8 : 12, a = 0; a < o; a++)d() && (a < 6 ? m(16) : m(64)) }p(); const g = c(); if (g === 0)c(); else if (g === 1) for (h(1), f(), f(), s = c(), a = 0; a < s; a++)f(); p(), h(1); const v = c(); const E = c(); const x = u(1); x === 0 && h(1), h(1), d() && (e = c(), t = c(), r = c(), i = c()); let T = [1, 1]; if (d() && d()) switch (l()) { case 1:T = [1, 1]; break; case 2:T = [12, 11]; break; case 3:T = [10, 11]; break; case 4:T = [16, 11]; break; case 5:T = [40, 33]; break; case 6:T = [24, 11]; break; case 7:T = [20, 11]; break; case 8:T = [32, 11]; break; case 9:T = [80, 33]; break; case 10:T = [18, 11]; break; case 11:T = [15, 11]; break; case 12:T = [64, 33]; break; case 13:T = [160, 99]; break; case 14:T = [4, 3]; break; case 15:T = [3, 2]; break; case 16:T = [2, 1]; break; case 255:{ T = [l() << 8 | l(), l() << 8 | l()]; break } } return { width: Math.ceil((v + 1) * 16 - e * 2 - t * 2), height: (2 - x) * (E + 1) * 16 - (x ? 2 : 4) * (r + i), pixelRatio: T } }readSliceType () { return this.readUByte(), this.readUEG(), this.readUEG() }} class bC extends PC {parseAVCPES (e, t, r, i, s) { const o = this.parseAVCNALu(e, r.data); let a = this.VideoSample; let l; let u = !1; r.data = null, a && o.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts, '')), o.forEach(c => { let d; switch (c.type) { case 1:{ let m = !1; l = !0; const y = c.data; if (u && y.length > 4) { const g = new Yp(y).readSliceType(); (g === 2 || g === 4 || g === 7 || g === 9) && (m = !0) } if (m) { let h; (h = a) != null && h.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null) }a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts, '')), a.frame = !0, a.key = m; break } case 5:l = !0, (d = a) != null && d.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts, '')), a.key = !0, a.frame = !0; break; case 6:{ l = !0, dv(c.data, 1, r.pts, t.samples); break } case 7:{ let f, p; l = !0, u = !0; const m = c.data; const g = new Yp(m).readSPS(); if (!e.sps || e.width !== g.width || e.height !== g.height || ((f = e.pixelRatio) == null ? void 0 : f[0]) !== g.pixelRatio[0] || ((p = e.pixelRatio) == null ? void 0 : p[1]) !== g.pixelRatio[1]) { e.width = g.width, e.height = g.height, e.pixelRatio = g.pixelRatio, e.sps = [m], e.duration = s; const v = m.subarray(1, 4); let E = 'avc1.'; for (let x = 0; x < 3; x++) { let T = v[x].toString(16); T.length < 2 && (T = '0' + T), E += T }e.codec = E } break } case 8:l = !0, e.pps = [c.data]; break; case 9:l = !0, e.audFound = !0, a && this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts, ''); break; case 12:l = !0; break; default:l = !1, a && (a.debug += 'unknown NAL ' + c.type + ' '); break }a && l && a.units.push(c) }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null) }parseAVCNALu (e, t) { const r = t.byteLength; let i = e.naluState || 0; const s = i; const o = []; let a = 0; let l; let u; let c; let d = -1; let h = 0; for (i === -1 && (d = 0, h = t[0] & 31, i = 0, a = 1); a < r;) { if (l = t[a++], !i) { i = l ? 0 : 1; continue } if (i === 1) { i = l ? 0 : 2; continue } if (!l)i = 3; else if (l === 1) { if (u = a - i - 1, d >= 0) { const f = { data: t.subarray(d, u), type: h }; o.push(f) } else { const f = this.getLastNalUnit(e.samples); f && (s && a <= 4 - s && f.state && (f.data = f.data.subarray(0, f.data.byteLength - s)), u > 0 && (f.data = $t(f.data, t.subarray(0, u)), f.state = 0)) }a < r ? (c = t[a] & 31, d = a, h = c, i = 0) : i = -1 } else i = 0 } if (d >= 0 && i >= 0) { const f = { data: t.subarray(d, r), type: h, state: i }; o.push(f) } if (o.length === 0) { const f = this.getLastNalUnit(e.samples); f && (f.data = $t(f.data, t)) } return e.naluState = i, o }} class OC {constructor (e, t, r) { this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new wh(t, { removePKCS7Padding: !1 }) }decryptBuffer (e) { return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer) }decryptAacSample (e, t, r) { const i = e[t].unit; if (i.length <= 16) return; const s = i.subarray(16, i.length - i.length % 16); const o = s.buffer.slice(s.byteOffset, s.byteOffset + s.length); this.decryptBuffer(o).then(a => { const l = new Uint8Array(a); i.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r) }) }decryptAacSamples (e, t, r) { for (;;t++) { if (t >= e.length) { r(); return } if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, r), !this.decrypter.isSync())) return } }getAvcEncryptedData (e) { const t = Math.floor((e.length - 48) / 160) * 16 + 16; const r = new Int8Array(t); let i = 0; for (let s = 32; s < e.length - 16; s += 160, i += 16)r.set(e.subarray(s, s + 16), i); return r }getAvcDecryptedUnit (e, t) { const r = new Uint8Array(t); let i = 0; for (let s = 32; s < e.length - 16; s += 160, i += 16)e.set(r.subarray(i, i + 16), s); return e }decryptAvcSample (e, t, r, i, s) { const o = hv(s.data); const a = this.getAvcEncryptedData(o); this.decryptBuffer(a.buffer).then(l => { s.data = this.getAvcDecryptedUnit(o, l), this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, i) }) }decryptAvcSamples (e, t, r, i) { if (e instanceof Uint8Array) throw new Error('Cannot decrypt samples of type Uint8Array'); for (;;t++, r = 0) { if (t >= e.length) { i(); return } const s = e[t].units; for (;!(r >= s.length); r++) { const o = s[r]; if (!(o.data.length <= 48 || o.type !== 1 && o.type !== 5) && (this.decryptAvcSample(e, t, r, i, o), !this.decrypter.isSync())) return } } }} const Me = 188; class Nn {constructor (e, t, r) { this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.videoParser = new bC() } static probe (e) { const t = Nn.syncOffset(e); return t > 0 && C.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), t !== -1 } static syncOffset (e) { const t = e.length; let r = Math.min(Me * 5, t - Me) + 1; let i = 0; for (;i < r;) { let s = !1; let o = -1; let a = 0; for (let l = i; l < t; l += Me) if (e[l] === 71 && (t - l === Me || e[l + Me] === 71)) { if (a++, o === -1 && (o = l, o !== 0 && (r = Math.min(o + Me * 99, e.length - Me) + 1)), s || (s = ed(e, l) === 0), s && a > 1 && (o === 0 && a > 2 || l + Me > r)) return o } else { if (a) return -1; break }i++ } return -1 } static createTrack (e, t) { return { container: e === 'video' || e === 'audio' ? 'video/mp2t' : void 0, type: e, id: ov[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: e === 'audio' ? t : void 0 } }resetInitSegment (e, t, r, i) { this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Nn.createTrack('video'), this._audioTrack = Nn.createTrack('audio', i), this._id3Track = Nn.createTrack('id3'), this._txtTrack = Nn.createTrack('text'), this._audioTrack.segmentCodec = 'aac', this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r, this._duration = i }resetTimeStamp () {}resetContiguity () { const { _audioTrack: e, _videoTrack: t, _id3Track: r } = this; e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null }demux (e, t, r = !1, i = !1) { r || (this.sampleAes = null); let s; const o = this._videoTrack; const a = this._audioTrack; const l = this._id3Track; const u = this._txtTrack; let c = o.pid; let d = o.pesData; let h = a.pid; let f = l.pid; let p = a.pesData; let m = l.pesData; let y = null; let g = this.pmtParsed; let v = this._pmtId; let E = e.length; if (this.remainderData && (e = $t(this.remainderData, e), E = e.length, this.remainderData = null), E < Me && !i) return this.remainderData = e, { audioTrack: a, videoTrack: o, id3Track: l, textTrack: u }; const x = Math.max(0, Nn.syncOffset(e)); E -= (E - x) % Me, E < e.byteLength && !i && (this.remainderData = new Uint8Array(e.buffer, E, e.buffer.byteLength - E)); let T = 0; for (let L = x; L < E; L += Me) if (e[L] === 71) { const A = !!(e[L + 1] & 64); const P = ed(e, L); const _ = (e[L + 3] & 48) >> 4; let F; if (_ > 1) { if (F = L + 5 + e[L + 4], F === L + Me) continue } else F = L + 4; switch (P) { case c:A && (d && (s = Xr(d)) && this.videoParser.parseAVCPES(o, u, s, !1, this._duration), d = { data: [], size: 0 }), d && (d.data.push(e.subarray(F, L + Me)), d.size += L + Me - F); break; case h:if (A) { if (p && (s = Xr(p))) switch (a.segmentCodec) { case 'aac':this.parseAACPES(a, s); break; case 'mp3':this.parseMPEGPES(a, s); break; case 'ac3':this.parseAC3PES(a, s); break }p = { data: [], size: 0 } }p && (p.data.push(e.subarray(F, L + Me)), p.size += L + Me - F); break; case f:A && (m && (s = Xr(m)) && this.parseID3PES(l, s), m = { data: [], size: 0 }), m && (m.data.push(e.subarray(F, L + Me)), m.size += L + Me - F); break; case 0:A && (F += e[F] + 1), v = this._pmtId = FC(e, F); break; case v:{ A && (F += e[F] + 1); const $ = MC(e, F, this.typeSupported, r); c = $.videoPid, c > 0 && (o.pid = c, o.segmentCodec = $.segmentVideoCodec), h = $.audioPid, h > 0 && (a.pid = h, a.segmentCodec = $.segmentAudioCodec), f = $.id3Pid, f > 0 && (l.pid = f), y !== null && !g && (C.warn(`MPEG-TS PMT found at ${L} after unknown PID '${y}'. Backtracking to sync byte @${x} to parse all TS packets.`), y = null, L = x - 188), g = this.pmtParsed = !0; break } case 17:case 8191:break; default:y = P; break } } else T++; if (T > 0) { const L = new Error(`Found ${T} TS packet/s that do not start with 0x47`); this.observer.emit(S.ERROR, S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, fatal: !1, error: L, reason: L.message }) }o.pesData = d, a.pesData = p, l.pesData = m; const w = { audioTrack: a, videoTrack: o, id3Track: l, textTrack: u }; return i && this.extractRemainingSamples(w), w }flush () { const { remainderData: e } = this; this.remainderData = null; let t; return e ? t = this.demux(e, -1, !1, !0) : t = { videoTrack: this._videoTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t }extractRemainingSamples (e) { const { audioTrack: t, videoTrack: r, id3Track: i, textTrack: s } = e; const o = r.pesData; const a = t.pesData; const l = i.pesData; let u; if (o && (u = Xr(o)) ? (this.videoParser.parseAVCPES(r, s, u, !0, this._duration), r.pesData = null) : r.pesData = o, a && (u = Xr(a))) { switch (t.segmentCodec) { case 'aac':this.parseAACPES(t, u); break; case 'mp3':this.parseMPEGPES(t, u); break; case 'ac3':this.parseAC3PES(t, u); break }t.pesData = null } else a != null && a.size && C.log('last AAC PES packet truncated,might overlap between fragments'), t.pesData = a; l && (u = Xr(l)) ? (this.parseID3PES(i, u), i.pesData = null) : i.pesData = l }demuxSampleAes (e, t, r) { const i = this.demux(e, r, !0, !this.config.progressive); const s = this.sampleAes = new OC(this.observer, this.config, t); return this.decrypt(i, s) }decrypt (e, t) { return new Promise(r => { const { audioTrack: i, videoTrack: s } = e; i.samples && i.segmentCodec === 'aac' ? t.decryptAacSamples(i.samples, 0, () => { s.samples ? t.decryptAvcSamples(s.samples, 0, 0, () => { r(e) }) : r(e) }) : s.samples && t.decryptAvcSamples(s.samples, 0, 0, () => { r(e) }) }) }destroy () { this._duration = 0 }parseAACPES (e, t) { let r = 0; const i = this.aacOverFlow; let s = t.data; if (i) { this.aacOverFlow = null; const d = i.missing; const h = i.sample.unit.byteLength; if (d === -1)s = $t(i.sample.unit, s); else { const f = h - d; i.sample.unit.set(s.subarray(0, d), f), e.samples.push(i.sample), r = i.missing } } let o, a; for (o = r, a = s.length; o < a - 1 && !il(s, o); o++);if (o !== r) { let d; const h = o < a - 1; h ? d = `AAC PES did not start with ADTS header,offset:${o}` : d = 'No ADTS header found in AAC PES'; const f = new Error(d); if (C.warn(`parsing error: ${d}`), this.observer.emit(S.ERROR, S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, fatal: !1, levelRetry: h, error: f, reason: d }), !h) return }Cv(e, this.observer, s, o, this.audioCodec); let l; if (t.pts !== void 0)l = t.pts; else if (i) { const d = Iv(e.samplerate); l = i.sample.pts + d } else { C.warn('[tsdemuxer]: AAC PES unknown PTS'); return } let u = 0; let c; for (;o < a;) if (c = _v(e, s, o, l, u), o += c.length, c.missing) { this.aacOverFlow = c; break } else for (u++; o < a - 1 && !il(s, o); o++); }parseMPEGPES (e, t) { const r = t.data; const i = r.length; let s = 0; let o = 0; const a = t.pts; if (a === void 0) { C.warn('[tsdemuxer]: MPEG PES unknown PTS'); return } for (;o < i;) if (Pv(r, o)) { const l = Dv(e, r, o, a, s); if (l)o += l.length, s++; else break } else o++ }parseAC3PES (e, t) { { const r = t.data; const i = t.pts; if (i === void 0) { C.warn('[tsdemuxer]: AC3 PES unknown PTS'); return } const s = r.length; let o = 0; let a = 0; let l; for (;a < s && (l = Fv(e, r, a, i, o++)) > 0;)a += l } }parseID3PES (e, t) { if (t.pts === void 0) { C.warn('[tsdemuxer]: ID3 PES unknown PTS'); return } const r = De({}, t, { type: this._videoTrack ? Yt.emsg : Yt.audioId3, duration: Number.POSITIVE_INFINITY }); e.samples.push(r) }} function ed (n, e) { return ((n[e + 1] & 31) << 8) + n[e + 2] } function FC (n, e) { return (n[e + 10] & 31) << 8 | n[e + 11] } function MC (n, e, t, r) { const i = { audioPid: -1, videoPid: -1, id3Pid: -1, segmentVideoCodec: 'avc', segmentAudioCodec: 'aac' }; const s = (n[e + 1] & 15) << 8 | n[e + 2]; const o = e + 3 + s - 4; const a = (n[e + 10] & 15) << 8 | n[e + 11]; for (e += 12 + a; e < o;) { const l = ed(n, e); const u = (n[e + 3] & 15) << 8 | n[e + 4]; switch (n[e]) { case 207:if (!r) { xu('ADTS AAC'); break } case 15:i.audioPid === -1 && (i.audioPid = l); break; case 21:i.id3Pid === -1 && (i.id3Pid = l); break; case 219:if (!r) { xu('H.264'); break } case 27:i.videoPid === -1 && (i.videoPid = l, i.segmentVideoCodec = 'avc'); break; case 3:case 4:!t.mpeg && !t.mp3 ? C.log('MPEG audio found, not supported in this browser') : i.audioPid === -1 && (i.audioPid = l, i.segmentAudioCodec = 'mp3'); break; case 193:if (!r) { xu('AC-3'); break } case 129:t.ac3 ? i.audioPid === -1 && (i.audioPid = l, i.segmentAudioCodec = 'ac3') : C.log('AC-3 audio found, not supported in this browser'); break; case 6:if (i.audioPid === -1 && u > 0) { let c = e + 5; let d = u; for (;d > 2;) { switch (n[c]) { case 106:t.ac3 !== !0 ? C.log('AC-3 audio found, not supported in this browser for now') : (i.audioPid = l, i.segmentAudioCodec = 'ac3'); break } const f = n[c + 1] + 2; c += f, d -= f } } break; case 194:case 135:C.warn('Unsupported EC-3 in M2TS found'); break; case 36:C.warn('Unsupported HEVC in M2TS found'); break }e += u + 5 } return i } function xu (n) { C.log(`${n} with AES-128-CBC encryption found in unencrypted stream`) } function Xr (n) { let e = 0; let t; let r; let i; let s; let o; const a = n.data; if (!n || n.size === 0) return null; for (;a[0].length < 19 && a.length > 1;)a[0] = $t(a[0], a[1]), a.splice(1, 1); if (t = a[0], (t[0] << 16) + (t[1] << 8) + t[2] === 1) { if (r = (t[4] << 8) + t[5], r && r > n.size - 6) return null; const u = t[7]; u & 192 && (s = (t[9] & 14) * 536870912 + (t[10] & 255) * 4194304 + (t[11] & 254) * 16384 + (t[12] & 255) * 128 + (t[13] & 254) / 2, u & 64 ? (o = (t[14] & 14) * 536870912 + (t[15] & 255) * 4194304 + (t[16] & 254) * 16384 + (t[17] & 255) * 128 + (t[18] & 254) / 2, s - o > 60 * 9e4 && (C.warn(`${Math.round((s - o) / 9e4)}s delta between PTS and DTS, align them`), s = o)) : o = s), i = t[8]; let c = i + 9; if (n.size <= c) return null; n.size -= c; const d = new Uint8Array(n.size); for (let h = 0, f = a.length; h < f; h++) { t = a[h]; let p = t.byteLength; if (c) if (c > p) { c -= p; continue } else t = t.subarray(c), p -= c, c = 0; d.set(t, e), e += p } return r && (r -= i + 3), { data: d, pts: s, dts: o, len: r } } return null } class NC extends Ih {resetInitSegment (e, t, r, i) { super.resetInitSegment(e, t, r, i), this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: 2, pid: -1, sequenceNumber: 0, segmentCodec: 'mp3', samples: [], manifestCodec: t, duration: i, inputTimeScale: 9e4, dropped: 0 } } static probe (e) { if (!e) return !1; const t = Zs(e, 0); let r = (t == null ? void 0 : t.length) || 0; if (t && e[r] === 11 && e[r + 1] === 119 && xh(t) !== void 0 && Ov(e, r) <= 16) return !1; for (let i = e.length; r < i; r++) if (bv(e, r)) return C.log('MPEG Audio sync word found !'), !0; return !1 }canParse (e, t) { return CC(e, t) }appendFrame (e, t, r) { if (this.basePTS !== null) return Dv(e, t, r, this.basePTS, this.frameIndex) }} class qp {static getSilentFrame (e, t) { switch (e) { case 'mp4a.40.2':if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (t === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (t === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); if (t === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); if (t === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]); break; default:if (t === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); break } }} const bn = Math.pow(2, 32) - 1; class I {static init () { I.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], '.mp3': [], dac3: [], 'ac-3': [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }; let e; for (e in I.types)I.types.hasOwnProperty(e) && (I.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]); const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); I.HDLR_TYPES = { video: t, audio: r }; const i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]); const s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); I.STTS = I.STSC = I.STCO = s, I.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), I.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), I.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), I.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); const o = new Uint8Array([105, 115, 111, 109]); const a = new Uint8Array([97, 118, 99, 49]); const l = new Uint8Array([0, 0, 0, 1]); I.FTYP = I.box(I.types.ftyp, o, l, o, a), I.DINF = I.box(I.types.dinf, I.box(I.types.dref, i)) } static box (e, ...t) { let r = 8; let i = t.length; const s = i; for (;i--;)r += t[i].byteLength; const o = new Uint8Array(r); for (o[0] = r >> 24 & 255, o[1] = r >> 16 & 255, o[2] = r >> 8 & 255, o[3] = r & 255, o.set(e, 4), i = 0, r = 8; i < s; i++)o.set(t[i], r), r += t[i].byteLength; return o } static hdlr (e) { return I.box(I.types.hdlr, I.HDLR_TYPES[e]) } static mdat (e) { return I.box(I.types.mdat, e) } static mdhd (e, t) { t *= e; const r = Math.floor(t / (bn + 1)); const i = Math.floor(t % (bn + 1)); return I.box(I.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, 85, 196, 0, 0])) } static mdia (e) { return I.box(I.types.mdia, I.mdhd(e.timescale, e.duration), I.hdlr(e.type), I.minf(e)) } static mfhd (e) { return I.box(I.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, e & 255])) } static minf (e) { return e.type === 'audio' ? I.box(I.types.minf, I.box(I.types.smhd, I.SMHD), I.DINF, I.stbl(e)) : I.box(I.types.minf, I.box(I.types.vmhd, I.VMHD), I.DINF, I.stbl(e)) } static moof (e, t, r) { return I.box(I.types.moof, I.mfhd(e), I.traf(r, t)) } static moov (e) { let t = e.length; const r = []; for (;t--;)r[t] = I.trak(e[t]); return I.box.apply(null, [I.types.moov, I.mvhd(e[0].timescale, e[0].duration)].concat(r).concat(I.mvex(e))) } static mvex (e) { let t = e.length; const r = []; for (;t--;)r[t] = I.trex(e[t]); return I.box.apply(null, [I.types.mvex, ...r]) } static mvhd (e, t) { t *= e; const r = Math.floor(t / (bn + 1)); const i = Math.floor(t % (bn + 1)); const s = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return I.box(I.types.mvhd, s) } static sdtp (e) { const t = e.samples || []; const r = new Uint8Array(4 + t.length); let i, s; for (i = 0; i < t.length; i++)s = t[i].flags, r[i + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy; return I.box(I.types.sdtp, r) } static stbl (e) { return I.box(I.types.stbl, I.stsd(e), I.box(I.types.stts, I.STTS), I.box(I.types.stsc, I.STSC), I.box(I.types.stsz, I.STSZ), I.box(I.types.stco, I.STCO)) } static avc1 (e) { let t = []; let r = []; let i; let s; let o; for (i = 0; i < e.sps.length; i++)s = e.sps[i], o = s.byteLength, t.push(o >>> 8 & 255), t.push(o & 255), t = t.concat(Array.prototype.slice.call(s)); for (i = 0; i < e.pps.length; i++)s = e.pps[i], o = s.byteLength, r.push(o >>> 8 & 255), r.push(o & 255), r = r.concat(Array.prototype.slice.call(s)); const a = I.box(I.types.avcC, new Uint8Array([1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(r))); const l = e.width; const u = e.height; const c = e.pixelRatio[0]; const d = e.pixelRatio[1]; return I.box(I.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, l & 255, u >> 8 & 255, u & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, I.box(I.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), I.box(I.types.pasp, new Uint8Array([c >> 24, c >> 16 & 255, c >> 8 & 255, c & 255, d >> 24, d >> 16 & 255, d >> 8 & 255, d & 255]))) } static esds (e) { const t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])) } static audioStsd (e) { const t = e.samplerate; return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, t & 255, 0, 0]) } static mp4a (e) { return I.box(I.types.mp4a, I.audioStsd(e), I.box(I.types.esds, I.esds(e))) } static mp3 (e) { return I.box(I.types['.mp3'], I.audioStsd(e)) } static ac3 (e) { return I.box(I.types['ac-3'], I.audioStsd(e), I.box(I.types.dac3, e.config)) } static stsd (e) { return e.type === 'audio' ? e.segmentCodec === 'mp3' && e.codec === 'mp3' ? I.box(I.types.stsd, I.STSD, I.mp3(e)) : e.segmentCodec === 'ac3' ? I.box(I.types.stsd, I.STSD, I.ac3(e)) : I.box(I.types.stsd, I.STSD, I.mp4a(e)) : I.box(I.types.stsd, I.STSD, I.avc1(e)) } static tkhd (e) { const t = e.id; const r = e.duration * e.timescale; const i = e.width; const s = e.height; const o = Math.floor(r / (bn + 1)); const a = Math.floor(r % (bn + 1)); return I.box(I.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i >> 8 & 255, i & 255, 0, 0, s >> 8 & 255, s & 255, 0, 0])) } static traf (e, t) { const r = I.sdtp(e); const i = e.id; const s = Math.floor(t / (bn + 1)); const o = Math.floor(t % (bn + 1)); return I.box(I.types.traf, I.box(I.types.tfhd, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255])), I.box(I.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255])), I.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8), r) } static trak (e) { return e.duration = e.duration || 4294967295, I.box(I.types.trak, I.tkhd(e), I.mdia(e)) } static trex (e) { const t = e.id; return I.box(I.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) } static trun (e, t) { const r = e.samples || []; const i = r.length; const s = 12 + 16 * i; const o = new Uint8Array(s); let a, l, u, c, d, h; for (t += 8 + s, o.set([e.type === 'video' ? 1 : 0, 0, 15, 1, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255], 0), a = 0; a < i; a++)l = r[a], u = l.duration, c = l.size, d = l.flags, h = l.cts, o.set([u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u & 255, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, c & 255, d.isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync, d.degradPrio & 61440, d.degradPrio & 15, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, h & 255], 12 + 16 * a); return I.box(I.types.trun, o) } static initSegment (e) { I.types || I.init(); const t = I.moov(e); return $t(I.FTYP, t) }}I.types = void 0; I.HDLR_TYPES = void 0; I.STTS = void 0; I.STSC = void 0; I.STCO = void 0; I.STSZ = void 0; I.VMHD = void 0; I.SMHD = void 0; I.STSD = void 0; I.FTYP = void 0; I.DINF = void 0; const Mv = 9e4; function kh (n, e, t = 1, r = !1) { const i = n * e * t; return r ? Math.round(i) : i } function UC (n, e, t = 1, r = !1) { return kh(n, e, 1 / t, r) } function ps (n, e = !1) { return kh(n, 1e3, 1 / Mv, e) } function BC (n, e = 1) { return kh(n, Mv, 1 / e) } const $C = 10 * 1e3; const Qp = 1024; const GC = 1152; const VC = 1536; let Jr = null; let Lu = null; class ga {constructor (e, t, r, i = '') { if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, Jr === null) { const o = (navigator.userAgent || '').match(/Chrome\/(\d+)/i); Jr = o ? parseInt(o[1]) : 0 } if (Lu === null) { const s = navigator.userAgent.match(/Safari\/(\d+)/i); Lu = s ? parseInt(s[1]) : 0 } }destroy () { this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null }resetTimeStamp (e) { C.log('[mp4-remuxer]: initPTS & initDTS reset'), this._initPTS = this._initDTS = e }resetNextTimestamp () { C.log('[mp4-remuxer]: reset next timestamp'), this.isVideoContiguous = !1, this.isAudioContiguous = !1 }resetInitSegment () { C.log('[mp4-remuxer]: ISGenerated flag reset'), this.ISGenerated = !1, this.videoTrackConfig = void 0 }getVideoStartPts (e) { let t = !1; const r = e.reduce((i, s) => { const o = s.pts - i; return o < -4294967296 ? (t = !0, bt(i, s.pts)) : o > 0 ? i : s.pts }, e[0].pts); return t && C.debug('PTS rollover detected'), r }remux (e, t, r, i, s, o, a, l) { let u; let c; let d; let h; let f; let p; let m = s; let y = s; const g = e.pid > -1; const v = t.pid > -1; const E = t.samples.length; const x = e.samples.length > 0; const T = a && E > 0 || E > 1; if ((!g || x) && (!v || T) || this.ISGenerated || a) { if (this.ISGenerated) { let L, A, P, _; const W = this.videoTrackConfig; W && (t.width !== W.width || t.height !== W.height || ((L = t.pixelRatio) == null ? void 0 : L[0]) !== ((A = W.pixelRatio) == null ? void 0 : A[0]) || ((P = t.pixelRatio) == null ? void 0 : P[1]) !== ((_ = W.pixelRatio) == null ? void 0 : _[1])) && this.resetInitSegment() } else d = this.generateIS(e, t, s, o); const F = this.isVideoContiguous; let $ = -1; let G; if (T && ($ = HC(t.samples), !F && this.config.forceKeyFrameOnDiscontinuity)) if (p = !0, $ > 0) { C.warn(`[mp4-remuxer]: Dropped ${$} out of ${E} video samples due to a missing keyframe`); const W = this.getVideoStartPts(t.samples); t.samples = t.samples.slice($), t.dropped += $, y += (t.samples[0].pts - W) / t.inputTimeScale, G = y } else $ === -1 && (C.warn(`[mp4-remuxer]: No keyframe found out of ${E} video samples`), p = !1); if (this.ISGenerated) { if (x && T) { const W = this.getVideoStartPts(t.samples); const Y = (bt(e.samples[0].pts, W) - W) / t.inputTimeScale; m += Math.max(0, Y), y += Math.max(0, -Y) } if (x) { if (e.samplerate || (C.warn('[mp4-remuxer]: regenerate InitSegment as audio detected'), d = this.generateIS(e, t, s, o)), c = this.remuxAudio(e, m, this.isAudioContiguous, o, v || T || l === X.AUDIO ? y : void 0), T) { const W = c ? c.endPTS - c.startPTS : 0; t.inputTimeScale || (C.warn('[mp4-remuxer]: regenerate InitSegment as video detected'), d = this.generateIS(e, t, s, o)), u = this.remuxVideo(t, y, F, W) } } else T && (u = this.remuxVideo(t, y, F, 0)); u && (u.firstKeyFrame = $, u.independent = $ !== -1, u.firstKeyFramePTS = G) } } return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (f = Nv(r, s, this._initPTS, this._initDTS)), i.samples.length && (h = Uv(i, s, this._initPTS))), { audio: c, video: u, initSegment: d, independent: p, text: h, id3: f } }generateIS (e, t, r, i) { const s = e.samples; const o = t.samples; const a = this.typeSupported; const l = {}; const u = this._initPTS; let c = !u || i; let d = 'audio/mp4'; let h; let f; let p; if (c && (h = f = 1 / 0), e.config && s.length) { switch (e.timescale = e.samplerate, e.segmentCodec) { case 'mp3':a.mpeg ? (d = 'audio/mpeg', e.codec = '') : a.mp3 && (e.codec = 'mp3'); break; case 'ac3':e.codec = 'ac-3'; break }l.audio = { id: 'audio', container: d, codec: e.codec, initSegment: e.segmentCodec === 'mp3' && a.mpeg ? new Uint8Array(0) : I.initSegment([e]), metadata: { channelCount: e.channelCount } }, c && (p = e.inputTimeScale, !u || p !== u.timescale ? h = f = s[0].pts - Math.round(p * r) : c = !1) } if (t.sps && t.pps && o.length) { if (t.timescale = t.inputTimeScale, l.video = { id: 'main', container: 'video/mp4', codec: t.codec, initSegment: I.initSegment([t]), metadata: { width: t.width, height: t.height } }, c) if (p = t.inputTimeScale, !u || p !== u.timescale) { const m = this.getVideoStartPts(o); const y = Math.round(p * r); f = Math.min(f, bt(o[0].dts, m) - y), h = Math.min(h, m - y) } else c = !1; this.videoTrackConfig = { width: t.width, height: t.height, pixelRatio: t.pixelRatio } } if (Object.keys(l).length) return this.ISGenerated = !0, c ? (this._initPTS = { baseTime: h, timescale: p }, this._initDTS = { baseTime: f, timescale: p }) : h = p = void 0, { tracks: l, initPTS: h, timescale: p } }remuxVideo (e, t, r, i) { const s = e.inputTimeScale; const o = e.samples; const a = []; const l = o.length; const u = this._initPTS; let c = this.nextAvcDts; let d = 8; let h = this.videoSampleDuration; let f; let p; let m = Number.POSITIVE_INFINITY; let y = Number.NEGATIVE_INFINITY; let g = !1; if (!r || c === null) { const M = t * s; const b = o[0].pts - bt(o[0].dts, o[0].pts); Jr && c !== null && Math.abs(M - b - c) < 15e3 ? r = !0 : c = M - b } const v = u.baseTime * s / u.timescale; for (let M = 0; M < l; M++) { const b = o[M]; b.pts = bt(b.pts - v, c), b.dts = bt(b.dts - v, c), b.dts < o[M > 0 ? M - 1 : M].dts && (g = !0) }g && o.sort(function (M, b) { const q = M.dts - b.dts; const z = M.pts - b.pts; return q || z }), f = o[0].dts, p = o[o.length - 1].dts; const E = p - f; const x = E ? Math.round(E / (l - 1)) : h || e.inputTimeScale / 30; if (r) { const M = f - c; const b = M > x; const q = M < -1; if ((b || q) && (b ? C.warn(`AVC: ${ps(M, !0)} ms (${M}dts) hole between fragments detected at ${t.toFixed(3)}`) : C.warn(`AVC: ${ps(-M, !0)} ms (${M}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !q || c >= o[0].pts || Jr)) { f = c; const z = o[0].pts - M; if (b)o[0].dts = f, o[0].pts = z; else for (let ie = 0; ie < o.length && !(o[ie].dts > z); ie++)o[ie].dts -= M, o[ie].pts -= M; C.log(`Video: Initial PTS/DTS adjusted: ${ps(z, !0)}/${ps(f, !0)}, delta: ${ps(M, !0)} ms`) } }f = Math.max(0, f); let T = 0; let w = 0; let L = f; for (let M = 0; M < l; M++) { const b = o[M]; const q = b.units; const z = q.length; let ie = 0; for (let ue = 0; ue < z; ue++)ie += q[ue].data.length; w += ie, T += z, b.length = ie, b.dts < L ? (b.dts = L, L += x / 4 | 0 || 1) : L = b.dts, m = Math.min(b.pts, m), y = Math.max(b.pts, y) }p = o[l - 1].dts; const A = w + 4 * T + 8; let P; try { P = new Uint8Array(A) } catch (M) { this.observer.emit(S.ERROR, S.ERROR, { type: J.MUX_ERROR, details: D.REMUX_ALLOC_ERROR, fatal: !1, error: M, bytes: A, reason: `fail allocating video mdat ${A}` }); return } const _ = new DataView(P.buffer); _.setUint32(0, A), P.set(I.types.mdat, 4); let F = !1; let $ = Number.POSITIVE_INFINITY; let G = Number.POSITIVE_INFINITY; let W = Number.NEGATIVE_INFINITY; let Z = Number.NEGATIVE_INFINITY; for (let M = 0; M < l; M++) { const b = o[M]; const q = b.units; let z = 0; for (let xe = 0, fe = q.length; xe < fe; xe++) { const Ge = q[xe]; const rs = Ge.data; const Dl = Ge.data.byteLength; _.setUint32(d, Dl), d += 4, P.set(rs, d), d += Dl, z += 4 + Dl } let ie; if (M < l - 1)h = o[M + 1].dts - b.dts, ie = o[M + 1].pts - b.pts; else { const xe = this.config; const fe = M > 0 ? b.dts - o[M - 1].dts : x; if (ie = M > 0 ? b.pts - o[M - 1].pts : x, xe.stretchShortVideoTrack && this.nextAudioPts !== null) { const Ge = Math.floor(xe.maxBufferHole * s); const rs = (i ? m + i * s : this.nextAudioPts) - b.pts; rs > Ge ? (h = rs - fe, h < 0 ? h = fe : F = !0, C.log(`[mp4-remuxer]: It is approximately ${rs / 90} ms to the next segment; using duration ${h / 90} ms for the last video frame.`)) : h = fe } else h = fe } const ue = Math.round(b.pts - b.dts); $ = Math.min($, h), W = Math.max(W, h), G = Math.min(G, ie), Z = Math.max(Z, ie), a.push(new Xp(b.key, h, z, ue)) } if (a.length) { if (Jr) { if (Jr < 70) { const M = a[0].flags; M.dependsOn = 2, M.isNonSync = 0 } } else if (Lu && Z - G < W - $ && x / W < 0.025 && a[0].cts === 0) { C.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.'); let M = f; for (let b = 0, q = a.length; b < q; b++) { const z = M + a[b].duration; const ie = M + a[b].cts; if (b < q - 1) { const ue = z + a[b + 1].cts; a[b].duration = ue - ie } else a[b].duration = b ? a[b - 1].duration : x; a[b].cts = 0, M = z } } }h = F || !h ? x : h, this.nextAvcDts = c = p + h, this.videoSampleDuration = h, this.isVideoContiguous = !0; const N = { data1: I.moof(e.sequenceNumber++, f, De({}, e, { samples: a })), data2: P, startPTS: m / s, endPTS: (y + h) / s, startDTS: f / s, endDTS: c / s, type: 'video', hasAudio: !1, hasVideo: !0, nb: a.length, dropped: e.dropped }; return e.samples = [], e.dropped = 0, N }getSamplesPerFrame (e) { switch (e.segmentCodec) { case 'mp3':return GC; case 'ac3':return VC; default:return Qp } }remuxAudio (e, t, r, i, s) { const o = e.inputTimeScale; const a = e.samplerate ? e.samplerate : o; const l = o / a; const u = this.getSamplesPerFrame(e); const c = u * l; const d = this._initPTS; const h = e.segmentCodec === 'mp3' && this.typeSupported.mpeg; const f = []; const p = s !== void 0; let m = e.samples; let y = h ? 0 : 8; let g = this.nextAudioPts || -1; const v = t * o; const E = d.baseTime * o / d.timescale; if (this.isAudioContiguous = r = r || m.length && g > 0 && (i && Math.abs(v - g) < 9e3 || Math.abs(bt(m[0].pts - E, v) - g) < 20 * c), m.forEach(function (Y) { Y.pts = bt(Y.pts - E, v) }), !r || g < 0) { if (m = m.filter(Y => Y.pts >= 0), !m.length) return; s === 0 ? g = 0 : i && !p ? g = Math.max(0, v) : g = m[0].pts } if (e.segmentCodec === 'aac') { const Y = this.config.maxAudioFramesDrift; for (let re = 0, N = g; re < m.length; re++) { const M = m[re]; const b = M.pts; const q = b - N; const z = Math.abs(1e3 * q / o); if (q <= -Y * c && p)re === 0 && (C.warn(`Audio frame @ ${(b / o).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * q / o)} ms.`), this.nextAudioPts = g = N = b); else if (q >= Y * c && z < $C && p) { let ie = Math.round(q / c); N = b - ie * c, N < 0 && (ie--, N += c), re === 0 && (this.nextAudioPts = g = N), C.warn(`[mp4-remuxer]: Injecting ${ie} audio frame @ ${(N / o).toFixed(3)}s due to ${Math.round(1e3 * q / o)} ms gap.`); for (let ue = 0; ue < ie; ue++) { const xe = Math.max(N, 0); let fe = qp.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); fe || (C.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.'), fe = M.unit.subarray()), m.splice(re, 0, { unit: fe, pts: xe }), N += c, re++ } }M.pts = N, N += c } } let x = null; let T = null; let w; let L = 0; let A = m.length; for (;A--;)L += m[A].unit.byteLength; for (let Y = 0, re = m.length; Y < re; Y++) { const N = m[Y]; const M = N.unit; let b = N.pts; if (T !== null) { const z = f[Y - 1]; z.duration = Math.round((b - T) / l) } else if (r && e.segmentCodec === 'aac' && (b = g), x = b, L > 0) { L += y; try { w = new Uint8Array(L) } catch (z) { this.observer.emit(S.ERROR, S.ERROR, { type: J.MUX_ERROR, details: D.REMUX_ALLOC_ERROR, fatal: !1, error: z, bytes: L, reason: `fail allocating audio mdat ${L}` }); return }h || (new DataView(w.buffer).setUint32(0, L), w.set(I.types.mdat, 4)) } else return; w.set(M, y); const q = M.byteLength; y += q, f.push(new Xp(!0, u, q, 0)), T = b } const P = f.length; if (!P) return; const _ = f[f.length - 1]; this.nextAudioPts = g = T + l * _.duration; const F = h ? new Uint8Array(0) : I.moof(e.sequenceNumber++, x / l, De({}, e, { samples: f })); e.samples = []; const $ = x / o; const G = g / o; const Z = { data1: F, data2: w, startPTS: $, endPTS: G, startDTS: $, endDTS: G, type: 'audio', hasAudio: !0, hasVideo: !1, nb: P }; return this.isAudioContiguous = !0, Z }remuxEmptyAudio (e, t, r, i) { const s = e.inputTimeScale; const o = e.samplerate ? e.samplerate : s; const a = s / o; const l = this.nextAudioPts; const u = this._initDTS; const c = u.baseTime * 9e4 / u.timescale; const d = (l !== null ? l : i.startDTS * s) + c; const h = i.endDTS * s + c; const f = a * Qp; const p = Math.ceil((h - d) / f); const m = qp.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (C.warn('[mp4-remuxer]: remux empty Audio'), !m) { C.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec'); return } const y = []; for (let g = 0; g < p; g++) { const v = d + g * f; y.push({ unit: m, pts: v, dts: v }) } return e.samples = y, this.remuxAudio(e, t, r, !1) }} function bt (n, e) { let t; if (e === null) return n; for (e < n ? t = -8589934592 : t = 8589934592; Math.abs(n - e) > 4294967296;)n += t; return n } function HC (n) { for (let e = 0; e < n.length; e++) if (n[e].key) return e; return -1 } function Nv (n, e, t, r) { const i = n.samples.length; if (!i) return; const s = n.inputTimeScale; for (let a = 0; a < i; a++) { const l = n.samples[a]; l.pts = bt(l.pts - t.baseTime * s / t.timescale, e * s) / s, l.dts = bt(l.dts - r.baseTime * s / r.timescale, e * s) / s } const o = n.samples; return n.samples = [], { samples: o } } function Uv (n, e, t) { const r = n.samples.length; if (!r) return; const i = n.inputTimeScale; for (let o = 0; o < r; o++) { const a = n.samples[o]; a.pts = bt(a.pts - t.baseTime * i / t.timescale, e * i) / i }n.samples.sort((o, a) => o.pts - a.pts); const s = n.samples; return n.samples = [], { samples: s } } class Xp {constructor (e, t, r, i) { this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = r, this.cts = i, this.flags = { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: e ? 2 : 1, isNonSync: e ? 0 : 1 } }} class KC {constructor () { this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null }destroy () {}resetTimeStamp (e) { this.initPTS = e, this.lastEndTime = null }resetNextTimestamp () { this.lastEndTime = null }resetInitSegment (e, t, r, i) { this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(JA(e, i)), this.emitInitSegment = !0 }generateInitSegment (e) { let { audioCodec: t, videoCodec: r } = this; if (!(e != null && e.byteLength)) { this.initTracks = void 0, this.initData = void 0; return } const i = this.initData = uv(e); i.audio && (t = Jp(i.audio, ae.AUDIO)), i.video && (r = Jp(i.video, ae.VIDEO)); const s = {}; i.audio && i.video ? s.audiovideo = { container: 'video/mp4', codec: t + ',' + r, initSegment: e, id: 'main' } : i.audio ? s.audio = { container: 'audio/mp4', codec: t, initSegment: e, id: 'audio' } : i.video ? s.video = { container: 'video/mp4', codec: r, initSegment: e, id: 'main' } : C.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.'), this.initTracks = s }remux (e, t, r, i, s, o) { let a, l; let { initPTS: u, lastEndTime: c } = this; const d = { audio: void 0, video: void 0, text: i, id3: r, initSegment: void 0 }; K(c) || (c = this.lastEndTime = s || 0); const h = t.samples; if (!(h != null && h.length)) return d; const f = { initPTS: void 0, timescale: 1 }; let p = this.initData; if ((a = p) != null && a.length || (this.generateInitSegment(h), p = this.initData), !((l = p) != null && l.length)) return C.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.'), d; this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1); const m = ew(h, p); const y = ZA(p, h); const g = y === null ? s : y; (jC(u, g, s, m) || f.timescale !== u.timescale && o) && (f.initPTS = g - s, u && u.timescale === 1 && C.warn(`Adjusting initPTS by ${f.initPTS - u.baseTime}`), this.initPTS = u = { baseTime: f.initPTS, timescale: 1 }); const v = e ? g - u.baseTime / u.timescale : c; const E = v + m; nw(p, h, u.baseTime / u.timescale), m > 0 ? this.lastEndTime = E : (C.warn('Duration parsed from mp4 should be greater than zero'), this.resetNextTimestamp()); const x = !!p.audio; const T = !!p.video; let w = ''; x && (w += 'audio'), T && (w += 'video'); const L = { data1: h, startPTS: v, startDTS: v, endPTS: E, endDTS: E, type: w, hasAudio: x, hasVideo: T, nb: 1, dropped: 0 }; return d.audio = L.type === 'audio' ? L : void 0, d.video = L.type !== 'audio' ? L : void 0, d.initSegment = f, d.id3 = Nv(r, s, u, u), i.samples.length && (d.text = Uv(i, s, u)), d }} function jC (n, e, t, r) { if (n === null) return !0; const i = Math.max(r, 1); const s = e - n.baseTime / n.timescale; return Math.abs(s - t) > i } function Jp (n, e) { const t = n == null ? void 0 : n.codec; if (t && t.length > 4) return t; if (e === ae.AUDIO) { if (t === 'ec-3' || t === 'ac-3' || t === 'alac') return t; if (t === 'fLaC' || t === 'Opus') return Ja(t, !1); const r = 'mp4a.40.5'; return C.info(`Parsed audio codec "${t}" or audio object type not handled. Using "${r}"`), r } return C.warn(`Unhandled video codec "${t}"`), t === 'hvc1' || t === 'hev1' ? 'hvc1.1.6.L120.90' : t === 'av01' ? 'av01.0.04M.08' : 'avc1.42e01e' } let Sn; try { Sn = self.performance.now.bind(self.performance) } catch { C.debug('Unable to use Performance API on this environment'), Sn = Wi == null ? void 0 : Wi.Date.now } const ya = [{ demux: DC, remux: KC }, { demux: Nn, remux: ga }, { demux: IC, remux: ga }, { demux: NC, remux: ga }]; ya.splice(2, 0, { demux: kC, remux: ga }); class Zp {constructor (e, t, r, i, s) { this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i, this.id = s }configure (e) { this.transmuxConfig = e, this.decrypter && this.decrypter.reset() }push (e, t, r, i) { const s = r.transmuxing; s.executeStart = Sn(); let o = new Uint8Array(e); const { currentTransmuxState: a, transmuxConfig: l } = this; i && (this.currentTransmuxState = i); const { contiguous: u, discontinuity: c, trackSwitch: d, accurateTimeOffset: h, timeOffset: f, initSegmentChange: p } = i || a; const { audioCodec: m, videoCodec: y, defaultInitPts: g, duration: v, initSegmentData: E } = l; const x = zC(o, t); if (x && x.method === 'AES-128') { const A = this.getDecrypter(); if (A.isSync()) { let P = A.softwareDecrypt(o, x.key.buffer, x.iv.buffer); if (r.part > -1 && (P = A.flush()), !P) return s.executeEnd = Sn(), Ru(r); o = new Uint8Array(P) } else return this.decryptionPromise = A.webCryptoDecrypt(o, x.key.buffer, x.iv.buffer).then(P => { const _ = this.push(P, null, r); return this.decryptionPromise = null, _ }), this.decryptionPromise } const T = this.needsProbing(c, d); if (T) { const A = this.configureTransmuxer(o); if (A) return C.warn(`[transmuxer] ${A.message}`), this.observer.emit(S.ERROR, S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, fatal: !1, error: A, reason: A.message }), s.executeEnd = Sn(), Ru(r) }(c || d || p || T) && this.resetInitSegment(E, m, y, v, t), (c || p || T) && this.resetInitialTimestamp(g), u || this.resetContiguity(); const w = this.transmux(o, x, f, h, r); const L = this.currentTransmuxState; return L.contiguous = !0, L.discontinuity = !1, L.trackSwitch = !1, s.executeEnd = Sn(), w }flush (e) { const t = e.transmuxing; t.executeStart = Sn(); const { decrypter: r, currentTransmuxState: i, decryptionPromise: s } = this; if (s) return s.then(() => this.flush(e)); const o = []; const { timeOffset: a } = i; if (r) { const d = r.flush(); d && o.push(this.push(d, null, e)) } const { demuxer: l, remuxer: u } = this; if (!l || !u) return t.executeEnd = Sn(), [Ru(e)]; const c = l.flush(a); return va(c) ? c.then(d => (this.flushRemux(o, d, e), o)) : (this.flushRemux(o, c, e), o) }flushRemux (e, t, r) { const { audioTrack: i, videoTrack: s, id3Track: o, textTrack: a } = t; const { accurateTimeOffset: l, timeOffset: u } = this.currentTransmuxState; C.log(`[transmuxer.ts]: Flushed fragment ${r.sn}${r.part > -1 ? ' p: ' + r.part : ''} of level ${r.level}`); const c = this.remuxer.remux(i, s, o, a, u, l, !0, this.id); e.push({ remuxResult: c, chunkMeta: r }), r.transmuxing.executeEnd = Sn() }resetInitialTimestamp (e) { const { demuxer: t, remuxer: r } = this; !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e)) }resetContiguity () { const { demuxer: e, remuxer: t } = this; !e || !t || (e.resetContiguity(), t.resetNextTimestamp()) }resetInitSegment (e, t, r, i, s) { const { demuxer: o, remuxer: a } = this; !o || !a || (o.resetInitSegment(e, t, r, i), a.resetInitSegment(e, t, r, s)) }destroy () { this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0) }transmux (e, t, r, i, s) { let o; return t && t.method === 'SAMPLE-AES' ? o = this.transmuxSampleAes(e, t, r, i, s) : o = this.transmuxUnencrypted(e, r, i, s), o }transmuxUnencrypted (e, t, r, i) { const { audioTrack: s, videoTrack: o, id3Track: a, textTrack: l } = this.demuxer.demux(e, t, !1, !this.config.progressive); return { remuxResult: this.remuxer.remux(s, o, a, l, t, r, !1, this.id), chunkMeta: i } }transmuxSampleAes (e, t, r, i, s) { return this.demuxer.demuxSampleAes(e, t, r).then(o => ({ remuxResult: this.remuxer.remux(o.audioTrack, o.videoTrack, o.id3Track, o.textTrack, r, i, !1, this.id), chunkMeta: s })) }configureTransmuxer (e) { const { config: t, observer: r, typeSupported: i, vendor: s } = this; let o; for (let h = 0, f = ya.length; h < f; h++) { var a; if ((a = ya[h].demux) != null && a.probe(e)) { o = ya[h]; break } } if (!o) return new Error('Failed to find demuxer by probing fragment data'); const l = this.demuxer; const u = this.remuxer; const c = o.remux; const d = o.demux; (!u || !(u instanceof c)) && (this.remuxer = new c(r, t, i, s)), (!l || !(l instanceof d)) && (this.demuxer = new d(r, t, i), this.probe = d.probe) }needsProbing (e, t) { return !this.demuxer || !this.remuxer || e || t }getDecrypter () { let e = this.decrypter; return e || (e = this.decrypter = new wh(this.config)), e }} function zC (n, e) { let t = null; return n.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (t = e), t } const Ru = n => ({ remuxResult: {}, chunkMeta: n }); function va (n) { return 'then' in n && n.then instanceof Function } class WC {constructor (e, t, r, i, s) { this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = i, this.defaultInitPts = s || null }} class YC {constructor (e, t, r, i, s, o) { this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = s, this.initSegmentChange = o }} const Bv = { exports: {} }; (function (n) { const e = Object.prototype.hasOwnProperty; let t = '~'; function r () {}Object.create && (r.prototype = Object.create(null), new r().__proto__ || (t = !1)); function i (l, u, c) { this.fn = l, this.context = u, this.once = c || !1 } function s (l, u, c, d, h) { if (typeof c !== 'function') throw new TypeError('The listener must be a function'); const f = new i(c, d || l, h); const p = t ? t + u : u; return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l } function o (l, u) { --l._eventsCount === 0 ? l._events = new r() : delete l._events[u] } function a () { this._events = new r(), this._eventsCount = 0 }a.prototype.eventNames = function () { const u = []; let c; let d; if (this._eventsCount === 0) return u; for (d in c = this._events)e.call(c, d) && u.push(t ? d.slice(1) : d); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u }, a.prototype.listeners = function (u) { const c = t ? t + u : u; const d = this._events[c]; if (!d) return []; if (d.fn) return [d.fn]; for (var h = 0, f = d.length, p = new Array(f); h < f; h++)p[h] = d[h].fn; return p }, a.prototype.listenerCount = function (u) { const c = t ? t + u : u; const d = this._events[c]; return d ? d.fn ? 1 : d.length : 0 }, a.prototype.emit = function (u, c, d, h, f, p) { const m = t ? t + u : u; if (!this._events[m]) return !1; const y = this._events[m]; const g = arguments.length; let v; let E; if (y.fn) { switch (y.once && this.removeListener(u, y.fn, void 0, !0), g) { case 1:return y.fn.call(y.context), !0; case 2:return y.fn.call(y.context, c), !0; case 3:return y.fn.call(y.context, c, d), !0; case 4:return y.fn.call(y.context, c, d, h), !0; case 5:return y.fn.call(y.context, c, d, h, f), !0; case 6:return y.fn.call(y.context, c, d, h, f, p), !0 } for (E = 1, v = new Array(g - 1); E < g; E++)v[E - 1] = arguments[E]; y.fn.apply(y.context, v) } else { const x = y.length; let T; for (E = 0; E < x; E++) switch (y[E].once && this.removeListener(u, y[E].fn, void 0, !0), g) { case 1:y[E].fn.call(y[E].context); break; case 2:y[E].fn.call(y[E].context, c); break; case 3:y[E].fn.call(y[E].context, c, d); break; case 4:y[E].fn.call(y[E].context, c, d, h); break; default:if (!v) for (T = 1, v = new Array(g - 1); T < g; T++)v[T - 1] = arguments[T]; y[E].fn.apply(y[E].context, v) } } return !0 }, a.prototype.on = function (u, c, d) { return s(this, u, c, d, !1) }, a.prototype.once = function (u, c, d) { return s(this, u, c, d, !0) }, a.prototype.removeListener = function (u, c, d, h) { const f = t ? t + u : u; if (!this._events[f]) return this; if (!c) return o(this, f), this; const p = this._events[f]; if (p.fn)p.fn === c && (!h || p.once) && (!d || p.context === d) && o(this, f); else { for (var m = 0, y = [], g = p.length; m < g; m++)(p[m].fn !== c || h && !p[m].once || d && p[m].context !== d) && y.push(p[m]); y.length ? this._events[f] = y.length === 1 ? y[0] : y : o(this, f) } return this }, a.prototype.removeAllListeners = function (u) { let c; return u ? (c = t ? t + u : u, this._events[c] && o(this, c)) : (this._events = new r(), this._eventsCount = 0), this }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, n.exports = a })(Bv); const qC = Bv.exports; const Ph = EA(qC); class $v {
  constructor (e, t, r, i) { this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0; const s = e.config; this.hls = e, this.id = t, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = r, this.onFlush = i; const o = (c, d) => { d = d || {}, d.frag = this.frag, d.id = this.id, c === S.ERROR && (this.error = d.error), this.hls.trigger(c, d) }; this.observer = new Ph(), this.observer.on(S.FRAG_DECRYPTED, o), this.observer.on(S.ERROR, o); const a = $r(s.preferManagedMediaSource) || { isTypeSupported: () => !1 }; const l = { mpeg: a.isTypeSupported('audio/mpeg'), mp3: a.isTypeSupported('audio/mp4; codecs="mp3"'), ac3: a.isTypeSupported('audio/mp4; codecs="ac-3"') }; const u = navigator.vendor; if (this.useWorker && typeof Worker < 'u' && (s.workerPath || pC())) { try { s.workerPath ? (C.log(`loading Web Worker ${s.workerPath} for "${t}"`), this.workerContext = gC(s.workerPath)) : (C.log(`injecting Web Worker for "${t}"`), this.workerContext = mC()), this.onwmsg = h => this.onWorkerMessage(h); const { worker: d } = this.workerContext; d.addEventListener('message', this.onwmsg), d.onerror = h => { const f = new Error(`${h.message}  (${h.filename}:${h.lineno})`); s.enableWorker = !1, C.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(S.ERROR, { type: J.OTHER_ERROR, details: D.INTERNAL_EXCEPTION, fatal: !1, event: 'demuxerWorker', error: f }) }, d.postMessage({ cmd: 'init', typeSupported: l, vendor: u, id: t, config: JSON.stringify(s) }) } catch (d) { C.warn(`Error setting up "${t}" Web Worker, fallback to inline`, d), this.resetWorker(), this.error = null, this.transmuxer = new Zp(this.observer, l, s, u, t) } return } this.transmuxer = new Zp(this.observer, l, s, u, t) }resetWorker () { if (this.workerContext) { const { worker: e, objectURL: t } = this.workerContext; t && self.URL.revokeObjectURL(t), e.removeEventListener('message', this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null } }destroy () { if (this.workerContext) this.resetWorker(), this.onwmsg = void 0; else { const t = this.transmuxer; t && (t.destroy(), this.transmuxer = null) } const e = this.observer; e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null }push (e, t, r, i, s, o, a, l, u, c) {
    let d, h; u.transmuxing.start = self.performance.now(); const { transmuxer: f } = this; const p = o ? o.start : s.start; const m = s.decryptdata; const y = this.frag; const g = !(y && s.cc === y.cc); const v = !(y && u.level === y.level); const E = y ? u.sn - y.sn : -1; const x = this.part ? u.part - this.part.index : -1; const T = E === 0 && u.id > 1 && u.id === (y == null ? void 0 : y.stats.chunkCount); const w = !v && (E === 1 || E === 0 && (x === 1 || T && x <= 0)); const L = self.performance.now(); (v || E || s.stats.parsing.start === 0) && (s.stats.parsing.start = L), o && (x || !w) && (o.stats.parsing.start = L); const A = !(y && ((d = s.initSegment) == null ? void 0 : d.url) === ((h = y.initSegment) == null ? void 0 : h.url)); const P = new YC(g, w, l, v, p, A); if (!w || g || A) {
      C.log(`[transmuxer-interface, ${s.type}]: Starting new transmux session for sn: ${u.sn} p: ${u.part} level: ${u.level} id: ${u.id}
        discontinuity: ${g}
        trackSwitch: ${v}
        contiguous: ${w}
        accurateTimeOffset: ${l}
        timeOffset: ${p}
        initSegmentChange: ${A}`); const _ = new WC(r, i, t, a, c); this.configureTransmuxer(_)
    } if (this.frag = s, this.part = o, this.workerContext) this.workerContext.worker.postMessage({ cmd: 'demux', data: e, decryptdata: m, chunkMeta: u, state: P }, e instanceof ArrayBuffer ? [e] : []); else if (f) { const _ = f.push(e, m, u, P); va(_) ? (f.async = !0, _.then(F => { this.handleTransmuxComplete(F) }).catch(F => { this.transmuxerError(F, u, 'transmuxer-interface push error') })) : (f.async = !1, this.handleTransmuxComplete(_)) }
  }

  flush (e) { e.transmuxing.start = self.performance.now(); const { transmuxer: t } = this; if (this.workerContext) this.workerContext.worker.postMessage({ cmd: 'flush', chunkMeta: e }); else if (t) { let r = t.flush(e); va(r) || t.async ? (va(r) || (r = Promise.resolve(r)), r.then(s => { this.handleFlushResult(s, e) }).catch(s => { this.transmuxerError(s, e, 'transmuxer-interface flush error') })) : this.handleFlushResult(r, e) } }transmuxerError (e, t, r) { this.hls && (this.error = e, this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_PARSING_ERROR, chunkMeta: t, fatal: !1, error: e, err: e, reason: r })) }handleFlushResult (e, t) { e.forEach(r => { this.handleTransmuxComplete(r) }), this.onFlush(t) }onWorkerMessage (e) { const t = e.data; const r = this.hls; switch (t.event) { case 'init':{ let i; const s = (i = this.workerContext) == null ? void 0 : i.objectURL; s && self.URL.revokeObjectURL(s); break } case 'transmuxComplete':{ this.handleTransmuxComplete(t.data); break } case 'flush':{ this.onFlush(t.data); break } case 'workerLog':C[t.data.logType] && C[t.data.logType](t.data.message); break; default:{ t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data); break } } }configureTransmuxer (e) { const { transmuxer: t } = this; this.workerContext ? this.workerContext.worker.postMessage({ cmd: 'configure', config: e }) : t && t.configure(e) }handleTransmuxComplete (e) { e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e) }
} function Gv (n, e) { if (n.length !== e.length) return !1; for (let t = 0; t < n.length; t++) if (!qi(n[t].attrs, e[t].attrs)) return !1; return !0 } function qi (n, e, t) { const r = n['STABLE-RENDITION-ID']; return r && !t ? r === e['STABLE-RENDITION-ID'] : !(t || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(i => n[i] !== e[i]) } function td (n, e) { return e.label.toLowerCase() === n.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (n.lang || '').toLowerCase()) } const em = 100; class QC extends Ch {constructor (e, t, r) { super(e, t, r, '[audio-stream-controller]', X.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners() }onHandlerDestroying () { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null }_registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.LEVEL_LOADED, this.onLevelLoaded, this), e.on(S.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(S.ERROR, this.onError, this), e.on(S.BUFFER_RESET, this.onBufferReset, this), e.on(S.BUFFER_CREATED, this.onBufferCreated, this), e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(S.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(S.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.LEVEL_LOADED, this.onLevelLoaded, this), e.off(S.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(S.ERROR, this.onError, this), e.off(S.BUFFER_RESET, this.onBufferReset, this), e.off(S.BUFFER_CREATED, this.onBufferCreated, this), e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(S.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(S.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this) }onInitPtsFound (e, { frag: t, id: r, initPTS: i, timescale: s }) { if (r === 'main') { const o = t.cc; this.initPTS[t.cc] = { baseTime: i, timescale: s }, this.log(`InitPTS for cc: ${o} found from main: ${i}`), this.videoTrackCC = o, this.state === O.WAITING_INIT_PTS && this.tick() } }startLoad (e) { if (!this.levels) { this.startPosition = e, this.state = O.STOPPED; return } const t = this.lastCurrentTime; this.stopLoad(), this.setInterval(em), t > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = O.IDLE) : (this.loadedmetadata = !1, this.state = O.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() }doTick () { switch (this.state) { case O.IDLE:this.doTickIdle(); break; case O.WAITING_TRACK:{ let e; const { levels: r, trackId: i } = this; const s = r == null || (e = r[i]) == null ? void 0 : e.details; if (s) { if (this.waitForCdnTuneIn(s)) break; this.state = O.WAITING_INIT_PTS } break } case O.FRAG_LOADING_WAITING_RETRY:{ let t; const r = performance.now(); const i = this.retryDate; if (!i || r >= i || (t = this.media) != null && t.seeking) { const { levels: s, trackId: o } = this; this.log('RetryDate reached, switch back to IDLE state'), this.resetStartWhenNotLoaded((s == null ? void 0 : s[o]) || null), this.state = O.IDLE } break } case O.WAITING_INIT_PTS:{ const r = this.waitingData; if (r) { const { frag: i, part: s, cache: o, complete: a } = r; if (this.initPTS[i.cc] !== void 0) { this.waitingData = null, this.waitingVideoCC = -1, this.state = O.FRAG_LOADING; const l = o.flush(); const u = { frag: i, part: s, payload: l, networkDetails: null }; this._handleFragmentLoadProgress(u), a && super._handleFragmentLoadComplete(u) } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${i.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment(); else { const l = this.getLoadPosition(); const u = de.bufferInfo(this.mediaBuffer, l, this.config.maxBufferHole); Zc(u.end, this.config.maxFragLookUpTolerance, i) < 0 && (this.log(`Waiting fragment cc (${i.cc}) @ ${i.start} cancelled because another fragment at ${u.end} is needed`), this.clearWaitingFragment()) } } else this.state = O.IDLE } } this.onTickEnd() }clearWaitingFragment () { const e = this.waitingData; e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = O.IDLE) }resetLoadingState () { this.clearWaitingFragment(), super.resetLoadingState() }onTickEnd () { const { media: e } = this; e != null && e.readyState && (this.lastCurrentTime = e.currentTime) }doTickIdle () { const { hls: e, levels: t, media: r, trackId: i } = this; const s = e.config; if (!r && (this.startFragRequested || !s.startFragPrefetch) || !(t != null && t[i])) return; const o = t[i]; const a = o.details; if (!a || a.live && this.levelLastLoaded !== o || this.waitForCdnTuneIn(a)) { this.state = O.WAITING_TRACK; return } const l = this.mediaBuffer ? this.mediaBuffer : this.media; this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, ae.AUDIO, X.AUDIO)); const u = this.getFwdBufferInfo(l, X.AUDIO); if (u === null) return; const { bufferedTrack: c, switchingTrack: d } = this; if (!d && this._streamEnded(u, a)) { e.trigger(S.BUFFER_EOS, { type: 'audio' }), this.state = O.ENDED; return } const h = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, X.MAIN); const f = u.len; const p = this.getMaxBufferLength(h == null ? void 0 : h.len); const m = a.fragments; const y = m[0].start; let g = this.flushing ? this.getLoadPosition() : u.end; if (d && r) { const T = this.getLoadPosition(); c && !qi(d.attrs, c.attrs) && (g = T), a.PTSKnown && T < y && (u.end > y || u.nextStart) && (this.log('Alt audio track ahead of main track, seek to start of alt audio track'), r.currentTime = y + 0.05) } if (f >= p && !d && g < m[m.length - 1].start) return; let v = this.getNextFragment(g, a); let E = !1; if (v && this.isLoopLoading(v, g) && (E = !!v.gap, v = this.getNextFragmentLoopLoading(v, a, u, X.MAIN, p)), !v) { this.bufferFlushed = !0; return } const x = h && v.start > h.end + a.targetduration; if (x || !(h != null && h.len) && u.len) { const T = this.getAppendedFrag(v.start, X.MAIN); if (T === null || (E || (E = !!T.gap || !!x && h.len === 0), x && !E || E && u.nextStart && u.nextStart < T.end)) return } this.loadFragment(v, o, g) }getMaxBufferLength (e) { const t = super.getMaxBufferLength(); return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t }onMediaDetaching () { this.videoBuffer = null, this.bufferFlushed = this.flushing = !1, super.onMediaDetaching() }onAudioTracksUpdated (e, { audioTracks: t }) { this.resetTransmuxer(), this.levels = t.map(r => new Yi(r)) }onAudioTrackSwitching (e, t) { const r = !!t.url; this.trackId = t.id; const { fragCurrent: i } = this; i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), r ? this.setInterval(em) : this.resetTransmuxer(), r ? (this.switchingTrack = t, this.state = O.IDLE, this.flushAudioIfNeeded(t)) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = O.STOPPED), this.tick() }onManifestLoading () { this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = this.flushing = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1 }onLevelLoaded (e, t) { this.mainDetails = t.details, this.cachedTrackLoadedData !== null && (this.hls.trigger(S.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null) }onAudioTrackLoaded (e, t) { let r; if (this.mainDetails == null) { this.cachedTrackLoadedData = t; return } const { levels: i } = this; const { details: s, id: o } = t; if (!i) { this.warn(`Audio tracks were reset while loading level ${o}`); return } this.log(`Audio track ${o} loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ''},duration:${s.totalduration}`); const a = i[o]; let l = 0; if (s.live || (r = a.details) != null && r.live) { this.checkLiveUpdate(s); const c = this.mainDetails; if (s.deltaUpdateFailed || !c) return; if (!a.details && s.hasProgramDateTime && c.hasProgramDateTime)rl(s, c), l = s.fragments[0].start; else { let u; l = this.alignPlaylists(s, a.details, (u = this.levelLastLoaded) == null ? void 0 : u.details) } }a.details = s, this.levelLastLoaded = a, !this.startFragRequested && (this.mainDetails || !s.live) && this.setStartPosition(this.mainDetails || s, l), this.state === O.WAITING_TRACK && !this.waitForCdnTuneIn(s) && (this.state = O.IDLE), this.tick() }_handleFragmentLoadProgress (e) { let t; const { frag: r, part: i, payload: s } = e; const { config: o, trackId: a, levels: l } = this; if (!l) { this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`); return } const u = l[a]; if (!u) { this.warn('Audio track is undefined on fragment load progress'); return } const c = u.details; if (!c) { this.warn('Audio track details undefined on fragment load progress'), this.removeUnbufferedFrags(r.start); return } const d = o.defaultAudioCodec || u.audioCodec || 'mp4a.40.2'; let h = this.transmuxer; h || (h = this.transmuxer = new $v(this.hls, X.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))); const f = this.initPTS[r.cc]; const p = (t = r.initSegment) == null ? void 0 : t.data; if (f !== void 0) { const y = i ? i.index : -1; const g = y !== -1; const v = new Ah(r.level, r.sn, r.stats.chunkCount, s.byteLength, y, g); h.push(s, p, d, '', r, i, c.totalduration, !1, v, f) } else { this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${c.startSN} ,${c.endSN}],track ${a}`); const { cache: m } = this.waitingData = this.waitingData || { frag: r, part: i, cache: new Rv(), complete: !1 }; m.push(new Uint8Array(s)), this.waitingVideoCC = this.videoTrackCC, this.state = O.WAITING_INIT_PTS } }_handleFragmentLoadComplete (e) { if (this.waitingData) { this.waitingData.complete = !0; return } super._handleFragmentLoadComplete(e) }onBufferReset () { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1 }onBufferCreated (e, t) { const r = t.tracks.audio; r && (this.mediaBuffer = r.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null) }onFragBuffered (e, t) { const { frag: r, part: i } = t; if (r.type !== X.AUDIO) { if (!this.loadedmetadata && r.type === X.MAIN) { const s = this.videoBuffer || this.media; s && de.getBuffered(s).length && (this.loadedmetadata = !0) } return } if (this.fragContextChanged(r)) { this.warn(`Fragment ${r.sn}${i ? ' p: ' + i.index : ''} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`); return } if (r.sn !== 'initSegment') { this.fragPrevious = r; const s = this.switchingTrack; s && (this.bufferedTrack = s, this.switchingTrack = null, this.hls.trigger(S.AUDIO_TRACK_SWITCHED, $e({}, s))) } this.fragBufferedComplete(r, i) }onError (e, t) { let r; if (t.fatal) { this.state = O.ERROR; return } switch (t.details) { case D.FRAG_GAP:case D.FRAG_PARSING_ERROR:case D.FRAG_DECRYPT_ERROR:case D.FRAG_LOAD_ERROR:case D.FRAG_LOAD_TIMEOUT:case D.KEY_LOAD_ERROR:case D.KEY_LOAD_TIMEOUT:this.onFragmentOrKeyLoadError(X.AUDIO, t); break; case D.AUDIO_TRACK_LOAD_ERROR:case D.AUDIO_TRACK_LOAD_TIMEOUT:case D.LEVEL_PARSING_ERROR:!t.levelRetry && this.state === O.WAITING_TRACK && ((r = t.context) == null ? void 0 : r.type) === se.AUDIO_TRACK && (this.state = O.IDLE); break; case D.BUFFER_APPEND_ERROR:case D.BUFFER_FULL_ERROR:if (!t.parent || t.parent !== 'audio') return; if (t.details === D.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio')); break; case D.INTERNAL_EXCEPTION:this.recoverWorkerError(t); break } }onBufferFlushing (e, { type: t }) { t !== ae.VIDEO && (this.flushing = !0) }onBufferFlushed (e, { type: t }) { if (t !== ae.VIDEO) { this.flushing = !1, this.bufferFlushed = !0, this.state === O.ENDED && (this.state = O.IDLE); const r = this.mediaBuffer || this.media; r && (this.afterBufferFlushed(r, t, X.AUDIO), this.tick()) } }_handleTransmuxComplete (e) { let t; const r = 'audio'; const { hls: i } = this; const { remuxResult: s, chunkMeta: o } = e; const a = this.getCurrentContext(o); if (!a) { this.resetWhenMissingContext(o); return } const { frag: l, part: u, level: c } = a; const { details: d } = c; const { audio: h, text: f, id3: p, initSegment: m } = s; if (this.fragContextChanged(l) || !d) { this.fragmentTracker.removeFragment(l); return } if (this.state = O.PARSING, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), m != null && m.tracks) { const y = l.initSegment || l; this._bufferInitSegment(c, m.tracks, y, o), i.trigger(S.FRAG_PARSING_INIT_SEGMENT, { frag: y, id: r, tracks: m.tracks }) } if (h) { const { startPTS: y, endPTS: g, startDTS: v, endDTS: E } = h; u && (u.elementaryStreams[ae.AUDIO] = { startPTS: y, endPTS: g, startDTS: v, endDTS: E }), l.setElementaryStreamInfo(ae.AUDIO, y, g, v, E), this.bufferFragmentData(h, l, u, o) } if (p != null && (t = p.samples) != null && t.length) { const y = De({ id: r, frag: l, details: d }, p); i.trigger(S.FRAG_PARSING_METADATA, y) } if (f) { const y = De({ id: r, frag: l, details: d }, f); i.trigger(S.FRAG_PARSING_USERDATA, y) } }_bufferInitSegment (e, t, r, i) { if (this.state !== O.PARSING) return; t.video && delete t.video; const s = t.audio; if (!s) return; s.id = 'audio'; const o = e.audioCodec; this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${o}/${s.codec}]`), o && o.split(',').length === 1 && (s.levelCodec = o), this.hls.trigger(S.BUFFER_CODECS, t); const a = s.initSegment; if (a != null && a.byteLength) { const l = { type: 'audio', frag: r, part: null, chunkMeta: i, parent: r.type, data: a }; this.hls.trigger(S.BUFFER_APPENDING, l) } this.tickImmediate() }loadFragment (e, t, r) { const i = this.fragmentTracker.getState(e); if (this.fragCurrent = e, this.switchingTrack || i === Ue.NOT_LOADED || i === Ue.PARTIAL) { let s; if (e.sn === 'initSegment') this._loadInitSegment(e, t); else if ((s = t.details) != null && s.live && !this.initPTS[e.cc]) { this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = O.WAITING_INIT_PTS; const o = this.mainDetails; o && o.fragments[0].start !== t.details.fragments[0].start && rl(t.details, o) } else this.startFragRequested = !0, super.loadFragment(e, t, r) } else this.clearTrackerIfNeeded(e) }flushAudioIfNeeded (e) { const { media: t, bufferedTrack: r } = this; const i = r == null ? void 0 : r.attrs; const s = e.attrs; t && i && (i.CHANNELS !== s.CHANNELS || r.name !== e.name || r.lang !== e.lang) && (this.log('Switching audio track : flushing all audio'), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio'), this.bufferedTrack = null) }completeAudioSwitch (e) { const { hls: t } = this; this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(S.AUDIO_TRACK_SWITCHED, $e({}, e)) }} class XC extends Rh {constructor (e) { super(e, '[audio-track-controller]'), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners() }registerListeners () { const { hls: e } = this; e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.LEVEL_LOADING, this.onLevelLoading, this), e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(S.ERROR, this.onError, this) }unregisterListeners () { const { hls: e } = this; e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.LEVEL_LOADING, this.onLevelLoading, this), e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(S.ERROR, this.onError, this) }destroy () { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy() }onManifestLoading () { this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0 }onManifestParsed (e, t) { this.tracks = t.audioTracks || [] }onAudioTrackLoaded (e, t) { const { id: r, groupId: i, details: s } = t; const o = this.tracksInGroup[r]; if (!o || o.groupId !== i) { this.warn(`Audio track with id:${r} and group:${i} not found in active group ${o == null ? void 0 : o.groupId}`); return } const a = o.details; o.details = t.details, this.log(`Audio track ${r} "${o.name}" lang:${o.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a) }onLevelLoading (e, t) { this.switchLevel(t.level) }onLevelSwitching (e, t) { this.switchLevel(t.level) }switchLevel (e) { const t = this.hls.levels[e]; if (!t) return; const r = t.audioGroups || null; const i = this.groupIds; let s = this.currentTrack; if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some(a => (i == null ? void 0 : i.indexOf(a)) === -1)) { this.groupIds = r, this.trackId = -1, this.currentTrack = null; const a = this.tracks.filter(h => !r || r.indexOf(h.groupId) !== -1); if (a.length) this.selectDefaultTrack && !a.some(h => h.default) && (this.selectDefaultTrack = !1), a.forEach((h, f) => { h.id = f }); else if (!s && !this.tracksInGroup.length) return; this.tracksInGroup = a; const l = this.hls.config.audioPreference; if (!s && l) { const h = cn(l, a, qr); if (h > -1)s = a[h]; else { const f = cn(l, this.tracks); s = this.tracks[f] } } let u = this.findTrackId(s); u === -1 && s && (u = this.findTrackId(null)); const c = { audioTracks: a }; this.log(`Updating audio tracks, ${a.length} track(s) found in group(s): ${r == null ? void 0 : r.join(',')}`), this.hls.trigger(S.AUDIO_TRACKS_UPDATED, c); const d = this.trackId; if (u !== -1 && d === -1) this.setAudioTrack(u); else if (a.length && d === -1) { let o; const h = new Error(`No audio track selected for current audio group-ID(s): ${(o = this.groupIds) == null ? void 0 : o.join(',')} track count: ${a.length}`); this.warn(h.message), this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.AUDIO_TRACK_LOAD_ERROR, fatal: !0, error: h }) } } else this.shouldReloadPlaylist(s) && this.setAudioTrack(this.trackId) }onError (e, t) { t.fatal || !t.context || t.context.type === se.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && (this.requestScheduled = -1, this.checkRetry(t)) } get allAudioTracks () { return this.tracks } get audioTracks () { return this.tracksInGroup } get audioTrack () { return this.trackId } set audioTrack (e) { this.selectDefaultTrack = !1, this.setAudioTrack(e) }setAudioOption (e) { const t = this.hls; if (t.config.audioPreference = e, e) { const r = this.allAudioTracks; if (this.selectDefaultTrack = !1, r.length) { const i = this.currentTrack; if (i && xi(e, i, qr)) return i; const s = cn(e, this.tracksInGroup, qr); if (s > -1) { const o = this.tracksInGroup[s]; return this.setAudioTrack(s), o } else if (i) { let o = t.loadLevel; o === -1 && (o = t.firstAutoLevel); const a = Xw(e, t.levels, r, o, qr); if (a === -1) return null; t.nextLoadLevel = a } if (e.channels || e.audioCodec) { const o = cn(e, r); if (o > -1) return r[o] } } } return null }setAudioTrack (e) { const t = this.tracksInGroup; if (e < 0 || e >= t.length) { this.warn(`Invalid audio track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; const r = this.currentTrack; const i = t[e]; const s = i.details && !i.details.live; if (e === this.trackId && i === r && s || (this.log(`Switching to audio-track ${e} "${i.name}" lang:${i.lang} group:${i.groupId} channels:${i.channels}`), this.trackId = e, this.currentTrack = i, this.hls.trigger(S.AUDIO_TRACK_SWITCHING, $e({}, i)), s)) return; const o = this.switchParams(i.url, r == null ? void 0 : r.details, i.details); this.loadPlaylist(o) }findTrackId (e) { const t = this.tracksInGroup; for (let r = 0; r < t.length; r++) { const i = t[r]; if (!(this.selectDefaultTrack && !i.default) && (!e || xi(e, i, qr))) return r } if (e) { const { name: r, lang: i, assocLang: s, characteristics: o, audioCodec: a, channels: l } = e; for (let u = 0; u < t.length; u++) { const c = t[u]; if (xi({ name: r, lang: i, assocLang: s, characteristics: o, audioCodec: a, channels: l }, c, qr)) return u } for (let u = 0; u < t.length; u++) { const c = t[u]; if (qi(e.attrs, c.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) return u } for (let u = 0; u < t.length; u++) { const c = t[u]; if (qi(e.attrs, c.attrs, ['LANGUAGE'])) return u } } return -1 }loadPlaylist (e) { const t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { super.loadPlaylist(); const r = t.id; const i = t.groupId; let s = t.url; if (e) try { s = e.addDirectives(s) } catch (o) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`) } this.log(`loading audio-track playlist ${r} "${t.name}" lang:${t.lang} group:${i}`), this.clearTimer(), this.hls.trigger(S.AUDIO_TRACK_LOADING, { url: s, id: r, groupId: i, deliveryDirectives: e || null }) } }} const tm = 500; class JC extends Ch {constructor (e, t, r) { super(e, t, r, '[subtitle-stream-controller]', X.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners() }onHandlerDestroying () { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null }_registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.LEVEL_LOADED, this.onLevelLoaded, this), e.on(S.ERROR, this.onError, this), e.on(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(S.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.LEVEL_LOADED, this.onLevelLoaded, this), e.off(S.ERROR, this.onError, this), e.off(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(S.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this) }startLoad (e) { this.stopLoad(), this.state = O.IDLE, this.setInterval(tm), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() }onManifestLoading () { this.mainDetails = null, this.fragmentTracker.removeAllFragments() }onMediaDetaching () { this.tracksBuffered = [], super.onMediaDetaching() }onLevelLoaded (e, t) { this.mainDetails = t.details }onSubtitleFragProcessed (e, t) { const { frag: r, success: i } = t; if (this.fragPrevious = r, this.state = O.IDLE, !i) return; const s = this.tracksBuffered[this.currentTrackId]; if (!s) return; let o; const a = r.start; for (let u = 0; u < s.length; u++) if (a >= s[u].start && a <= s[u].end) { o = s[u]; break } const l = r.start + r.duration; o ? o.end = l : (o = { start: a, end: l }, s.push(o)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null) }onBufferFlushing (e, t) { const { startOffset: r, endOffset: i } = t; if (r === 0 && i !== Number.POSITIVE_INFINITY) { const s = i - 1; if (s <= 0) return; t.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach(o => { for (let a = 0; a < o.length;) { if (o[a].end <= s) { o.shift(); continue } else if (o[a].start < s)o[a].start = s; else break; a++ } }), this.fragmentTracker.removeFragmentsInRange(r, s, X.SUBTITLE) } }onFragBuffered (e, t) { if (!this.loadedmetadata && t.frag.type === X.MAIN) { let r; (r = this.media) != null && r.buffered.length && (this.loadedmetadata = !0) } }onError (e, t) { const r = t.frag; (r == null ? void 0 : r.type) === X.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== O.STOPPED && (this.state = O.IDLE)) }onSubtitleTracksUpdated (e, { subtitleTracks: t }) { if (this.levels && Gv(this.levels, t)) { this.levels = t.map(r => new Yi(r)); return } this.tracksBuffered = [], this.levels = t.map(r => { const i = new Yi(r); return this.tracksBuffered[i.id] = [], i }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, X.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null }onSubtitleTrackSwitch (e, t) { let r; if (this.currentTrackId = t.id, !((r = this.levels) != null && r.length) || this.currentTrackId === -1) { this.clearInterval(); return } const i = this.levels[this.currentTrackId]; i != null && i.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, i && this.setInterval(tm) }onSubtitleTrackLoaded (e, t) { let r; const { currentTrackId: i, levels: s } = this; const { details: o, id: a } = t; if (!s) { this.warn(`Subtitle tracks were reset while loading level ${a}`); return } const l = s[i]; if (a >= s.length || a !== i || !l) return; this.log(`Subtitle track ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ''},duration:${o.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges; let u = 0; if (o.live || (r = l.details) != null && r.live) { const d = this.mainDetails; if (o.deltaUpdateFailed || !d) return; const h = d.fragments[0]; if (!l.details)o.hasProgramDateTime && d.hasProgramDateTime ? (rl(o, d), u = o.fragments[0].start) : h && (u = h.start, Jc(o, u)); else { let c; u = this.alignPlaylists(o, l.details, (c = this.levelLastLoaded) == null ? void 0 : c.details), u === 0 && h && (u = h.start, Jc(o, u)) } }l.details = o, this.levelLastLoaded = l, !this.startFragRequested && (this.mainDetails || !o.live) && this.setStartPosition(this.mainDetails || o, u), this.tick(), o.live && !this.fragCurrent && this.media && this.state === O.IDLE && (nl(null, o.fragments, this.media.currentTime, 0) || (this.warn('Subtitle playlist not aligned with playback'), l.details = void 0)) }_handleFragmentLoadComplete (e) { const { frag: t, payload: r } = e; const i = t.decryptdata; const s = this.hls; if (!this.fragContextChanged(t) && r && r.byteLength > 0 && i != null && i.key && i.iv && i.method === 'AES-128') { const o = performance.now(); this.decrypter.decrypt(new Uint8Array(r), i.key.buffer, i.iv.buffer).catch(a => { throw s.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.FRAG_DECRYPT_ERROR, fatal: !1, error: a, reason: a.message, frag: t }), a }).then(a => { const l = performance.now(); s.trigger(S.FRAG_DECRYPTED, { frag: t, payload: a, stats: { tstart: o, tdecrypt: l } }) }).catch(a => { this.warn(`${a.name}: ${a.message}`), this.state = O.IDLE }) } }doTick () { if (!this.media) { this.state = O.IDLE; return } if (this.state === O.IDLE) { const { currentTrackId: e, levels: t } = this; const r = t == null ? void 0 : t[e]; if (!r || !t.length || !r.details) return; const { config: i } = this; const s = this.getLoadPosition(); const o = de.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, i.maxBufferHole); const { end: a, len: l } = o; const u = this.getFwdBufferInfo(this.media, X.MAIN); const c = r.details; const d = this.getMaxBufferLength(u == null ? void 0 : u.len) + c.levelTargetDuration; if (l > d) return; const h = c.fragments; const f = h.length; const p = c.edge; let m = null; const y = this.fragPrevious; if (a < p) { const g = i.maxFragLookUpTolerance; const v = a > p - g ? 0 : g; m = nl(y, h, Math.max(h[0].start, a), v), !m && y && y.start < h[0].start && (m = h[0]) } else m = h[f - 1]; if (!m) return; if (m = this.mapToInitFragWhenRequired(m), m.sn !== 'initSegment') { const g = m.sn - c.startSN; const v = h[g - 1]; v && v.cc === m.cc && this.fragmentTracker.getState(v) === Ue.NOT_LOADED && (m = v) } this.fragmentTracker.getState(m) === Ue.NOT_LOADED && this.loadFragment(m, r, a) } }getMaxBufferLength (e) { const t = super.getMaxBufferLength(); return e ? Math.max(t, e) : t }loadFragment (e, t, r) { this.fragCurrent = e, e.sn === 'initSegment' ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) } get mediaBufferTimeRanges () { return new ZC(this.tracksBuffered[this.currentTrackId] || []) }} class ZC {constructor (e) { this.buffered = void 0; const t = (r, i, s) => { if (i = i >>> 0, i > s - 1) throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`); return e[i][r] }; this.buffered = { get length () { return e.length }, end (r) { return t('end', r, e.length) }, start (r) { return t('start', r, e.length) } } }} class eI extends Rh {constructor (e) { super(e, '[subtitle-track-controller]'), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.onTextTracksChanged = () => { if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return; let t = null; const r = fa(this.media.textTracks); for (let s = 0; s < r.length; s++) if (r[s].mode === 'hidden')t = r[s]; else if (r[s].mode === 'showing') { t = r[s]; break } const i = this.findTrackForTextTrack(t); this.subtitleTrack !== i && this.setSubtitleTrack(i) }, this.registerListeners() }destroy () { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy() } get subtitleDisplay () { return this._subtitleDisplay } set subtitleDisplay (e) { this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes() }registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.LEVEL_LOADING, this.onLevelLoading, this), e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(S.ERROR, this.onError, this) }unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.LEVEL_LOADING, this.onLevelLoading, this), e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(S.ERROR, this.onError, this) }onMediaAttached (e, t) { this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener('change', this.asyncPollTrackChange)) }pollTrackChange (e) { self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e) }onMediaDetaching () { if (!this.media) return; self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), fa(this.media.textTracks).forEach(t => { pi(t) }), this.subtitleTrack = -1, this.media = null }onManifestLoading () { this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0 }onManifestParsed (e, t) { this.tracks = t.subtitleTracks }onSubtitleTrackLoaded (e, t) { const { id: r, groupId: i, details: s } = t; const o = this.tracksInGroup[r]; if (!o || o.groupId !== i) { this.warn(`Subtitle track with id:${r} and group:${i} not found in active group ${o == null ? void 0 : o.groupId}`); return } const a = o.details; o.details = t.details, this.log(`Subtitle track ${r} "${o.name}" lang:${o.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a) }onLevelLoading (e, t) { this.switchLevel(t.level) }onLevelSwitching (e, t) { this.switchLevel(t.level) }switchLevel (e) { const t = this.hls.levels[e]; if (!t) return; const r = t.subtitleGroups || null; const i = this.groupIds; let s = this.currentTrack; if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some(o => (i == null ? void 0 : i.indexOf(o)) === -1)) { this.groupIds = r, this.trackId = -1, this.currentTrack = null; const o = this.tracks.filter(c => !r || r.indexOf(c.groupId) !== -1); if (o.length) this.selectDefaultTrack && !o.some(c => c.default) && (this.selectDefaultTrack = !1), o.forEach((c, d) => { c.id = d }); else if (!s && !this.tracksInGroup.length) return; this.tracksInGroup = o; const a = this.hls.config.subtitlePreference; if (!s && a) { this.selectDefaultTrack = !1; const c = cn(a, o); if (c > -1)s = o[c]; else { const d = cn(a, this.tracks); s = this.tracks[d] } } let l = this.findTrackId(s); l === -1 && s && (l = this.findTrackId(null)); const u = { subtitleTracks: o }; this.log(`Updating subtitle tracks, ${o.length} track(s) found in "${r == null ? void 0 : r.join(',')}" group-id`), this.hls.trigger(S.SUBTITLE_TRACKS_UPDATED, u), l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l) } else this.shouldReloadPlaylist(s) && this.setSubtitleTrack(this.trackId) }findTrackId (e) { const t = this.tracksInGroup; const r = this.selectDefaultTrack; for (let i = 0; i < t.length; i++) { const s = t[i]; if (!(r && !s.default || !r && !e) && (!e || xi(s, e))) return i } if (e) { for (let i = 0; i < t.length; i++) { const s = t[i]; if (qi(e.attrs, s.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) return i } for (let i = 0; i < t.length; i++) { const s = t[i]; if (qi(e.attrs, s.attrs, ['LANGUAGE'])) return i } } return -1 }findTrackForTextTrack (e) { if (e) { const t = this.tracksInGroup; for (let r = 0; r < t.length; r++) { const i = t[r]; if (td(i, e)) return r } } return -1 }onError (e, t) { t.fatal || !t.context || t.context.type === se.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t) } get allSubtitleTracks () { return this.tracks } get subtitleTracks () { return this.tracksInGroup } get subtitleTrack () { return this.trackId } set subtitleTrack (e) { this.selectDefaultTrack = !1, this.setSubtitleTrack(e) }setSubtitleOption (e) { if (this.hls.config.subtitlePreference = e, e) { const t = this.allSubtitleTracks; if (this.selectDefaultTrack = !1, t.length) { const r = this.currentTrack; if (r && xi(e, r)) return r; const i = cn(e, this.tracksInGroup); if (i > -1) { const s = this.tracksInGroup[i]; return this.setSubtitleTrack(i), s } else { if (r) return null; { const s = cn(e, t); if (s > -1) return t[s] } } } } return null }loadPlaylist (e) { super.loadPlaylist(); const t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { const r = t.id; const i = t.groupId; let s = t.url; if (e) try { s = e.addDirectives(s) } catch (o) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`) } this.log(`Loading subtitle playlist for id ${r}`), this.hls.trigger(S.SUBTITLE_TRACK_LOADING, { url: s, id: r, groupId: i, deliveryDirectives: e || null }) } }toggleTrackModes () { const { media: e } = this; if (!e) return; const t = fa(e.textTracks); const r = this.currentTrack; let i; if (r && (i = t.filter(s => td(r, s))[0], i || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`)), [].slice.call(t).forEach(s => { s.mode !== 'disabled' && s !== i && (s.mode = 'disabled') }), i) { const s = this.subtitleDisplay ? 'showing' : 'hidden'; i.mode !== s && (i.mode = s) } }setSubtitleTrack (e) { const t = this.tracksInGroup; if (!this.media) { this.queuedDefaultTrack = e; return } if (e < -1 || e >= t.length || !K(e)) { this.warn(`Invalid subtitle track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; const r = this.currentTrack; const i = t[e] || null; if (this.trackId = e, this.currentTrack = i, this.toggleTrackModes(), !i) { this.hls.trigger(S.SUBTITLE_TRACK_SWITCH, { id: e }); return } const s = !!i.details && !i.details.live; if (e === this.trackId && i === r && s) return; this.log(`Switching to subtitle-track ${e}` + (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : '')); const { id: o, groupId: a = '', name: l, type: u, url: c } = i; this.hls.trigger(S.SUBTITLE_TRACK_SWITCH, { id: o, groupId: a, name: l, type: u, url: c }); const d = this.switchParams(i.url, r == null ? void 0 : r.details, i.details); this.loadPlaylist(d) }} class tI {constructor (e) { this.buffers = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.buffers = e }append (e, t, r) { const i = this.queues[t]; i.push(e), i.length === 1 && !r && this.executeNext(t) }insertAbort (e, t) { this.queues[t].unshift(e), this.executeNext(t) }appendBlocker (e) { let t; const r = new Promise(s => { t = s }); const i = { execute: t, onStart: () => {}, onComplete: () => {}, onError: () => {} }; return this.append(i, e), r }executeNext (e) { const t = this.queues[e]; if (t.length) { const r = t[0]; try { r.execute() } catch (i) { C.warn(`[buffer-operation-queue]: Exception executing "${e}" SourceBuffer operation: ${i}`), r.onError(i); const s = this.buffers[e]; s != null && s.updating || this.shiftAndExecuteNext(e) } } }shiftAndExecuteNext (e) { this.queues[e].shift(), this.executeNext(e) }current (e) { return this.queues[e][0] }} const nm = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/; class nI {constructor (e) { this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = r => { this.hls && this.hls.pauseBuffering() }, this._onStartStreaming = r => { this.hls && this.hls.resumeBuffering() }, this._onMediaSourceOpen = () => { const { media: r, mediaSource: i } = this; this.log('Media source opened'), r && (r.removeEventListener('emptied', this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(S.MEDIA_ATTACHED, { media: r, mediaSource: i })), i && i.removeEventListener('sourceopen', this._onMediaSourceOpen), this.checkPendingTracks() }, this._onMediaSourceClose = () => { this.log('Media source closed') }, this._onMediaSourceEnded = () => { this.log('Media source ended') }, this._onMediaEmptied = () => { const { mediaSrc: r, _objectUrl: i } = this; r !== i && C.error(`Media element src was set while attaching MediaSource (${i} > ${r})`) }, this.hls = e; const t = '[buffer-controller]'; this.appendSource = hw($r(e.config.preferManagedMediaSource)), this.log = C.log.bind(C, t), this.warn = C.warn.bind(C, t), this.error = C.error.bind(C, t), this._initSourceBuffer(), this.registerListeners() }hasSourceTypes () { return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0 }destroy () { this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null }registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.BUFFER_RESET, this.onBufferReset, this), e.on(S.BUFFER_APPENDING, this.onBufferAppending, this), e.on(S.BUFFER_CODECS, this.onBufferCodecs, this), e.on(S.BUFFER_EOS, this.onBufferEos, this), e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(S.FRAG_PARSED, this.onFragParsed, this), e.on(S.FRAG_CHANGED, this.onFragChanged, this) }unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.BUFFER_RESET, this.onBufferReset, this), e.off(S.BUFFER_APPENDING, this.onBufferAppending, this), e.off(S.BUFFER_CODECS, this.onBufferCodecs, this), e.off(S.BUFFER_EOS, this.onBufferEos, this), e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(S.FRAG_PARSED, this.onFragParsed, this), e.off(S.FRAG_CHANGED, this.onFragChanged, this) }_initSourceBuffer () { this.sourceBuffer = {}, this.operationQueue = new tI(this.sourceBuffer), this.listeners = { audio: [], video: [], audiovideo: [] }, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.lastMpegAudioChunk = null }onManifestLoading () { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null }onManifestParsed (e, t) { let r = 2; (t.audio && !t.video || !t.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`) }onMediaAttaching (e, t) { const r = this.media = t.media; const i = $r(this.appendSource); if (r && i) { let s; const o = this.mediaSource = new i(); this.log(`created media source: ${(s = o.constructor) == null ? void 0 : s.name}`), o.addEventListener('sourceopen', this._onMediaSourceOpen), o.addEventListener('sourceended', this._onMediaSourceEnded), o.addEventListener('sourceclose', this._onMediaSourceClose), this.appendSource && (o.addEventListener('startstreaming', this._onStartStreaming), o.addEventListener('endstreaming', this._onEndStreaming)); const a = this._objectUrl = self.URL.createObjectURL(o); if (this.appendSource) try { r.removeAttribute('src'); const l = self.ManagedMediaSource; r.disableRemotePlayback = r.disableRemotePlayback || l && o instanceof l, rm(r), rI(r, a), r.load() } catch { r.src = a } else r.src = a; r.addEventListener('emptied', this._onMediaEmptied) } }onMediaDetaching () { const { media: e, mediaSource: t, _objectUrl: r } = this; if (t) { if (this.log('media source detaching'), t.readyState === 'open') try { t.endOfStream() } catch (i) { this.warn(`onMediaDetaching: ${i.message} while calling endOfStream`) } this.onBufferReset(), t.removeEventListener('sourceopen', this._onMediaSourceOpen), t.removeEventListener('sourceended', this._onMediaSourceEnded), t.removeEventListener('sourceclose', this._onMediaSourceClose), this.appendSource && (t.removeEventListener('startstreaming', this._onStartStreaming), t.removeEventListener('endstreaming', this._onEndStreaming)), e && (e.removeEventListener('emptied', this._onMediaEmptied), r && self.URL.revokeObjectURL(r), this.mediaSrc === r ? (e.removeAttribute('src'), this.appendSource && rm(e), e.load()) : this.warn('media|source.src was changed by a third party - skip cleanup')), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {} } this.hls.trigger(S.MEDIA_DETACHED, void 0) }onBufferReset () { this.getSourceBufferTypes().forEach(e => { this.resetBuffer(e) }), this._initSourceBuffer() }resetBuffer (e) { const t = this.sourceBuffer[e]; try { if (t) { let r; this.removeBufferListeners(e), this.sourceBuffer[e] = void 0, (r = this.mediaSource) != null && r.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t) } } catch (i) { this.warn(`onBufferReset ${e}`, i) } }onBufferCodecs (e, t) { const r = this.getSourceBufferTypes().length; const i = Object.keys(t); if (i.forEach(o => { if (r) { const l = this.tracks[o]; if (l && typeof l.buffer.changeType === 'function') { let a; const { id: u, codec: c, levelCodec: d, container: h, metadata: f } = t[o]; const p = Rp(l.codec, l.levelCodec); const m = p == null ? void 0 : p.replace(nm, '$1'); let y = Rp(c, d); const g = (a = y) == null ? void 0 : a.replace(nm, '$1'); if (y && m !== g) { o.slice(0, 5) === 'audio' && (y = Ja(y, this.appendSource)); const v = `${h};codecs=${y}`; this.appendChangeType(o, v), this.log(`switching codec ${p} to ${y}`), this.tracks[o] = { buffer: l.buffer, codec: c, container: h, levelCodec: d, metadata: f, id: u } } } } else this.pendingTracks[o] = t[o] }), r) return; const s = Math.max(this.bufferCodecEventsExpected - 1, 0); this.bufferCodecEventsExpected !== s && (this.log(`${s} bufferCodec event(s) expected ${i.join(',')}`), this.bufferCodecEventsExpected = s), this.mediaSource && this.mediaSource.readyState === 'open' && this.checkPendingTracks() }appendChangeType (e, t) { const { operationQueue: r } = this; const i = { execute: () => { const s = this.sourceBuffer[e]; s && (this.log(`changing ${e} sourceBuffer type to ${t}`), s.changeType(t)), r.shiftAndExecuteNext(e) }, onStart: () => {}, onComplete: () => {}, onError: s => { this.warn(`Failed to change ${e} SourceBuffer type`, s) } }; r.append(i, e, !!this.pendingTracks[e]) }onBufferAppending (e, t) { const { hls: r, operationQueue: i, tracks: s } = this; const { data: o, type: a, frag: l, part: u, chunkMeta: c } = t; const d = c.buffering[a]; const h = self.performance.now(); d.start = h; const f = l.stats.buffering; const p = u ? u.stats.buffering : null; f.start === 0 && (f.start = h), p && p.start === 0 && (p.start = h); const m = s.audio; let y = !1; a === 'audio' && (m == null ? void 0 : m.container) === 'audio/mpeg' && (y = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c); const g = l.start; const v = { execute: () => { if (d.executeStart = self.performance.now(), y) { const E = this.sourceBuffer[a]; if (E) { const x = g - E.timestampOffset; Math.abs(x) >= 0.1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${g} (delta: ${x}) sn: ${l.sn})`), E.timestampOffset = g) } } this.appendExecutor(o, a) }, onStart: () => {}, onComplete: () => { const E = self.performance.now(); d.executeEnd = d.end = E, f.first === 0 && (f.first = E), p && p.first === 0 && (p.first = E); const { sourceBuffer: x } = this; const T = {}; for (const w in x)T[w] = de.getBuffered(x[w]); this.appendErrors[a] = 0, a === 'audio' || a === 'video' ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(S.BUFFER_APPENDED, { type: a, frag: l, part: u, chunkMeta: c, parent: l.type, timeRanges: T }) }, onError: E => { const x = { type: J.MEDIA_ERROR, parent: l.type, details: D.BUFFER_APPEND_ERROR, sourceBufferName: a, frag: l, part: u, chunkMeta: c, error: E, err: E, fatal: !1 }; if (E.code === DOMException.QUOTA_EXCEEDED_ERR)x.details = D.BUFFER_FULL_ERROR; else { const T = ++this.appendErrors[a]; x.details = D.BUFFER_APPEND_ERROR, this.warn(`Failed ${T}/${r.config.appendErrorMaxRetry} times to append segment in "${a}" sourceBuffer`), T >= r.config.appendErrorMaxRetry && (x.fatal = !0) }r.trigger(S.ERROR, x) } }; i.append(v, a, !!this.pendingTracks[a]) }onBufferFlushing (e, t) { const { operationQueue: r } = this; const i = s => ({ execute: this.removeExecutor.bind(this, s, t.startOffset, t.endOffset), onStart: () => {}, onComplete: () => { this.hls.trigger(S.BUFFER_FLUSHED, { type: s }) }, onError: o => { this.warn(`Failed to remove from ${s} SourceBuffer`, o) } }); t.type ? r.append(i(t.type), t.type) : this.getSourceBufferTypes().forEach(s => { r.append(i(s), s) }) }onFragParsed (e, t) { const { frag: r, part: i } = t; const s = []; const o = i ? i.elementaryStreams : r.elementaryStreams; o[ae.AUDIOVIDEO] ? s.push('audiovideo') : (o[ae.AUDIO] && s.push('audio'), o[ae.VIDEO] && s.push('video')); const a = () => { const l = self.performance.now(); r.stats.buffering.end = l, i && (i.stats.buffering.end = l); const u = i ? i.stats : r.stats; this.hls.trigger(S.FRAG_BUFFERED, { frag: r, part: i, stats: u, id: r.type }) }; s.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(a, s) }onFragChanged (e, t) { this.trimBuffers() }onBufferEos (e, t) { this.getSourceBufferTypes().reduce((i, s) => { const o = this.sourceBuffer[s]; return o && (!t.type || t.type === s) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${s} sourceBuffer now EOS`))), i && !!(!o || o.ended) }, !0) && (this.log('Queueing mediaSource.endOfStream()'), this.blockBuffers(() => { this.getSourceBufferTypes().forEach(s => { const o = this.sourceBuffer[s]; o && (o.ending = !1) }); const { mediaSource: i } = this; if (!i || i.readyState !== 'open') { i && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${i.readyState}`); return } this.log('Calling mediaSource.endOfStream()'), i.endOfStream() })) }onLevelUpdated (e, { details: t }) { t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration()) }trimBuffers () { const { hls: e, details: t, media: r } = this; if (!r || t === null || !this.getSourceBufferTypes().length) return; const s = e.config; const o = r.currentTime; const a = t.levelTargetDuration; const l = t.live && s.liveBackBufferLength !== null ? s.liveBackBufferLength : s.backBufferLength; if (K(l) && l > 0) { const u = Math.max(l, a); const c = Math.floor(o / a) * a - u; this.flushBackBuffer(o, a, c) } if (K(s.frontBufferFlushThreshold) && s.frontBufferFlushThreshold > 0) { const u = Math.max(s.maxBufferLength, s.frontBufferFlushThreshold); const c = Math.max(u, a); const d = Math.floor(o / a) * a + c; this.flushFrontBuffer(o, a, d) } }flushBackBuffer (e, t, r) { const { details: i, sourceBuffer: s } = this; this.getSourceBufferTypes().forEach(a => { const l = s[a]; if (l) { const u = de.getBuffered(l); if (u.length > 0 && r > u.start(0)) { if (this.hls.trigger(S.BACK_BUFFER_REACHED, { bufferEnd: r }), i != null && i.live) this.hls.trigger(S.LIVE_BACK_BUFFER_REACHED, { bufferEnd: r }); else if (l.ended && u.end(u.length - 1) - e < t * 2) { this.log(`Cannot flush ${a} back buffer while SourceBuffer is in ended state`); return } this.hls.trigger(S.BUFFER_FLUSHING, { startOffset: 0, endOffset: r, type: a }) } } }) }flushFrontBuffer (e, t, r) { const { sourceBuffer: i } = this; this.getSourceBufferTypes().forEach(o => { const a = i[o]; if (a) { const l = de.getBuffered(a); const u = l.length; if (u < 2) return; const c = l.start(u - 1); const d = l.end(u - 1); if (r > c || e >= c && e <= d) return; if (a.ended && e - d < 2 * t) { this.log(`Cannot flush ${o} front buffer while SourceBuffer is in ended state`); return } this.hls.trigger(S.BUFFER_FLUSHING, { startOffset: c, endOffset: 1 / 0, type: o }) } }) }updateMediaElementDuration () { if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') return; const { details: e, hls: t, media: r, mediaSource: i } = this; const s = e.fragments[0].start + e.totalduration; const o = r.duration; const a = K(i.duration) ? i.duration : 0; e.live && t.config.liveDurationInfinity ? (i.duration = 1 / 0, this.updateSeekableRange(e)) : (s > a && s > o || !K(o)) && (this.log(`Updating Media Source duration to ${s.toFixed(3)}`), i.duration = s) }updateSeekableRange (e) { const t = this.mediaSource; const r = e.fragments; if (r.length && e.live && t != null && t.setLiveSeekableRange) { const s = Math.max(0, r[0].start); const o = Math.max(s, s + e.totalduration); this.log(`Media Source duration is set to ${t.duration}. Setting seekable range to ${s}-${o}.`), t.setLiveSeekableRange(s, o) } }checkPendingTracks () { const { bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: r } = this; const i = Object.keys(r).length; if (i && (!e || i === 2 || 'audiovideo' in r)) { this.createSourceBuffers(r), this.pendingTracks = {}; const s = this.getSourceBufferTypes(); if (s.length) this.hls.trigger(S.BUFFER_CREATED, { tracks: this.tracks }), s.forEach(o => { t.executeNext(o) }); else { const o = new Error('could not create source buffer for media codec(s)'); this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: !0, error: o, reason: o.message }) } } }createSourceBuffers (e) { const { sourceBuffer: t, mediaSource: r } = this; if (!r) throw Error('createSourceBuffers called when mediaSource was null'); for (const s in e) if (!t[s]) { var i; const o = e[s]; if (!o) throw Error(`source buffer exists for track ${s}, however track does not`); let a = ((i = o.levelCodec) == null ? void 0 : i.indexOf(',')) === -1 ? o.levelCodec : o.codec; a && s.slice(0, 5) === 'audio' && (a = Ja(a, this.appendSource)); const l = `${o.container};codecs=${a}`; this.log(`creating sourceBuffer(${l})`); try { const u = t[s] = r.addSourceBuffer(l); const c = s; this.addBufferListener(c, 'updatestart', this._onSBUpdateStart), this.addBufferListener(c, 'updateend', this._onSBUpdateEnd), this.addBufferListener(c, 'error', this._onSBUpdateError), this.appendSource && this.addBufferListener(c, 'bufferedchange', (d, h) => { const f = h.removedRanges; f != null && f.length && this.hls.trigger(S.BUFFER_FLUSHED, { type: s }) }), this.tracks[s] = { buffer: u, codec: a, container: o.container, levelCodec: o.levelCodec, metadata: o.metadata, id: o.id } } catch (u) { this.error(`error while trying to add sourceBuffer: ${u.message}`), this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_ADD_CODEC_ERROR, fatal: !1, error: u, sourceBufferName: s, mimeType: l }) } } } get mediaSrc () { let e; const t = ((e = this.media) == null ? void 0 : e.firstChild) || this.media; return t == null ? void 0 : t.src }_onSBUpdateStart (e) { const { operationQueue: t } = this; t.current(e).onStart() }_onSBUpdateEnd (e) { let t; if (((t = this.mediaSource) == null ? void 0 : t.readyState) === 'closed') { this.resetBuffer(e); return } const { operationQueue: r } = this; r.current(e).onComplete(), r.shiftAndExecuteNext(e) }_onSBUpdateError (e, t) { let r; const i = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`); this.error(`${i}`, t), this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_APPENDING_ERROR, sourceBufferName: e, error: i, fatal: !1 }); const s = this.operationQueue.current(e); s && s.onError(i) }removeExecutor (e, t, r) { const { media: i, mediaSource: s, operationQueue: o, sourceBuffer: a } = this; const l = a[e]; if (!i || !s || !l) { this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), o.shiftAndExecuteNext(e); return } const u = K(i.duration) ? i.duration : 1 / 0; const c = K(s.duration) ? s.duration : 1 / 0; const d = Math.max(0, t); const h = Math.min(r, u, c); h > d && (!l.ending || l.ended) ? (l.ended = !1, this.log(`Removing [${d},${h}] from the ${e} SourceBuffer`), l.remove(d, h)) : o.shiftAndExecuteNext(e) }appendExecutor (e, t) { const r = this.sourceBuffer[t]; if (!r) { if (!this.pendingTracks[t]) throw new Error(`Attempting to append to the ${t} SourceBuffer, but it does not exist`); return }r.ended = !1, r.appendBuffer(e) }blockBuffers (e, t = this.getSourceBufferTypes()) { if (!t.length) { this.log('Blocking operation requested, but no SourceBuffers exist'), Promise.resolve().then(e); return } const { operationQueue: r } = this; const i = t.map(s => r.appendBlocker(s)); Promise.all(i).then(() => { e(), t.forEach(s => { const o = this.sourceBuffer[s]; o != null && o.updating || r.shiftAndExecuteNext(s) }) }) }getSourceBufferTypes () { return Object.keys(this.sourceBuffer) }addBufferListener (e, t, r) { const i = this.sourceBuffer[e]; if (!i) return; const s = r.bind(this, e); this.listeners[e].push({ event: t, listener: s }), i.addEventListener(t, s) }removeBufferListeners (e) { const t = this.sourceBuffer[e]; t && this.listeners[e].forEach(r => { t.removeEventListener(r.event, r.listener) }) }} function rm (n) { const e = n.querySelectorAll('source'); [].slice.call(e).forEach(t => { n.removeChild(t) }) } function rI (n, e) { const t = self.document.createElement('source'); t.type = 'video/mp4', t.src = e, n.appendChild(t) } const im = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }; const Vv = function (e) { let t = e; return im.hasOwnProperty(e) && (t = im[e]), String.fromCharCode(t) }; const Ht = 15; const gn = 100; const iI = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }; const sI = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }; const oI = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }; const aI = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }; const lI = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent']; class uI {constructor () { this.time = null, this.verboseLevel = 0 }log (e, t) { if (this.verboseLevel >= e) { const r = typeof t === 'function' ? t() : t; C.log(`${this.time} [${e}] ${r}`) } }} const mr = function (e) { const t = []; for (let r = 0; r < e.length; r++)t.push(e[r].toString(16)); return t }; class Hv {constructor () { this.foreground = 'white', this.underline = !1, this.italics = !1, this.background = 'black', this.flash = !1 }reset () { this.foreground = 'white', this.underline = !1, this.italics = !1, this.background = 'black', this.flash = !1 }setStyles (e) { const t = ['foreground', 'underline', 'italics', 'background', 'flash']; for (let r = 0; r < t.length; r++) { const i = t[r]; e.hasOwnProperty(i) && (this[i] = e[i]) } }isDefault () { return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash }equals (e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash }copy (e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash }toString () { return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash }} class cI {constructor () { this.uchar = ' ', this.penState = new Hv() }reset () { this.uchar = ' ', this.penState.reset() }setChar (e, t) { this.uchar = e, this.penState.copy(t) }setPenState (e) { this.penState.copy(e) }equals (e) { return this.uchar === e.uchar && this.penState.equals(e.penState) }copy (e) { this.uchar = e.uchar, this.penState.copy(e.penState) }isEmpty () { return this.uchar === ' ' && this.penState.isDefault() }} class dI {constructor (e) { this.chars = [], this.pos = 0, this.currPenState = new Hv(), this.cueStartTime = null, this.logger = void 0; for (let t = 0; t < gn; t++) this.chars.push(new cI()); this.logger = e }equals (e) { for (let t = 0; t < gn; t++) if (!this.chars[t].equals(e.chars[t])) return !1; return !0 }copy (e) { for (let t = 0; t < gn; t++) this.chars[t].copy(e.chars[t]) }isEmpty () { let e = !0; for (let t = 0; t < gn; t++) if (!this.chars[t].isEmpty()) { e = !1; break } return e }setCursor (e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, 'Negative cursor position ' + this.pos), this.pos = 0) : this.pos > gn && (this.logger.log(3, 'Too large cursor position ' + this.pos), this.pos = gn) }moveCursor (e) { const t = this.pos + e; if (e > 1) for (let r = this.pos + 1; r < t + 1; r++) this.chars[r].setPenState(this.currPenState); this.setCursor(t) }backSpace () { this.moveCursor(-1), this.chars[this.pos].setChar(' ', this.currPenState) }insertChar (e) { e >= 144 && this.backSpace(); const t = Vv(e); if (this.pos >= gn) { this.logger.log(0, () => 'Cannot insert ' + e.toString(16) + ' (' + t + ') at position ' + this.pos + '. Skipping it!'); return } this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1) }clearFromPos (e) { let t; for (t = e; t < gn; t++) this.chars[t].reset() }clear () { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() }clearToEndOfRow () { this.clearFromPos(this.pos) }getTextString () { const e = []; let t = !0; for (let r = 0; r < gn; r++) { const i = this.chars[r].uchar; i !== ' ' && (t = !1), e.push(i) } return t ? '' : e.join('') }setPenStyles (e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState) }} class Au {
  constructor (e) { this.rows = [], this.currRow = Ht - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0; for (let t = 0; t < Ht; t++) this.rows.push(new dI(e)); this.logger = e }reset () { for (let e = 0; e < Ht; e++) this.rows[e].clear(); this.currRow = Ht - 1 }equals (e) { let t = !0; for (let r = 0; r < Ht; r++) if (!this.rows[r].equals(e.rows[r])) { t = !1; break } return t }copy (e) { for (let t = 0; t < Ht; t++) this.rows[t].copy(e.rows[t]) }isEmpty () { let e = !0; for (let t = 0; t < Ht; t++) if (!this.rows[t].isEmpty()) { e = !1; break } return e }backSpace () { this.rows[this.currRow].backSpace() }clearToEndOfRow () { this.rows[this.currRow].clearToEndOfRow() }insertChar (e) { this.rows[this.currRow].insertChar(e) }setPen (e) { this.rows[this.currRow].setPenStyles(e) }moveCursor (e) { this.rows[this.currRow].moveCursor(e) }setCursor (e) { this.logger.log(2, 'setCursor: ' + e), this.rows[this.currRow].setCursor(e) }setPAC (e) { this.logger.log(2, () => 'pacData = ' + JSON.stringify(e)); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let a = 0; a < Ht; a++) this.rows[a].clear(); const s = this.currRow + 1 - this.nrRollUpRows; const o = this.lastOutputScreen; if (o) { const a = o.rows[s].cueStartTime; const l = this.logger.time; if (a !== null && l !== null && a < l) for (let u = 0; u < this.nrRollUpRows; u++) this.rows[t - this.nrRollUpRows + u + 1].copy(o.rows[s + u]) } } this.currRow = t; const r = this.rows[this.currRow]; if (e.indent !== null) { const s = e.indent; const o = Math.max(s - 1, 0); r.setCursor(e.indent), e.color = r.chars[o].penState.foreground } const i = { foreground: e.color, underline: e.underline, italics: e.italics, background: 'black', flash: !1 }; this.setPen(i) }setBkgData (e) { this.logger.log(2, () => 'bkgData = ' + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32) }setRollUpRows (e) { this.nrRollUpRows = e }rollUp () { if (this.nrRollUpRows === null) { this.logger.log(3, 'roll_up but nrRollUpRows not set yet'); return } this.logger.log(1, () => this.getDisplayText()); const e = this.currRow + 1 - this.nrRollUpRows; const t = this.rows.splice(e, 1)[0]; t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, 'Rolling up') }getDisplayText (e) {
    e = e || !1; const t = []; let r = ''; let i = -1; for (let s = 0; s < Ht; s++) { const o = this.rows[s].getTextString(); o && (i = s + 1, e ? t.push('Row ' + i + ": '" + o + "'") : t.push(o.trim())) } return t.length > 0 && (e
      ? r = '[' + t.join(' | ') + ']'
      : r = t.join(`
`)), r
  }

  getTextAndFormat () { return this.rows }
} class sm {constructor (e, t, r) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Au(r), this.nonDisplayedMemory = new Au(r), this.lastOutputScreen = new Au(r), this.currRollUpRow = this.displayedMemory.rows[Ht - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r }reset () { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Ht - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null }getHandler () { return this.outputFilter }setHandler (e) { this.outputFilter = e }setPAC (e) { this.writeScreen.setPAC(e) }setBkgData (e) { this.writeScreen.setBkgData(e) }setMode (e) { e !== this.mode && (this.mode = e, this.logger.log(2, () => 'MODE=' + e), this.mode === 'MODE_POP-ON' ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== 'MODE_ROLL-UP' && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) }insertChars (e) { for (let r = 0; r < e.length; r++) this.writeScreen.insertChar(e[r]); const t = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP'; this.logger.log(2, () => t + ': ' + this.writeScreen.getDisplayText(!0)), (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') && (this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) }ccRCL () { this.logger.log(2, 'RCL - Resume Caption Loading'), this.setMode('MODE_POP-ON') }ccBS () { this.logger.log(2, 'BS - BackSpace'), this.mode !== 'MODE_TEXT' && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()) }ccAOF () {}ccAON () {}ccDER () { this.logger.log(2, 'DER- Delete to End of Row'), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() }ccRU (e) { this.logger.log(2, 'RU(' + e + ') - Roll Up'), this.writeScreen = this.displayedMemory, this.setMode('MODE_ROLL-UP'), this.writeScreen.setRollUpRows(e) }ccFON () { this.logger.log(2, 'FON - Flash On'), this.writeScreen.setPen({ flash: !0 }) }ccRDC () { this.logger.log(2, 'RDC - Resume Direct Captioning'), this.setMode('MODE_PAINT-ON') }ccTR () { this.logger.log(2, 'TR'), this.setMode('MODE_TEXT') }ccRTD () { this.logger.log(2, 'RTD'), this.setMode('MODE_TEXT') }ccEDM () { this.logger.log(2, 'EDM - Erase Displayed Memory'), this.displayedMemory.reset(), this.outputDataUpdate(!0) }ccCR () { this.logger.log(2, 'CR - Carriage Return'), this.writeScreen.rollUp(), this.outputDataUpdate(!0) }ccENM () { this.logger.log(2, 'ENM - Erase Non-displayed Memory'), this.nonDisplayedMemory.reset() }ccEOC () { if (this.logger.log(2, 'EOC - End Of Caption'), this.mode === 'MODE_POP-ON') { const e = this.displayedMemory; this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText()) } this.outputDataUpdate(!0) }ccTO (e) { this.logger.log(2, 'TO(' + e + ') - Tab Offset'), this.writeScreen.moveCursor(e) }ccMIDROW (e) { const t = { flash: !1 }; if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics)t.foreground = 'white'; else { const r = Math.floor(e / 2) - 16; const i = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta']; t.foreground = i[r] } this.logger.log(2, 'MIDROW: ' + JSON.stringify(t)), this.writeScreen.setPen(t) }outputDataUpdate (e = !1) { const t = this.logger.time; t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory)) }cueSplitAtTime (e) { this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e)) }} class om {constructor (e, t, r) { this.channels = void 0, this.currentChannel = 0, this.cmdHistory = lm(), this.logger = void 0; const i = this.logger = new uI(); this.channels = [null, new sm(e, t, i), new sm(e + 1, r, i)] }getHandler (e) { return this.channels[e].getHandler() }setHandler (e, t) { this.channels[e].setHandler(t) }addData (e, t) { let r; let i; let s; let o = !1; this.logger.time = e; for (let a = 0; a < t.length; a += 2) if (i = t[a] & 127, s = t[a + 1] & 127, !(i === 0 && s === 0)) { if (this.logger.log(3, '[' + mr([t[a], t[a + 1]]) + '] -> (' + mr([i, s]) + ')'), r = this.parseCmd(i, s), r || (r = this.parseMidrow(i, s)), r || (r = this.parsePAC(i, s)), r || (r = this.parseBackgroundAttributes(i, s)), !r && (o = this.parseChars(i, s), o)) { const l = this.currentChannel; l && l > 0 ? this.channels[l].insertChars(o) : this.logger.log(2, 'No channel found yet. TEXT-MODE?') }!r && !o && this.logger.log(2, "Couldn't parse cleaned data " + mr([i, s]) + ' orig: ' + mr([t[a], t[a + 1]])) } }parseCmd (e, t) { const { cmdHistory: r } = this; const i = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47; const s = (e === 23 || e === 31) && t >= 33 && t <= 35; if (!(i || s)) return !1; if (am(e, t, r)) return Zr(null, null, r), this.logger.log(3, 'Repeated command (' + mr([e, t]) + ') is dropped'), !0; const o = e === 20 || e === 21 || e === 23 ? 1 : 2; const a = this.channels[o]; return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32), Zr(e, t, r), this.currentChannel = o, !0 }parseMidrow (e, t) { let r = 0; if ((e === 17 || e === 25) && t >= 32 && t <= 47) { if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel) return this.logger.log(0, 'Mismatch channel in midrow parsing'), !1; const i = this.channels[r]; return i ? (i.ccMIDROW(t), this.logger.log(3, 'MIDROW (' + mr([e, t]) + ')'), !0) : !1 } return !1 }parsePAC (e, t) { let r; const i = this.cmdHistory; const s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127; const o = (e === 16 || e === 24) && t >= 64 && t <= 95; if (!(s || o)) return !1; if (am(e, t, i)) return Zr(null, null, i), !0; const a = e <= 23 ? 1 : 2; t >= 64 && t <= 95 ? r = a === 1 ? iI[e] : oI[e] : r = a === 1 ? sI[e] : aI[e]; const l = this.channels[a]; return l ? (l.setPAC(this.interpretPAC(r, t)), Zr(e, t, i), this.currentChannel = a, !0) : !1 }interpretPAC (e, t) { let r; const i = { color: null, italics: !1, indent: null, underline: !1, row: e }; return t > 95 ? r = t - 96 : r = t - 64, i.underline = (r & 1) === 1, r <= 13 ? i.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = 'white') : i.indent = Math.floor((r - 16) / 2) * 4, i }parseChars (e, t) { let r; let i = null; let s = null; if (e >= 25 ? (r = 2, s = e - 8) : (r = 1, s = e), s >= 17 && s <= 19) { let o; s === 17 ? o = t + 80 : s === 18 ? o = t + 112 : o = t + 144, this.logger.log(2, "Special char '" + Vv(o) + "' in channel " + r), i = [o] } else e >= 32 && e <= 127 && (i = t === 0 ? [e] : [e, t]); if (i) { const o = mr(i); this.logger.log(3, 'Char codes =  ' + o.join(',')), Zr(e, t, this.cmdHistory) } return i }parseBackgroundAttributes (e, t) { const r = (e === 16 || e === 24) && t >= 32 && t <= 47; const i = (e === 23 || e === 31) && t >= 45 && t <= 47; if (!(r || i)) return !1; let s; const o = {}; e === 16 || e === 24 ? (s = Math.floor((t - 32) / 2), o.background = lI[s], t % 2 === 1 && (o.background = o.background + '_semi')) : t === 45 ? o.background = 'transparent' : (o.foreground = 'black', t === 47 && (o.underline = !0)); const a = e <= 23 ? 1 : 2; return this.channels[a].setBkgData(o), Zr(e, t, this.cmdHistory), !0 }reset () { for (let e = 0; e < Object.keys(this.channels).length; e++) { const t = this.channels[e]; t && t.reset() } this.cmdHistory = lm() }cueSplitAtTime (e) { for (let t = 0; t < this.channels.length; t++) { const r = this.channels[t]; r && r.cueSplitAtTime(e) } }} function Zr (n, e, t) { t.a = n, t.b = e } function am (n, e, t) { return t.a === n && t.b === e } function lm () { return { a: null, b: null } } class Yo {constructor (e, t) { this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t }dispatchCue () { this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null) }newCue (e, t, r) { (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName) }reset () { this.cueRanges = [], this.startTime = null }} const bh = (function () { if (Wi != null && Wi.VTTCue) return self.VTTCue; const n = ['', 'lr', 'rl']; const e = ['start', 'middle', 'end', 'left', 'right']; function t (a, l) { if (typeof l !== 'string' || !Array.isArray(a)) return !1; const u = l.toLowerCase(); return ~a.indexOf(u) ? u : !1 } function r (a) { return t(n, a) } function i (a) { return t(e, a) } function s (a, ...l) { let u = 1; for (;u < arguments.length; u++) { const c = arguments[u]; for (const d in c)a[d] = c[d] } return a } function o (a, l, u) { const c = this; const d = { enumerable: !0 }; c.hasBeenReset = !1; let h = ''; let f = !1; let p = a; let m = l; let y = u; let g = null; let v = ''; let E = !0; let x = 'auto'; let T = 'start'; let w = 50; let L = 'middle'; let A = 50; let P = 'middle'; Object.defineProperty(c, 'id', s({}, d, { get: function () { return h }, set: function (_) { h = '' + _ } })), Object.defineProperty(c, 'pauseOnExit', s({}, d, { get: function () { return f }, set: function (_) { f = !!_ } })), Object.defineProperty(c, 'startTime', s({}, d, { get: function () { return p }, set: function (_) { if (typeof _ !== 'number') throw new TypeError('Start time must be set to a number.'); p = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'endTime', s({}, d, { get: function () { return m }, set: function (_) { if (typeof _ !== 'number') throw new TypeError('End time must be set to a number.'); m = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'text', s({}, d, { get: function () { return y }, set: function (_) { y = '' + _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'region', s({}, d, { get: function () { return g }, set: function (_) { g = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'vertical', s({}, d, { get: function () { return v }, set: function (_) { const F = r(_); if (F === !1) throw new SyntaxError('An invalid or illegal string was specified.'); v = F, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'snapToLines', s({}, d, { get: function () { return E }, set: function (_) { E = !!_, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'line', s({}, d, { get: function () { return x }, set: function (_) { if (typeof _ !== 'number' && _ !== 'auto') throw new SyntaxError('An invalid number or illegal string was specified.'); x = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'lineAlign', s({}, d, { get: function () { return T }, set: function (_) { const F = i(_); if (!F) throw new SyntaxError('An invalid or illegal string was specified.'); T = F, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'position', s({}, d, { get: function () { return w }, set: function (_) { if (_ < 0 || _ > 100) throw new Error('Position must be between 0 and 100.'); w = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'positionAlign', s({}, d, { get: function () { return L }, set: function (_) { const F = i(_); if (!F) throw new SyntaxError('An invalid or illegal string was specified.'); L = F, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'size', s({}, d, { get: function () { return A }, set: function (_) { if (_ < 0 || _ > 100) throw new Error('Size must be between 0 and 100.'); A = _, this.hasBeenReset = !0 } })), Object.defineProperty(c, 'align', s({}, d, { get: function () { return P }, set: function (_) { const F = i(_); if (!F) throw new SyntaxError('An invalid or illegal string was specified.'); P = F, this.hasBeenReset = !0 } })), c.displayState = void 0 } return o.prototype.getCueAsHTML = function () { return self.WebVTT.convertCueToDOMTree(self, this.text) }, o }()); class hI {decode (e, t) { if (!e) return ''; if (typeof e !== 'string') throw new Error('Error - expected string data.'); return decodeURIComponent(encodeURIComponent(e)) }} function Kv (n) { function e (r, i, s, o) { return (r | 0) * 3600 + (i | 0) * 60 + (s | 0) + parseFloat(o || 0) } const t = n.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/); return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null } class fI {constructor () { this.values = Object.create(null) }set (e, t) { !this.get(e) && t !== '' && (this.values[e] = t) }get (e, t, r) { return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t }has (e) { return e in this.values }alt (e, t, r) { for (let i = 0; i < r.length; ++i) if (t === r[i]) { this.set(e, t); break } }integer (e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) }percent (e, t) { if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) { const r = parseFloat(t); if (r >= 0 && r <= 100) return this.set(e, r), !0 } return !1 }} function jv (n, e, t, r) { const i = r ? n.split(r) : [n]; for (const s in i) { if (typeof i[s] !== 'string') continue; const o = i[s].split(t); if (o.length !== 2) continue; const a = o[0]; const l = o[1]; e(a, l) } } const nd = new bh(0, 0, ''); const qo = nd.align === 'middle' ? 'middle' : 'center'; function pI (n, e, t) { const r = n; function i () { const a = Kv(n); if (a === null) throw new Error('Malformed timestamp: ' + r); return n = n.replace(/^[^\sa-zA-Z-]+/, ''), a } function s (a, l) { const u = new fI(); jv(a, function (h, f) { let p; switch (h) { case 'region':for (let m = t.length - 1; m >= 0; m--) if (t[m].id === f) { u.set(h, t[m].region); break } break; case 'vertical':u.alt(h, f, ['rl', 'lr']); break; case 'line':p = f.split(','), u.integer(h, p[0]), u.percent(h, p[0]) && u.set('snapToLines', !1), u.alt(h, p[0], ['auto']), p.length === 2 && u.alt('lineAlign', p[1], ['start', qo, 'end']); break; case 'position':p = f.split(','), u.percent(h, p[0]), p.length === 2 && u.alt('positionAlign', p[1], ['start', qo, 'end', 'line-left', 'line-right', 'auto']); break; case 'size':u.percent(h, f); break; case 'align':u.alt(h, f, ['start', qo, 'end', 'left', 'right']); break } }, /:/, /\s/), l.region = u.get('region', null), l.vertical = u.get('vertical', ''); let c = u.get('line', 'auto'); c === 'auto' && nd.line === -1 && (c = -1), l.line = c, l.lineAlign = u.get('lineAlign', 'start'), l.snapToLines = u.get('snapToLines', !0), l.size = u.get('size', 100), l.align = u.get('align', qo); let d = u.get('position', 'auto'); d === 'auto' && nd.position === 50 && (d = l.align === 'start' || l.align === 'left' ? 0 : l.align === 'end' || l.align === 'right' ? 100 : 50), l.position = d } function o () { n = n.replace(/^\s+/, '') } if (o(), e.startTime = i(), o(), n.slice(0, 3) !== '-->') throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r); n = n.slice(3), o(), e.endTime = i(), o(), s(n, e) } function zv (n) {
  return n.replace(/<br(?: \/)?>/gi, `
`)
} class mI {
  constructor () { this.state = 'INITIAL', this.buffer = '', this.decoder = new hI(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0 }parse (e) {
    const t = this; e && (t.buffer += t.decoder.decode(e, { stream: !0 })); function r () {
      let s = t.buffer; let o = 0; for (s = zv(s); o < s.length && s[o] !== '\r' && s[o] !== `
`;)++o; const a = s.slice(0, o); return s[o] === '\r' && ++o, s[o] === `
` && ++o, t.buffer = s.slice(o), a
    } function i (s) { jv(s, function (o, a) {}, /:/) } try {
      let s = ''; if (t.state === 'INITIAL') { if (!/\r\n|\n/.test(t.buffer)) return this; s = r(); const a = s.match(/^()?WEBVTT([ \t].*)?$/); if (!(a != null && a[0])) throw new Error('Malformed WebVTT signature.'); t.state = 'HEADER' } let o = !1; for (;t.buffer;) {
        if (!/\r\n|\n/.test(t.buffer)) return this; switch (o ? o = !1 : s = r(), t.state) {
          case 'HEADER':/:/.test(s) ? i(s) : s || (t.state = 'ID'); continue; case 'NOTE':s || (t.state = 'ID'); continue; case 'ID':if (/^NOTE($|[ \t])/.test(s)) { t.state = 'NOTE'; break } if (!s) continue; if (t.cue = new bh(0, 0, ''), t.state = 'CUE', s.indexOf('-->') === -1) { t.cue.id = s; continue } case 'CUE':if (!t.cue) { t.state = 'BADCUE'; continue } try { pI(s, t.cue, t.regionList) } catch { t.cue = null, t.state = 'BADCUE'; continue }t.state = 'CUETEXT'; continue; case 'CUETEXT':{ const a = s.indexOf('-->') !== -1; if (!s || a && (o = !0)) { t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = 'ID'; continue } if (t.cue === null) continue; t.cue.text && (t.cue.text += `
`), t.cue.text += s } continue; case 'BADCUE':s || (t.state = 'ID')
        }
      }
    } catch { t.state === 'CUETEXT' && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE' } return this
  }

  flush () {
    const e = this; try {
      if ((e.cue || e.state === 'HEADER') && (e.buffer += `

`, e.parse()), e.state === 'INITIAL' || e.state === 'BADWEBVTT') throw new Error('Malformed WebVTT signature.')
    } catch (t) { e.onparsingerror && e.onparsingerror(t) } return e.onflush && e.onflush(), this
  }
} const gI = /\r\n|\n\r|\n|\r/g; const wu = function (e, t, r = 0) { return e.slice(r, r + t.length) === t }; const yI = function (e) { let t = parseInt(e.slice(-3)); const r = parseInt(e.slice(-6, -4)); const i = parseInt(e.slice(-9, -7)); const s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(':'))) : 0; if (!K(t) || !K(r) || !K(i) || !K(s)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`); return t += 1e3 * r, t += 60 * 1e3 * i, t += 60 * 60 * 1e3 * s, t }; const Cu = function (e) { let t = 5381; let r = e.length; for (;r;)t = t * 33 ^ e.charCodeAt(--r); return (t >>> 0).toString() }; function Oh (n, e, t) { return Cu(n.toString()) + Cu(e.toString()) + Cu(t) } const vI = function (e, t, r) { let i = e[t]; let s = e[i.prevCC]; if (!s || !s.new && i.new) { e.ccOffset = e.presentationOffset = i.start, i.new = !1; return } for (;(o = s) != null && o.new;) { var o; e.ccOffset += i.start - s.start, i.new = !1, i = s, s = e[i.prevCC] }e.presentationOffset = r }; function EI (n, e, t, r, i, s, o) {
  const a = new mI(); const l = fn(new Uint8Array(n)).trim().replace(gI, `
`).split(`
`); const u = []; const c = e ? BC(e.baseTime, e.timescale) : 0; let d = '00:00.000'; let h = 0; let f = 0; let p; let m = !0; a.oncue = function (y) { const g = t[r]; let v = t.ccOffset; const E = (h - c) / 9e4; if (g != null && g.new && (f !== void 0 ? v = t.ccOffset = g.start : vI(t, r, E)), E) { if (!e) { p = new Error('Missing initPTS for VTT MPEGTS'); return }v = E - t.presentationOffset } const x = y.endTime - y.startTime; const T = bt((y.startTime + v - f) * 9e4, i * 9e4) / 9e4; y.startTime = Math.max(T, 0), y.endTime = Math.max(T + x, 0); const w = y.text.trim(); y.text = decodeURIComponent(encodeURIComponent(w)), y.id || (y.id = Oh(y.startTime, y.endTime, w)), y.endTime > 0 && u.push(y) }, a.onparsingerror = function (y) { p = y }, a.onflush = function () { if (p) { o(p); return }s(u) }, l.forEach(y => {
    if (m) if (wu(y, 'X-TIMESTAMP-MAP=')) { m = !1, y.slice(16).split(',').forEach(g => { wu(g, 'LOCAL:') ? d = g.slice(6) : wu(g, 'MPEGTS:') && (h = parseInt(g.slice(7))) }); try { f = yI(d) / 1e3 } catch (g) { p = g } return } else y === '' && (m = !1); a.parse(y + `
`)
  }), a.flush()
} const Iu = 'stpp.ttml.im1t'; const Wv = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/; const Yv = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/; const SI = { left: 'start', center: 'center', right: 'end', start: 'start', end: 'end' }; function um (n, e, t, r) { const i = ee(new Uint8Array(n), ['mdat']); if (i.length === 0) { r(new Error('Could not parse IMSC1 mdat')); return } const s = i.map(a => fn(a)); const o = UC(e.baseTime, 1, e.timescale); try { s.forEach(a => t(TI(a, o))) } catch (a) { r(a) } } function TI (n, e) { const i = new DOMParser().parseFromString(n, 'text/xml').getElementsByTagName('tt')[0]; if (!i) throw new Error('Invalid ttml'); const s = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }; const o = Object.keys(s).reduce((d, h) => (d[h] = i.getAttribute(`ttp:${h}`) || s[h], d), {}); const a = i.getAttribute('xml:space') !== 'preserve'; const l = cm(_u(i, 'styling', 'style')); const u = cm(_u(i, 'layout', 'region')); const c = _u(i, 'body', '[begin]'); return [].map.call(c, d => { const h = qv(d, a); if (!h || !d.hasAttribute('begin')) return null; const f = ku(d.getAttribute('begin'), o); const p = ku(d.getAttribute('dur'), o); let m = ku(d.getAttribute('end'), o); if (f === null) throw dm(d); if (m === null) { if (p === null) throw dm(d); m = f + p } const y = new bh(f - e, m - e, h); y.id = Oh(y.startTime, y.endTime, y.text); const g = u[d.getAttribute('region')]; const v = l[d.getAttribute('style')]; const E = xI(g, v, l); const { textAlign: x } = E; if (x) { const T = SI[x]; T && (y.lineAlign = T), y.align = x } return De(y, E), y }).filter(d => d !== null) } function _u (n, e, t) { const r = n.getElementsByTagName(e)[0]; return r ? [].slice.call(r.querySelectorAll(t)) : [] } function cm (n) { return n.reduce((e, t) => { const r = t.getAttribute('xml:id'); return r && (e[r] = t), e }, {}) } function qv (n, e) {
  return [].slice.call(n.childNodes).reduce((t, r, i) => {
    let s; return r.nodeName === 'br' && i
      ? t + `
`
      : (s = r.childNodes) != null && s.length ? qv(r, e) : e ? t + r.textContent.trim().replace(/\s+/g, ' ') : t + r.textContent
  }, '')
} function xI (n, e, t) { const r = 'http://www.w3.org/ns/ttml#styling'; let i = null; const s = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily']; const o = n != null && n.hasAttribute('style') ? n.getAttribute('style') : null; return o && t.hasOwnProperty(o) && (i = t[o]), s.reduce((a, l) => { const u = Du(e, r, l) || Du(n, r, l) || Du(i, r, l); return u && (a[l] = u), a }, {}) } function Du (n, e, t) { return n && n.hasAttributeNS(e, t) ? n.getAttributeNS(e, t) : null } function dm (n) { return new Error(`Could not parse ttml timestamp ${n}`) } function ku (n, e) { if (!n) return null; let t = Kv(n); return t === null && (Wv.test(n) ? t = LI(n, e) : Yv.test(n) && (t = RI(n, e))), t } function LI (n, e) { const t = Wv.exec(n); const r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate; return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate } function RI (n, e) { const t = Yv.exec(n); const r = Number(t[1]); switch (t[2]) { case 'h':return r * 3600; case 'm':return r * 60; case 'ms':return r * 1e3; case 'f':return r / e.frameRate; case 't':return r / e.tickRate } return r } class AI {constructor (e) { this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = fm(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(S.FRAG_LOADING, this.onFragLoading, this), e.on(S.FRAG_LOADED, this.onFragLoaded, this), e.on(S.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(S.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(S.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(S.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this) }destroy () { const { hls: e } = this; e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(S.FRAG_LOADING, this.onFragLoading, this), e.off(S.FRAG_LOADED, this.onFragLoaded, this), e.off(S.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(S.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(S.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(S.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = null, this.cea608Parser1 = this.cea608Parser2 = void 0 }initCea608Parsers () { if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) { const e = new Yo(this, 'textTrack1'); const t = new Yo(this, 'textTrack2'); const r = new Yo(this, 'textTrack3'); const i = new Yo(this, 'textTrack4'); this.cea608Parser1 = new om(1, e, t), this.cea608Parser2 = new om(3, r, i) } }addCues (e, t, r, i, s) { let o = !1; for (let a = s.length; a--;) { const l = s[a]; const u = wI(l[0], l[1], t, r); if (u >= 0 && (l[0] = Math.min(l[0], t), l[1] = Math.max(l[1], r), o = !0, u / (r - t) > 0.5)) return } if (o || s.push([t, r]), this.config.renderTextTracksNatively) { const a = this.captionsTracks[e]; this.Cues.newCue(a, t, r, i) } else { const a = this.Cues.newCue(null, t, r, i); this.hls.trigger(S.CUES_PARSED, { type: 'captions', cues: a, track: e }) } }onInitPtsFound (e, { frag: t, id: r, initPTS: i, timescale: s }) { const { unparsedVttFrags: o } = this; r === 'main' && (this.initPTS[t.cc] = { baseTime: i, timescale: s }), o.length && (this.unparsedVttFrags = [], o.forEach(a => { this.onFragLoaded(S.FRAG_LOADED, a) })) }getExistingTrack (e, t) { const { media: r } = this; if (r) for (let i = 0; i < r.textTracks.length; i++) { const s = r.textTracks[i]; if (hm(s, { name: e, lang: t, attrs: {} })) return s } return null }createCaptionsTrack (e) { this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e) }createNativeTrack (e) { if (this.captionsTracks[e]) return; const { captionsProperties: t, captionsTracks: r, media: i } = this; const { label: s, languageCode: o } = t[e]; const a = this.getExistingTrack(s, o); if (a)r[e] = a, pi(r[e]), mv(r[e], i); else { const l = this.createTextTrack('captions', s, o); l && (l[e] = !0, r[e] = l) } }createNonNativeTrack (e) { if (this.nonNativeCaptionsTracks[e]) return; const t = this.captionsProperties[e]; if (!t) return; const r = t.label; const i = { _id: e, label: r, kind: 'captions', default: t.media ? !!t.media.default : !1, closedCaptions: t.media }; this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(S.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [i] }) }createTextTrack (e, t, r) { const i = this.media; if (i) return i.addTextTrack(e, t, r) }onMediaAttaching (e, t) { this.media = t.media, this._cleanTracks() }onMediaDetaching () { const { captionsTracks: e } = this; Object.keys(e).forEach(t => { pi(e[t]), delete e[t] }), this.nonNativeCaptionsTracks = {} }onManifestLoading () { this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = fm(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset()) }_cleanTracks () { const { media: e } = this; if (!e) return; const t = e.textTracks; if (t) for (let r = 0; r < t.length; r++)pi(t[r]) }onSubtitleTracksUpdated (e, t) { const r = t.subtitleTracks || []; const i = r.some(s => s.textCodec === Iu); if (this.config.enableWebVTT || i && this.config.enableIMSC1) { if (Gv(this.tracks, r)) { this.tracks = r; return } if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) { const o = this.media; const a = o ? fa(o.textTracks) : null; if (this.tracks.forEach((l, u) => { let c; if (a) { let d = null; for (let h = 0; h < a.length; h++) if (a[h] && hm(a[h], l)) { d = a[h], a[h] = null; break }d && (c = d) } if (c)pi(c); else { const d = Qv(l); c = this.createTextTrack(d, l.name, l.lang), c && (c.mode = 'disabled') }c && this.textTracks.push(c) }), a != null && a.length) { const l = a.filter(u => u !== null).map(u => u.label); l.length && C.warn(`Media element contains unused subtitle tracks: ${l.join(', ')}. Replace media element for each source to clear TextTracks and captions menu.`) } } else if (this.tracks.length) { const o = this.tracks.map(a => ({ label: a.name, kind: a.type.toLowerCase(), default: a.default, subtitleTrack: a })); this.hls.trigger(S.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: o }) } } }onManifestLoaded (e, t) { this.config.enableCEA708Captions && t.captions && t.captions.forEach(r => { const i = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId); if (!i) return; const s = `textTrack${i[1]}`; const o = this.captionsProperties[s]; o && (o.label = r.name, r.lang && (o.languageCode = r.lang), o.media = r) }) }closedCaptionsForLevel (e) { const t = this.hls.levels[e.level]; return t == null ? void 0 : t.attrs['CLOSED-CAPTIONS'] }onFragLoading (e, t) { this.initCea608Parsers(); const { cea608Parser1: r, cea608Parser2: i, lastCc: s, lastSn: o, lastPartIndex: a } = this; if (!(!this.enabled || !r || !i) && t.frag.type === X.MAIN) { let l, u; const { cc: c, sn: d } = t.frag; const h = (l = t == null || (u = t.part) == null ? void 0 : u.index) != null ? l : -1; d === o + 1 || d === o && h === a + 1 || c === s || (r.reset(), i.reset()), this.lastCc = c, this.lastSn = d, this.lastPartIndex = h } }onFragLoaded (e, t) { const { frag: r, payload: i } = t; if (r.type === X.SUBTITLE) if (i.byteLength) { const s = r.decryptdata; const o = 'stats' in t; if (s == null || !s.encrypted || o) { const a = this.tracks[r.level]; const l = this.vttCCs; l[r.cc] || (l[r.cc] = { start: r.start, prevCC: this.prevCC, new: !0 }, this.prevCC = r.cc), a && a.textCodec === Iu ? this._parseIMSC1(r, i) : this._parseVTTs(t) } } else this.hls.trigger(S.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: r, error: new Error('Empty subtitle payload') }) }_parseIMSC1 (e, t) { const r = this.hls; um(t, this.initPTS[e.cc], i => { this._appendCues(i, e.level), r.trigger(S.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e }) }, i => { C.log(`Failed to parse IMSC1: ${i}`), r.trigger(S.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e, error: i }) }) }_parseVTTs (e) { let t; const { frag: r, payload: i } = e; const { initPTS: s, unparsedVttFrags: o } = this; const a = s.length - 1; if (!s[r.cc] && a === -1) { o.push(e); return } const l = this.hls; const u = (t = r.initSegment) != null && t.data ? $t(r.initSegment.data, new Uint8Array(i)) : i; EI(u, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, c => { this._appendCues(c, r.level), l.trigger(S.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: r }) }, c => { const d = c.message === 'Missing initPTS for VTT MPEGTS'; d ? o.push(e) : this._fallbackToIMSC1(r, i), C.log(`Failed to parse VTT cue: ${c}`), !(d && a > r.cc) && l.trigger(S.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: r, error: c }) }) }_fallbackToIMSC1 (e, t) { const r = this.tracks[e.level]; r.textCodec || um(t, this.initPTS[e.cc], () => { r.textCodec = Iu, this._parseIMSC1(e, t) }, () => { r.textCodec = 'wvtt' }) }_appendCues (e, t) { const r = this.hls; if (this.config.renderTextTracksNatively) { const i = this.textTracks[t]; if (!i || i.mode === 'disabled') return; e.forEach(s => gv(i, s)) } else { const i = this.tracks[t]; if (!i) return; const s = i.default ? 'default' : 'subtitles' + t; r.trigger(S.CUES_PARSED, { type: 'subtitles', cues: e, track: s }) } }onFragDecrypted (e, t) { const { frag: r } = t; r.type === X.SUBTITLE && this.onFragLoaded(S.FRAG_LOADED, t) }onSubtitleTracksCleared () { this.tracks = [], this.captionsTracks = {} }onFragParsingUserdata (e, t) { this.initCea608Parsers(); const { cea608Parser1: r, cea608Parser2: i } = this; if (!this.enabled || !r || !i) return; const { frag: s, samples: o } = t; if (!(s.type === X.MAIN && this.closedCaptionsForLevel(s) === 'NONE')) for (let a = 0; a < o.length; a++) { const l = o[a].bytes; if (l) { const u = this.extractCea608Data(l); r.addData(o[a].pts, u[0]), i.addData(o[a].pts, u[1]) } } }onBufferFlushing (e, { startOffset: t, endOffset: r, endOffsetSubtitles: i, type: s }) { const { media: o } = this; if (!(!o || o.currentTime < r)) { if (!s || s === 'video') { const { captionsTracks: a } = this; Object.keys(a).forEach(l => qc(a[l], t, r)) } if (this.config.renderTextTracksNatively && t === 0 && i !== void 0) { const { textTracks: a } = this; Object.keys(a).forEach(l => qc(a[l], t, i)) } } }extractCea608Data (e) { const t = [[], []]; const r = e[0] & 31; let i = 2; for (let s = 0; s < r; s++) { const o = e[i++]; const a = 127 & e[i++]; const l = 127 & e[i++]; if (a === 0 && l === 0) continue; if ((4 & o) !== 0) { const c = 3 & o; (c === 0 || c === 1) && (t[c].push(a), t[c].push(l)) } } return t }} function Qv (n) { return n.characteristics && /transcribes-spoken-dialog/gi.test(n.characteristics) && /describes-music-and-sound/gi.test(n.characteristics) ? 'captions' : 'subtitles' } function hm (n, e) { return !!n && n.kind === Qv(e) && td(e, n) } function wI (n, e, t, r) { return Math.min(e, r) - Math.max(n, t) } function fm () { return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } } } class Fh {constructor (e) { this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners() }setStreamController (e) { this.streamController = e }destroy () { this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null }registerListeners () { const { hls: e } = this; e.on(S.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(S.BUFFER_CODECS, this.onBufferCodecs, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this) }unregisterListener () { const { hls: e } = this; e.off(S.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(S.BUFFER_CODECS, this.onBufferCodecs, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this) }onFpsDropLevelCapping (e, t) { const r = this.hls.levels[t.droppedLevel]; this.isLevelAllowed(r) && this.restrictedLevels.push({ bitrate: r.bitrate, height: r.height, width: r.width }) }onMediaAttaching (e, t) { this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize() }onManifestParsed (e, t) { const r = this.hls; this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping() }onLevelsUpdated (e, t) { this.timer && K(this.autoLevelCapping) && this.detectPlayerSize() }onBufferCodecs (e, t) { this.hls.config.capLevelToPlayerSize && t.video && this.startCapping() }onMediaDetaching () { this.stopCapping() }detectPlayerSize () { if (this.media) { if (this.mediaHeight <= 0 || this.mediaWidth <= 0) { this.clientRect = null; return } const e = this.hls.levels; if (e.length) { const t = this.hls; const r = this.getMaxLevel(e.length - 1); r !== this.autoLevelCapping && C.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = r, t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping } } }getMaxLevel (e) { const t = this.hls.levels; if (!t.length) return -1; const r = t.filter((i, s) => this.isLevelAllowed(i) && s <= e); return this.clientRect = null, Fh.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight) }startCapping () { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) }stopCapping () { this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0) }getDimensions () { if (this.clientRect) return this.clientRect; const e = this.media; const t = { width: 0, height: 0 }; if (e) { const r = e.getBoundingClientRect(); t.width = r.width, t.height = r.height, !t.width && !t.height && (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0) } return this.clientRect = t, t } get mediaWidth () { return this.getDimensions().width * this.contentScaleFactor } get mediaHeight () { return this.getDimensions().height * this.contentScaleFactor } get contentScaleFactor () { let e = 1; if (!this.hls.config.ignoreDevicePixelRatio) try { e = self.devicePixelRatio } catch {} return e }isLevelAllowed (e) { return !this.restrictedLevels.some(r => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height) } static getMaxLevelByMediaSize (e, t, r) { if (!(e != null && e.length)) return -1; const i = (a, l) => l ? a.width !== l.width || a.height !== l.height : !0; let s = e.length - 1; const o = Math.max(t, r); for (let a = 0; a < e.length; a += 1) { const l = e[a]; if ((l.width >= o || l.height >= o) && i(l, e[a + 1])) { s = a; break } } return s }} class CI {constructor (e) { this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners() }setStreamController (e) { this.streamController = e }registerListeners () { this.hls.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this) }unregisterListeners () { this.hls.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this) }destroy () { this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null }onMediaAttaching (e, t) { const r = this.hls.config; if (r.capLevelOnFPSDrop) { const i = t.media instanceof self.HTMLVideoElement ? t.media : null; this.media = i, i && typeof i.getVideoPlaybackQuality === 'function' && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod) } }checkFPS (e, t, r) { const i = performance.now(); if (t) { if (this.lastTime) { const s = i - this.lastTime; const o = r - this.lastDroppedFrames; const a = t - this.lastDecodedFrames; const l = 1e3 * o / s; const u = this.hls; if (u.trigger(S.FPS_DROP, { currentDropped: o, currentDecoded: a, totalDroppedFrames: r }), l > 0 && o > u.config.fpsDroppedMonitoringThreshold * a) { let c = u.currentLevel; C.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + c), c > 0 && (u.autoLevelCapping === -1 || u.autoLevelCapping >= c) && (c = c - 1, u.trigger(S.FPS_DROP_LEVEL_CAPPING, { level: c, droppedLevel: u.currentLevel }), u.autoLevelCapping = c, this.streamController.nextLevelSwitch()) } } this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t } }checkFPSInterval () { const e = this.media; if (e) if (this.isVideoPlaybackQualityAvailable) { const t = e.getVideoPlaybackQuality(); this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames) } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount) }} const Qo = '[eme]'; class Li {
  constructor (e) { this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = Li.CDMCleanupPromise ? [Li.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = C.debug.bind(C, Qo), this.log = C.log.bind(C, Qo), this.warn = C.warn.bind(C, Qo), this.error = C.error.bind(C, Qo), this.hls = e, this.config = e.config, this.registerListeners() }destroy () { this.unregisterListeners(), this.onMediaDetached(); const e = this.config; e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null }registerListeners () { this.hls.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(S.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(S.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(S.MANIFEST_LOADED, this.onManifestLoaded, this) }unregisterListeners () { this.hls.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(S.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(S.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(S.MANIFEST_LOADED, this.onManifestLoaded, this) }getLicenseServerUrl (e) { const { drmSystems: t, widevineLicenseUrl: r } = this.config; const i = t[e]; if (i) return i.licenseUrl; if (e === ye.WIDEVINE && r) return r; throw new Error(`no license server URL configured for key-system "${e}"`) }getServerCertificateUrl (e) { const { drmSystems: t } = this.config; const r = t[e]; if (r) return r.serverCertificateUrl; this.log(`No Server Certificate in config.drmSystems["${e}"]`) }attemptKeySystemAccess (e) { const t = this.hls.levels; const r = (o, a, l) => !!o && l.indexOf(o) === a; const i = t.map(o => o.audioCodec).filter(r); const s = t.map(o => o.videoCodec).filter(r); return i.length + s.length === 0 && s.push('avc1.42e01e'), new Promise((o, a) => { const l = u => { const c = u.shift(); this.getMediaKeysPromise(c, i, s).then(d => o({ keySystem: c, mediaKeys: d })).catch(d => { u.length ? l(u) : d instanceof Dt ? a(d) : a(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_NO_ACCESS, error: d, fatal: !0 }, d.message)) }) }; l(e) }) }requestMediaKeySystemAccess (e, t) { const { requestMediaKeySystemAccessFunc: r } = this.config; if (typeof r !== 'function') { let i = `Configured requestMediaKeySystemAccess is not a function ${r}`; return nv === null && self.location.protocol === 'http:' && (i = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(i)) } return r(e, t) }getMediaKeysPromise (e, t, r) { const i = UA(e, t, r, this.config.drmSystemOptions); const s = this.keySystemAccessPromises[e]; let o = s == null ? void 0 : s.keySystemAccess; if (!o) { this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(i)}`), o = this.requestMediaKeySystemAccess(e, i); const a = this.keySystemAccessPromises[e] = { keySystemAccess: o }; return o.catch(l => { this.log(`Failed to obtain access to key-system "${e}": ${l}`) }), o.then(l => { this.log(`Access for key-system "${l.keySystem}" obtained`); const u = this.fetchServerCertificate(e); return this.log(`Create media-keys for "${e}"`), a.mediaKeys = l.createMediaKeys().then(c => (this.log(`Media-keys created for "${e}"`), u.then(d => d ? this.setMediaKeysServerCertificate(c, e, d) : c))), a.mediaKeys.catch(c => { this.error(`Failed to create media-keys for "${e}"}: ${c}`) }), a.mediaKeys }) } return o.then(() => s.mediaKeys) }createMediaKeySessionContext ({ decryptdata: e, keySystem: t, mediaKeys: r }) { this.log(`Creating key-system session "${t}" keyId: ${tn.hexDump(e.keyId || [])}`); const i = r.createSession(); const s = { decryptdata: e, keySystem: t, mediaKeys: r, mediaKeysSession: i, keyStatus: 'status-pending' }; return this.mediaKeySessions.push(s), s }renewKeySession (e) { const t = e.decryptdata; if (t.pssh) { const r = this.createMediaKeySessionContext(e); const i = this.getKeyIdString(t); const s = 'cenc'; this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(r, s, t.pssh, 'expired') } else this.warn('Could not renew expired session. Missing pssh initData.'); this.removeSession(e) }getKeyIdString (e) { if (!e) throw new Error('Could not read keyId of undefined decryptdata'); if (e.keyId === null) throw new Error('keyId is null'); return tn.hexDump(e.keyId) }updateKeySession (e, t) {
    let r; const i = e.mediaKeysSession; return this.log(`Updating key-session "${i.sessionId}" for keyID ${tn.hexDump(((r = e.decryptdata) == null ? void 0 : r.keyId) || [])}
      } (data length: ${t && t.byteLength})`), i.update(t)
  }

  selectKeySystemFormat (e) { const t = Object.keys(e.levelkeys || {}); return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(', ')}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise }getKeyFormatPromise (e) { return new Promise((t, r) => { const i = fu(this.config); const s = e.map(yp).filter(o => !!o && i.indexOf(o) !== -1); return this.getKeySystemSelectionPromise(s).then(({ keySystem: o }) => { const a = vp(o); a ? t(a) : r(new Error(`Unable to find format for key-system "${o}"`)) }).catch(r) }) }loadKey (e) { const t = e.keyInfo.decryptdata; const r = this.getKeyIdString(t); const i = `(keyId: ${r} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`; this.log(`Starting session for key ${i}`); let s = this.keyIdToKeySessionPromise[r]; return s || (s = this.keyIdToKeySessionPromise[r] = this.getKeySystemForKeyPromise(t).then(({ keySystem: o, mediaKeys: a }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(o, a).then(() => { this.throwIfDestroyed(); const l = this.createMediaKeySessionContext({ keySystem: o, mediaKeys: a, decryptdata: t }); return this.generateRequestWithPreferredKeySession(l, 'cenc', t.pssh, 'playlist-key') }))), s.catch(o => this.handleError(o))), s }throwIfDestroyed (e = 'Invalid state') { if (!this.hls) throw new Error('invalid state') }handleError (e) { this.hls && (this.error(e.message), e instanceof Dt ? this.hls.trigger(S.ERROR, e.data) : this.hls.trigger(S.ERROR, { type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_NO_KEYS, error: e, fatal: !0 })) }getKeySystemForKeyPromise (e) { const t = this.getKeyIdString(e); const r = this.keyIdToKeySessionPromise[t]; if (!r) { const i = yp(e.keyFormat); const s = i ? [i] : fu(this.config); return this.attemptKeySystemAccess(s) } return r }getKeySystemSelectionPromise (e) { if (e.length || (e = fu(this.config)), e.length === 0) throw new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 }, `Missing key-system license configuration options ${JSON.stringify({ drmSystems: this.config.drmSystems })}`); return this.attemptKeySystemAccess(e) }_onMediaEncrypted (e) { const { initDataType: t, initData: r } = e; if (this.debug(`"${e.type}" event: init data type: "${t}"`), r === null) return; let i, s; if (t === 'sinf' && this.config.drmSystems[ye.FAIRPLAY]) { const c = Pe(new Uint8Array(r)); try { const d = Sh(JSON.parse(c).sinf); const h = cv(new Uint8Array(d)); if (!h) return; i = h.subarray(8, 24), s = ye.FAIRPLAY } catch { this.warn('Failed to parse sinf "encrypted" event message initData'); return } } else { const c = uw(r); if (c === null) return; c.version === 0 && c.systemId === tv.WIDEVINE && c.data && (i = c.data.subarray(8, 24)), s = NA(c.systemId) } if (!s || !i) return; const o = tn.hexDump(i); const { keyIdToKeySessionPromise: a, mediaKeySessions: l } = this; let u = a[o]; for (let c = 0; c < l.length; c++) { const d = l[c]; const h = d.decryptdata; if (h.pssh || !h.keyId) continue; const f = tn.hexDump(h.keyId); if (o === f || h.uri.replace(/-/g, '').indexOf(o) !== -1) { u = a[f], delete a[f], h.pssh = new Uint8Array(r), h.keyId = i, u = a[o] = u.then(() => this.generateRequestWithPreferredKeySession(d, t, r, 'encrypted-event-key-match')); break } }u || (u = a[o] = this.getKeySystemSelectionPromise([s]).then(({ keySystem: c, mediaKeys: d }) => { let h; this.throwIfDestroyed(); const f = new eo('ISO-23001-7', o, (h = vp(c)) != null ? h : ''); return f.pssh = new Uint8Array(r), f.keyId = i, this.attemptSetMediaKeys(c, d).then(() => { this.throwIfDestroyed(); const p = this.createMediaKeySessionContext({ decryptdata: f, keySystem: c, mediaKeys: d }); return this.generateRequestWithPreferredKeySession(p, t, r, 'encrypted-event-no-match') }) })), u.catch(c => this.handleError(c)) }_onWaitingForKey (e) { this.log(`"${e.type}" event`) }attemptSetMediaKeys (e, t) { const r = this.setMediaKeysQueue.slice(); this.log(`Setting media-keys for "${e}"`); const i = Promise.all(r).then(() => { if (!this.media) throw new Error('Attempted to set mediaKeys without media element attached'); return this.media.setMediaKeys(t) }); return this.setMediaKeysQueue.push(i), i.then(() => { this.log(`Media-keys set for "${e}"`), r.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(s => r.indexOf(s) === -1) }) }generateRequestWithPreferredKeySession (e, t, r, i) { let s, o; const a = (s = this.config.drmSystems) == null || (o = s[e.keySystem]) == null ? void 0 : o.generateRequest; if (a) try { const p = a.call(this.hls, t, r, e); if (!p) throw new Error('Invalid response from configured generateRequest filter'); t = p.initDataType, r = e.decryptdata.pssh = p.initData ? new Uint8Array(p.initData) : null } catch (p) { let l; if (this.warn(p.message), (l = this.hls) != null && l.config.debug) throw p } if (r === null) return this.log(`Skipping key-session request for "${i}" (no initData)`), Promise.resolve(e); const u = this.getKeyIdString(e.decryptdata); this.log(`Generating key-session request for "${i}": ${u} (init data type: ${t} length: ${r ? r.byteLength : null})`); const c = new Ph(); const d = e._onmessage = p => { const m = e.mediaKeysSession; if (!m) { c.emit('error', new Error('invalid state')); return } const { messageType: y, message: g } = p; this.log(`"${y}" message event for session "${m.sessionId}" message size: ${g.byteLength}`), y === 'license-request' || y === 'license-renewal' ? this.renewLicense(e, g).catch(v => { this.handleError(v), c.emit('error', v) }) : y === 'license-release' ? e.keySystem === ye.FAIRPLAY && (this.updateKeySession(e, Wc('acknowledged')), this.removeSession(e)) : this.warn(`unhandled media key message type "${y}"`) }; const h = e._onkeystatuseschange = p => { if (!e.mediaKeysSession) { c.emit('error', new Error('invalid state')); return } this.onKeyStatusChange(e); const y = e.keyStatus; c.emit('keyStatus', y), y === 'expired' && (this.warn(`${e.keySystem} expired for key ${u}`), this.renewKeySession(e)) }; e.mediaKeysSession.addEventListener('message', d), e.mediaKeysSession.addEventListener('keystatuseschange', h); const f = new Promise((p, m) => { c.on('error', m), c.on('keyStatus', y => { y.startsWith('usable') ? p() : y === 'output-restricted' ? m(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED, fatal: !1 }, 'HDCP level output restricted')) : y === 'internal-error' ? m(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_STATUS_INTERNAL_ERROR, fatal: !0 }, `key status changed to "${y}"`)) : y === 'expired' ? m(new Error('key expired while generating request')) : this.warn(`unhandled key status change "${y}"`) }) }); return e.mediaKeysSession.generateRequest(t, r).then(() => { let p; this.log(`Request generated for key-session "${(p = e.mediaKeysSession) == null ? void 0 : p.sessionId}" keyId: ${u}`) }).catch(p => { throw new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_NO_SESSION, error: p, fatal: !1 }, `Error generating key-session request: ${p}`) }).then(() => f).catch(p => { throw c.removeAllListeners(), this.removeSession(e), p }).then(() => (c.removeAllListeners(), e)) }onKeyStatusChange (e) { e.mediaKeysSession.keyStatuses.forEach((t, r) => { this.log(`key status change "${t}" for keyStatuses keyId: ${tn.hexDump('buffer' in r ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : new Uint8Array(r))} session keyId: ${tn.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t }) }fetchServerCertificate (e) { const t = this.config; const r = t.loader; const i = new r(t); const s = this.getServerCertificateUrl(e); return s ? (this.log(`Fetching server certificate for "${e}"`), new Promise((o, a) => { const l = { responseType: 'arraybuffer', url: s }; const u = t.certLoadPolicy.default; const c = { loadPolicy: u, timeout: u.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; const d = { onSuccess: (h, f, p, m) => { o(h.data) }, onError: (h, f, p, m) => { a(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: p, response: $e({ url: l.url, data: void 0 }, h) }, `"${e}" certificate request failed (${s}). Status: ${h.code} (${h.text})`)) }, onTimeout: (h, f, p) => { a(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: p, response: { url: l.url, data: void 0 } }, `"${e}" certificate request timed out (${s})`)) }, onAbort: (h, f, p) => { a(new Error('aborted')) } }; i.load(l, c, d) })) : Promise.resolve() }setMediaKeysServerCertificate (e, t, r) { return new Promise((i, s) => { e.setServerCertificate(r).then(o => { this.log(`setServerCertificate ${o ? 'success' : 'not supported by CDM'} (${r == null ? void 0 : r.byteLength}) on "${t}"`), i(e) }).catch(o => { s(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED, error: o, fatal: !0 }, o.message)) }) }) }renewLicense (e, t) { return this.requestLicense(e, new Uint8Array(t)).then(r => this.updateKeySession(e, new Uint8Array(r)).catch(i => { throw new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_SESSION_UPDATE_FAILED, error: i, fatal: !0 }, i.message) })) }unpackPlayReadyKeyMessage (e, t) { const r = String.fromCharCode.apply(null, new Uint16Array(t.buffer)); if (!r.includes('PlayReadyKeyMessage')) return e.setRequestHeader('Content-Type', 'text/xml; charset=utf-8'), t; const i = new DOMParser().parseFromString(r, 'application/xml'); const s = i.querySelectorAll('HttpHeader'); if (s.length > 0) { let c; for (let d = 0, h = s.length; d < h; d++) { var o, a; c = s[d]; const f = (o = c.querySelector('name')) == null ? void 0 : o.textContent; const p = (a = c.querySelector('value')) == null ? void 0 : a.textContent; f && p && e.setRequestHeader(f, p) } } const l = i.querySelector('Challenge'); const u = l == null ? void 0 : l.textContent; if (!u) throw new Error('Cannot find <Challenge> in key message'); return Wc(atob(u)) }setupLicenseXHR (e, t, r, i) { const s = this.config.licenseXhrSetup; return s ? Promise.resolve().then(() => { if (!r.decryptdata) throw new Error('Key removed'); return s.call(this.hls, e, t, r, i) }).catch(o => { if (!r.decryptdata) throw o; return e.open('POST', t, !0), s.call(this.hls, e, t, r, i) }).then(o => (e.readyState || e.open('POST', t, !0), { xhr: e, licenseChallenge: o || i })) : (e.open('POST', t, !0), Promise.resolve({ xhr: e, licenseChallenge: i })) }requestLicense (e, t) { const r = this.config.keyLoadPolicy.default; return new Promise((i, s) => { const o = this.getLicenseServerUrl(e.keySystem); this.log(`Sending license request to URL: ${o}`); const a = new XMLHttpRequest(); a.responseType = 'arraybuffer', a.onreadystatechange = () => { if (!this.hls || !e.mediaKeysSession) return s(new Error('invalid state')); if (a.readyState === 4) if (a.status === 200) { this._requestLicenseFailureCount = 0; let l = a.response; this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`); const u = this.config.licenseResponseCallback; if (u) try { l = u.call(this.hls, a, o, e) } catch (c) { this.error(c) }i(l) } else { const l = r.errorRetry; const u = l ? l.maxNumRetry : 0; if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > u || a.status >= 400 && a.status < 500)s(new Dt({ type: J.KEY_SYSTEM_ERROR, details: D.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0, networkDetails: a, response: { url: o, data: void 0, code: a.status, text: a.statusText } }, `License Request XHR failed (${o}). Status: ${a.status} (${a.statusText})`)); else { const c = u - this._requestLicenseFailureCount + 1; this.warn(`Retrying license request, ${c} attempts left`), this.requestLicense(e, t).then(i, s) } } }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, o, e, t).then(({ xhr: l, licenseChallenge: u }) => { e.keySystem == ye.PLAYREADY && (u = this.unpackPlayReadyKeyMessage(l, u)), l.send(u) }) }) }onMediaAttached (e, t) { if (!this.config.emeEnabled) return; const r = t.media; this.media = r, r.addEventListener('encrypted', this.onMediaEncrypted), r.addEventListener('waitingforkey', this.onWaitingForKey) }onMediaDetached () { const e = this.media; const t = this.mediaKeySessions; e && (e.removeEventListener('encrypted', this.onMediaEncrypted), e.removeEventListener('waitingforkey', this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, eo.clearKeyUriToKeyIdMap(); const r = t.length; Li.CDMCleanupPromise = Promise.all(t.map(i => this.removeSession(i)).concat(e == null ? void 0 : e.setMediaKeys(null).catch(i => { this.log(`Could not clear media keys: ${i}`) }))).then(() => { r && (this.log('finished closing key sessions and clearing media keys'), t.length = 0) }).catch(i => { this.log(`Could not close sessions and clear media keys: ${i}`) }) }onManifestLoading () { this.keyFormatPromise = null }onManifestLoaded (e, { sessionKeys: t }) { if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) { const r = t.reduce((i, s) => (i.indexOf(s.keyFormat) === -1 && i.push(s.keyFormat), i), []); this.log(`Selecting key-system from session-keys ${r.join(', ')}`), this.keyFormatPromise = this.getKeyFormatPromise(r) } }removeSession (e) { const { mediaKeysSession: t, licenseXhr: r } = e; if (t) { this.log(`Remove licenses and keys and close session ${t.sessionId}`), e._onmessage && (t.removeEventListener('message', e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener('keystatuseschange', e._onkeystatuseschange), e._onkeystatuseschange = void 0), r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0; const i = this.mediaKeySessions.indexOf(e); return i > -1 && this.mediaKeySessions.splice(i, 1), t.remove().catch(s => { this.log(`Could not remove session: ${s}`) }).then(() => t.close()).catch(s => { this.log(`Could not close session: ${s}`) }) } }
}Li.CDMCleanupPromise = void 0; class Dt extends Error {constructor (e, t) { super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error }} let Xe; (function (n) { n.MANIFEST = 'm', n.AUDIO = 'a', n.VIDEO = 'v', n.MUXED = 'av', n.INIT = 'i', n.CAPTION = 'c', n.TIMED_TEXT = 'tt', n.KEY = 'k', n.OTHER = 'o' })(Xe || (Xe = {})); let rd; (function (n) { n.DASH = 'd', n.HLS = 'h', n.SMOOTH = 's', n.OTHER = 'o' })(rd || (rd = {})); let xr; (function (n) { n.OBJECT = 'CMCD-Object', n.REQUEST = 'CMCD-Request', n.SESSION = 'CMCD-Session', n.STATUS = 'CMCD-Status' })(xr || (xr = {})); const II = { [xr.OBJECT]: ['br', 'd', 'ot', 'tb'], [xr.REQUEST]: ['bl', 'dl', 'mtp', 'nor', 'nrr', 'su'], [xr.SESSION]: ['cid', 'pr', 'sf', 'sid', 'st', 'v'], [xr.STATUS]: ['bs', 'rtp'] }; class Qi {constructor (e, t) { this.value = void 0, this.params = void 0, Array.isArray(e) && (e = e.map(r => r instanceof Qi ? r : new Qi(r))), this.value = e, this.params = t }} class Xv {constructor (e) { this.description = void 0, this.description = e }} const _I = 'Dict'; function DI (n) { return Array.isArray(n) ? JSON.stringify(n) : n instanceof Map ? 'Map{}' : n instanceof Set ? 'Set{}' : typeof n === 'object' ? JSON.stringify(n) : String(n) } function kI (n, e, t, r) { return new Error(`failed to ${n} "${DI(e)}" as ${t}`, { cause: r }) } const pm = 'Bare Item'; const PI = 'Boolean'; const bI = 'Byte Sequence'; const OI = 'Decimal'; const FI = 'Integer'; function MI (n) { return n < -999999999999999 || n > 999999999999999 } const NI = /[\x00-\x1f\x7f]+/; const UI = 'Token'; const BI = 'Key'; function pn (n, e, t) { return kI('serialize', n, e, t) } function $I (n) { if (typeof n !== 'boolean') throw pn(n, PI); return n ? '?1' : '?0' } function GI (n) { return btoa(String.fromCharCode(...n)) } function VI (n) { if (ArrayBuffer.isView(n) === !1) throw pn(n, bI); return `:${GI(n)}:` } function Jv (n) { if (MI(n)) throw pn(n, FI); return n.toString() } function HI (n) { return `@${Jv(n.getTime() / 1e3)}` } function Zv (n, e) { if (n < 0) return -Zv(-n, e); const t = Math.pow(10, e); if (Math.abs(n * t % 1 - 0.5) < Number.EPSILON) { const i = Math.floor(n * t); return (i % 2 === 0 ? i : i + 1) / t } else return Math.round(n * t) / t } function KI (n) { const e = Zv(n, 3); if (Math.floor(Math.abs(e)).toString().length > 12) throw pn(n, OI); const t = e.toString(); return t.includes('.') ? t : `${t}.0` } const jI = 'String'; function zI (n) { if (NI.test(n)) throw pn(n, jI); return `"${n.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"` } function WI (n) { return n.description || n.toString().slice(7, -1) } function mm (n) { const e = WI(n); if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1) throw pn(e, UI); return e } function id (n) { switch (typeof n) { case 'number':if (!K(n)) throw pn(n, pm); return Number.isInteger(n) ? Jv(n) : KI(n); case 'string':return zI(n); case 'symbol':return mm(n); case 'boolean':return $I(n); case 'object':if (n instanceof Date) return HI(n); if (n instanceof Uint8Array) return VI(n); if (n instanceof Xv) return mm(n); default:throw pn(n, pm) } } function sd (n) { if (/^[a-z*][a-z0-9\-_.*]*$/.test(n) === !1) throw pn(n, BI); return n } function Mh (n) { return n == null ? '' : Object.entries(n).map(([e, t]) => t === !0 ? `;${sd(e)}` : `;${sd(e)}=${id(t)}`).join('') } function eE (n) { return n instanceof Qi ? `${id(n.value)}${Mh(n.params)}` : id(n) } function YI (n) { return `(${n.value.map(eE).join(' ')})${Mh(n.params)}` } function qI (n, e = { whitespace: !0 }) { if (typeof n !== 'object') throw pn(n, _I); const t = n instanceof Map ? n.entries() : Object.entries(n); const r = e != null && e.whitespace ? ' ' : ''; return Array.from(t).map(([i, s]) => { s instanceof Qi || (s = new Qi(s)); let o = sd(i); return s.value === !0 ? o += Mh(s.params) : (o += '=', Array.isArray(s.value) ? o += YI(s) : o += eE(s)), o }).join(`,${r}`) } function QI (n, e) { return qI(n, e) } const XI = n => n === 'ot' || n === 'sf' || n === 'st'; const JI = n => typeof n === 'number' ? K(n) : n != null && n !== '' && n !== !1; function ZI (n, e) { const t = new URL(n); const r = new URL(e); if (t.origin !== r.origin) return n; const i = t.pathname.split('/').slice(1); const s = r.pathname.split('/').slice(1, -1); for (;i[0] === s[0];)i.shift(), s.shift(); for (;s.length;)s.shift(), i.unshift('..'); return i.join('/') } function e_ () { try { return crypto.randomUUID() } catch { try { const e = URL.createObjectURL(new Blob()); const t = e.toString(); return URL.revokeObjectURL(e), t.slice(t.lastIndexOf('/') + 1) } catch { let t = new Date().getTime(); return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, i => { const s = (t + Math.random() * 16) % 16 | 0; return t = Math.floor(t / 16), (i == 'x' ? s : s & 3 | 8).toString(16) }) } } } const Ea = n => Math.round(n); const t_ = (n, e) => (e != null && e.baseUrl && (n = ZI(n, e.baseUrl)), encodeURIComponent(n)); const Xo = n => Ea(n / 100) * 100; const n_ = { br: Ea, d: Ea, bl: Xo, dl: Xo, mtp: Xo, nor: t_, rtp: Xo, tb: Ea }; function r_ (n, e) { const t = {}; if (n == null || typeof n !== 'object') return t; const r = Object.keys(n).sort(); const i = De({}, n_, e == null ? void 0 : e.formatters); const s = e == null ? void 0 : e.filter; return r.forEach(o => { if (s != null && s(o)) return; let a = n[o]; const l = i[o]; l && (a = l(a, e)), !(o === 'v' && a === 1) && (o == 'pr' && a === 1 || JI(a) && (XI(o) && typeof a === 'string' && (a = new Xv(a)), t[o] = a)) }), t } function tE (n, e = {}) { return n ? QI(r_(n, e), De({ whitespace: !1 }, e)) : '' } function i_ (n, e = {}) { if (!n) return {}; const t = Object.entries(n); const r = Object.entries(II).concat(Object.entries((e == null ? void 0 : e.customHeaderMap) || {})); const i = t.reduce((s, o) => { let a, l; const [u, c] = o; const d = ((a = r.find(h => h[1].includes(u))) == null ? void 0 : a[0]) || xr.REQUEST; return (l = s[d]) != null || (s[d] = {}), s[d][u] = c, s }, {}); return Object.entries(i).reduce((s, [o, a]) => (s[o] = tE(a, e), s), {}) } function s_ (n, e, t) { return De(n, i_(e, t)) } const o_ = 'CMCD'; function a_ (n, e = {}) { if (!n) return ''; const t = tE(n, e); return `${o_}=${encodeURIComponent(t)}` } const gm = /CMCD=[^&#]+/; function l_ (n, e, t) { const r = a_(e, t); if (!r) return n; if (gm.test(n)) return n.replace(gm, r); const i = n.includes('?') ? '&' : '?'; return `${n}${i}${r}` } class u_ {constructor (e) { this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => { this.initialized && (this.starved = !0), this.buffering = !0 }, this.onPlaying = () => { this.initialized || (this.initialized = !0), this.buffering = !1 }, this.applyPlaylistData = i => { try { this.apply(i, { ot: Xe.MANIFEST, su: !this.initialized }) } catch (s) { C.warn('Could not generate manifest CMCD data.', s) } }, this.applyFragmentData = i => { try { const s = i.frag; const o = this.hls.levels[s.level]; const a = this.getObjectType(s); const l = { d: s.duration * 1e3, ot: a }; (a === Xe.VIDEO || a === Xe.AUDIO || a == Xe.MUXED) && (l.br = o.bitrate / 1e3, l.tb = this.getTopBandwidth(a) / 1e3, l.bl = this.getBufferLength(a)), this.apply(i, l) } catch (s) { C.warn('Could not generate segment CMCD data.', s) } }, this.hls = e; const t = this.config = e.config; const { cmcd: r } = t; r != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e_(), this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners()) }registerListeners () { const e = this.hls; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHED, this.onMediaDetached, this), e.on(S.BUFFER_CREATED, this.onBufferCreated, this) }unregisterListeners () { const e = this.hls; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHED, this.onMediaDetached, this), e.off(S.BUFFER_CREATED, this.onBufferCreated, this) }destroy () { this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = null }onMediaAttached (e, t) { this.media = t.media, this.media.addEventListener('waiting', this.onWaiting), this.media.addEventListener('playing', this.onPlaying) }onMediaDetached () { this.media && (this.media.removeEventListener('waiting', this.onWaiting), this.media.removeEventListener('playing', this.onPlaying), this.media = null) }onBufferCreated (e, t) { let r, i; this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (i = t.tracks.video) == null ? void 0 : i.buffer }createData () { let e; return { v: 1, sf: rd.HLS, sid: this.sid, cid: this.cid, pr: (e = this.media) == null ? void 0 : e.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 } }apply (e, t = {}) { De(t, this.createData()); const r = t.ot === Xe.INIT || t.ot === Xe.VIDEO || t.ot === Xe.MUXED; this.starved && r && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering); const { includeKeys: i } = this; i && (t = Object.keys(t).reduce((s, o) => (i.includes(o) && (s[o] = t[o]), s), {})), this.useHeaders ? (e.headers || (e.headers = {}), s_(e.headers, t)) : e.url = l_(e.url, t) }getObjectType (e) { const { type: t } = e; if (t === 'subtitle') return Xe.TIMED_TEXT; if (e.sn === 'initSegment') return Xe.INIT; if (t === 'audio') return Xe.AUDIO; if (t === 'main') return this.hls.audioTracks.length ? Xe.VIDEO : Xe.MUXED }getTopBandwidth (e) { let t = 0; let r; const i = this.hls; if (e === Xe.AUDIO)r = i.audioTracks; else { const s = i.maxAutoLevel; const o = s > -1 ? s + 1 : i.levels.length; r = i.levels.slice(0, o) } for (const s of r)s.bitrate > t && (t = s.bitrate); return t > 0 ? t : NaN }getBufferLength (e) { const t = this.hls.media; const r = e === Xe.AUDIO ? this.audioBuffer : this.videoBuffer; return !r || !t ? NaN : de.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3 }createPlaylistLoader () { const { pLoader: e } = this.config; const t = this.applyPlaylistData; const r = e || this.config.loader; return class {constructor (s) { this.loader = void 0, this.loader = new r(s) } get stats () { return this.loader.stats } get context () { return this.loader.context }destroy () { this.loader.destroy() }abort () { this.loader.abort() }load (s, o, a) { t(s), this.loader.load(s, o, a) }} }createFragmentLoader () { const { fLoader: e } = this.config; const t = this.applyFragmentData; const r = e || this.config.loader; return class {constructor (s) { this.loader = void 0, this.loader = new r(s) } get stats () { return this.loader.stats } get context () { return this.loader.context }destroy () { this.loader.destroy() }abort () { this.loader.abort() }load (s, o, a) { t(s), this.loader.load(s, o, a) }} }} const c_ = 3e5; class d_ {constructor (e) { this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = '.', this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = C.log.bind(C, '[content-steering]:'), this.registerListeners() }registerListeners () { const e = this.hls; e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.ERROR, this.onError, this) }unregisterListeners () { const e = this.hls; e && (e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.ERROR, this.onError, this)) }startLoad () { if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) { if (this.updated) { const e = this.timeToLoad * 1e3 - (performance.now() - this.updated); if (e > 0) { this.scheduleRefresh(this.uri, e); return } } this.loadSteeringManifest(this.uri) } }stopLoad () { this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout() }clearTimeout () { this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1) }destroy () { this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null }removeLevel (e) { const t = this.levels; t && (this.levels = t.filter(r => r !== e)) }onManifestLoading () { this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = '.', this.levels = this.audioTracks = this.subtitleTracks = null }onManifestLoaded (e, t) { const { contentSteering: r } = t; r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad()) }onManifestParsed (e, t) { this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks }onError (e, t) { const { errorAction: r } = t; if ((r == null ? void 0 : r.action) === je.SendAlternateToPenaltyBox && r.flags === Vt.MoveAllAlternatesMatchingHost) { const i = this.levels; let s = this.pathwayPriority; let o = this.pathwayId; if (t.context) { const { groupId: a, pathwayId: l, type: u } = t.context; a && i ? o = this.getPathwayForGroupId(a, u, o) : l && (o = l) }o in this.penalizedPathways || (this.penalizedPathways[o] = performance.now()), !s && i && (s = i.reduce((a, l) => (a.indexOf(l.pathwayId) === -1 && a.push(l.pathwayId), a), [])), s && s.length > 1 && (this.updatePathwayPriority(s), r.resolved = this.pathwayId !== o), r.resolved || C.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${o} levels: ${i && i.length} priorities: ${JSON.stringify(s)} penalized: ${JSON.stringify(this.penalizedPathways)}`) } }filterParsedLevels (e) { this.levels = e; let t = this.getLevelsForPathway(this.pathwayId); if (t.length === 0) { const r = e[0].pathwayId; this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), t = this.getLevelsForPathway(r), this.pathwayId = r } return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e }getLevelsForPathway (e) { return this.levels === null ? [] : this.levels.filter(t => e === t.pathwayId) }updatePathwayPriority (e) { this.pathwayPriority = e; let t; const r = this.penalizedPathways; const i = performance.now(); Object.keys(r).forEach(s => { i - r[s] > c_ && delete r[s] }); for (let s = 0; s < e.length; s++) { const o = e[s]; if (o in r) continue; if (o === this.pathwayId) return; const a = this.hls.nextLoadLevel; const l = this.hls.levels[a]; if (t = this.getLevelsForPathway(o), t.length > 0) { this.log(`Setting Pathway to "${o}"`), this.pathwayId = o, Sv(t), this.hls.trigger(S.LEVELS_UPDATED, { levels: t }); const u = this.hls.levels[a]; l && u && this.levels && (u.attrs['STABLE-VARIANT-ID'] !== l.attrs['STABLE-VARIANT-ID'] && u.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${u.bitrate}`), this.hls.nextLoadLevel = a); break } } }getPathwayForGroupId (e, t, r) { const i = this.getLevelsForPathway(r).concat(this.levels || []); for (let s = 0; s < i.length; s++) if (t === se.AUDIO_TRACK && i[s].hasAudioGroup(e) || t === se.SUBTITLE_TRACK && i[s].hasSubtitleGroup(e)) return i[s].pathwayId; return r }clonePathways (e) { const t = this.levels; if (!t) return; const r = {}; const i = {}; e.forEach(s => { const { ID: o, 'BASE-ID': a, 'URI-REPLACEMENT': l } = s; if (t.some(c => c.pathwayId === o)) return; const u = this.getLevelsForPathway(a).map(c => { const d = new ve(c.attrs); d['PATHWAY-ID'] = o; const h = d.AUDIO && `${d.AUDIO}_clone_${o}`; const f = d.SUBTITLES && `${d.SUBTITLES}_clone_${o}`; h && (r[d.AUDIO] = h, d.AUDIO = h), f && (i[d.SUBTITLES] = f, d.SUBTITLES = f); const p = nE(c.uri, d['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', l); const m = new Yi({ attrs: d, audioCodec: c.audioCodec, bitrate: c.bitrate, height: c.height, name: c.name, url: p, videoCodec: c.videoCodec, width: c.width }); if (c.audioGroups) for (let y = 1; y < c.audioGroups.length; y++)m.addGroupId('audio', `${c.audioGroups[y]}_clone_${o}`); if (c.subtitleGroups) for (let y = 1; y < c.subtitleGroups.length; y++)m.addGroupId('text', `${c.subtitleGroups[y]}_clone_${o}`); return m }); t.push(...u), ym(this.audioTracks, r, l, o), ym(this.subtitleTracks, i, l, o) }) }loadSteeringManifest (e) { const t = this.hls.config; const r = t.loader; this.loader && this.loader.destroy(), this.loader = new r(t); let i; try { i = new self.URL(e) } catch { this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`); return } if (i.protocol !== 'data:') { const c = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0; i.searchParams.set('_HLS_pathway', this.pathwayId), i.searchParams.set('_HLS_throughput', '' + c) } const s = { responseType: 'json', url: i.href }; const o = t.steeringManifestLoadPolicy.default; const a = o.errorRetry || o.timeoutRetry || {}; const l = { loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: a.maxNumRetry || 0, retryDelay: a.retryDelayMs || 0, maxRetryDelay: a.maxRetryDelayMs || 0 }; const u = { onSuccess: (c, d, h, f) => { this.log(`Loaded steering manifest: "${i}"`); const p = c.data; if (p.VERSION !== 1) { this.log(`Steering VERSION ${p.VERSION} not supported!`); return } this.updated = performance.now(), this.timeToLoad = p.TTL; const { 'RELOAD-URI': m, 'PATHWAY-CLONES': y, 'PATHWAY-PRIORITY': g } = p; if (m) try { this.uri = new self.URL(m, i).href } catch { this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${m}`); return } this.scheduleRefresh(this.uri || h.url), y && this.clonePathways(y); const v = { steeringManifest: p, url: i.toString() }; this.hls.trigger(S.STEERING_MANIFEST_LOADED, v), g && this.updatePathwayPriority(g) }, onError: (c, d, h, f) => { if (this.log(`Error loading steering manifest: ${c.code} ${c.text} (${d.url})`), this.stopLoad(), c.code === 410) { this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`); return } let p = this.timeToLoad * 1e3; if (c.code === 429) { const m = this.loader; if (typeof (m == null ? void 0 : m.getResponseHeader) === 'function') { const y = m.getResponseHeader('Retry-After'); y && (p = parseFloat(y) * 1e3) } this.log(`Steering manifest ${d.url} rate limited`); return } this.scheduleRefresh(this.uri || d.url, p) }, onTimeout: (c, d, h) => { this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url) } }; this.log(`Requesting steering manifest: ${i}`), this.loader.load(s, l, u) }scheduleRefresh (e, t = this.timeToLoad * 1e3) { this.clearTimeout(), this.reloadTimer = self.setTimeout(() => { let r; const i = (r = this.hls) == null ? void 0 : r.media; if (i && !i.ended) { this.loadSteeringManifest(e); return } this.scheduleRefresh(e, this.timeToLoad * 1e3) }, t) }} function ym (n, e, t, r) { n && Object.keys(e).forEach(i => { const s = n.filter(o => o.groupId === i).map(o => { const a = De({}, o); return a.details = void 0, a.attrs = new ve(a.attrs), a.url = a.attrs.URI = nE(o.url, o.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', t), a.groupId = a.attrs['GROUP-ID'] = e[i], a.attrs['PATHWAY-ID'] = r, a }); n.push(...s) }) } function nE (n, e, t, r) { const { HOST: i, PARAMS: s, [t]: o } = r; let a; e && (a = o == null ? void 0 : o[e], a && (n = a)); const l = new self.URL(n); return i && !a && (l.host = i), s && Object.keys(s).sort().forEach(u => { u && l.searchParams.set(u, s[u]) }), l.href } const h_ = /^age:\s*[\d.]+\s*$/im; class rE {constructor (e) { this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new Il(), this.retryDelay = 0 }destroy () { this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null, this.stats = null }abortInternal () { const e = this.loader; self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort())) }abort () { let e; this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader) }load (e, t, r) { if (this.stats.loading.start) throw new Error('Loader can only be used once.'); this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal() }loadInternal () { const { config: e, context: t } = this; if (!e || !t) return; const r = this.loader = new self.XMLHttpRequest(); const i = this.stats; i.loading.first = 0, i.loaded = 0, i.aborted = !1; const s = this.xhrSetup; s ? Promise.resolve().then(() => { if (!this.stats.aborted) return s(r, t.url) }).catch(o => (r.open('GET', t.url, !0), s(r, t.url))).then(() => { this.stats.aborted || this.openAndSendXhr(r, t, e) }).catch(o => { this.callbacks.onError({ code: r.status, text: o.message }, t, r, i) }) : this.openAndSendXhr(r, t, e) }openAndSendXhr (e, t, r) { e.readyState || e.open('GET', t.url, !0); const i = t.headers; const { maxTimeToFirstByteMs: s, maxLoadTimeMs: o } = r.loadPolicy; if (i) for (const a in i)e.setRequestHeader(a, i[a]); t.rangeEnd && e.setRequestHeader('Range', 'bytes=' + t.rangeStart + '-' + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = s && K(s) ? s : o, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send() }readystatechange () { const { context: e, loader: t, stats: r } = this; if (!e || !t) return; const i = t.readyState; const s = this.config; if (!r.aborted && i >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), i === 4)) { self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null; const o = t.status; const a = t.responseType !== 'text'; if (o >= 200 && o < 300 && (a && t.response || t.responseText !== null)) { r.loading.end = Math.max(self.performance.now(), r.loading.first); const l = a ? t.response : t.responseText; const u = t.responseType === 'arraybuffer' ? l.byteLength : l.length; if (r.loaded = r.total = u, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first), !this.callbacks) return; const c = this.callbacks.onProgress; if (c && c(r, e, l, t), !this.callbacks) return; const d = { url: t.responseURL, data: l, code: o }; this.callbacks.onSuccess(d, r, e, t) } else { const l = s.loadPolicy.errorRetry; const u = r.retry; const c = { url: e.url, data: void 0, code: o }; tl(l, u, !1, c) ? this.retry(l) : (C.error(`${o} while loading ${e.url}`), this.callbacks.onError({ code: o, text: t.statusText }, e, t, r)) } } }loadtimeout () { let e; const t = (e = this.config) == null ? void 0 : e.loadPolicy.timeoutRetry; const r = this.stats.retry; if (tl(t, r, !0)) this.retry(t); else { let i; C.warn(`timeout while loading ${(i = this.context) == null ? void 0 : i.url}`); const s = this.callbacks; s && (this.abortInternal(), s.onTimeout(this.stats, this.context, this.loader)) } }retry (e) { const { context: t, stats: r } = this; this.retryDelay = Lh(e, r.retry), r.retry++, C.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${t == null ? void 0 : t.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay) }loadprogress (e) { const t = this.stats; t.loaded = e.loaded, e.lengthComputable && (t.total = e.total) }getCacheAge () { let e = null; if (this.loader && h_.test(this.loader.getAllResponseHeaders())) { const t = this.loader.getResponseHeader('age'); e = t ? parseFloat(t) : null } return e }getResponseHeader (e) { return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, 'im').test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null }} function f_ () { if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try { return new self.ReadableStream({}), !0 } catch {} return !1 } const p_ = /(\d+)-(\d+)\/(\d+)/; class vm {constructor (e) { this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || v_, this.controller = new self.AbortController(), this.stats = new Il() }destroy () { this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null }abortInternal () { this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort()) }abort () { let e; this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response) }load (e, t, r) { const i = this.stats; if (i.loading.start) throw new Error('Loader can only be used once.'); i.loading.start = self.performance.now(); const s = m_(e, this.controller.signal); const o = r.onProgress; const a = e.responseType === 'arraybuffer'; const l = a ? 'byteLength' : 'length'; const { maxTimeToFirstByteMs: u, maxLoadTimeMs: c } = t.loadPolicy; this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), t.timeout = u && K(u) ? u : c, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), r.onTimeout(i, e, this.response) }, t.timeout), self.fetch(this.request).then(d => { this.response = this.loader = d; const h = Math.max(self.performance.now(), i.loading.start); if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), r.onTimeout(i, e, this.response) }, c - (h - i.loading.start)), !d.ok) { const { status: f, statusText: p } = d; throw new E_(p || 'fetch, bad network response', f, d) } return i.loading.first = h, i.total = y_(d.headers) || i.total, o && K(t.highWaterMark) ? this.loadProgressively(d, i, e, t.highWaterMark, o) : a ? d.arrayBuffer() : e.responseType === 'json' ? d.json() : d.text() }).then(d => { const h = this.response; if (!h) throw new Error('loader destroyed'); self.clearTimeout(this.requestTimeout), i.loading.end = Math.max(self.performance.now(), i.loading.first); const f = d[l]; f && (i.loaded = i.total = f); const p = { url: h.url, data: d, code: h.status }; o && !K(t.highWaterMark) && o(i, e, d, h), r.onSuccess(p, i, e, h) }).catch(d => { if (self.clearTimeout(this.requestTimeout), i.aborted) return; const h = d && d.code || 0; const f = d ? d.message : null; r.onError({ code: h, text: f }, e, d ? d.details : null, i) }) }getCacheAge () { let e = null; if (this.response) { const t = this.response.headers.get('age'); e = t ? parseFloat(t) : null } return e }getResponseHeader (e) { return this.response ? this.response.headers.get(e) : null }loadProgressively (e, t, r, i = 0, s) { const o = new Rv(); const a = e.body.getReader(); const l = () => a.read().then(u => { if (u.done) return o.dataLength && s(t, r, o.flush(), e), Promise.resolve(new ArrayBuffer(0)); const c = u.value; const d = c.length; return t.loaded += d, d < i || o.dataLength ? (o.push(c), o.dataLength >= i && s(t, r, o.flush(), e)) : s(t, r, c, e), l() }).catch(() => Promise.reject()); return l() }} function m_ (n, e) { const t = { method: 'GET', mode: 'cors', credentials: 'same-origin', signal: e, headers: new self.Headers(De({}, n.headers)) }; return n.rangeEnd && t.headers.set('Range', 'bytes=' + n.rangeStart + '-' + String(n.rangeEnd - 1)), t } function g_ (n) { const e = p_.exec(n); if (e) return parseInt(e[2]) - parseInt(e[1]) + 1 } function y_ (n) { const e = n.get('Content-Range'); if (e) { const r = g_(e); if (K(r)) return r } const t = n.get('Content-Length'); if (t) return parseInt(t) } function v_ (n, e) { return new self.Request(n.url, e) } class E_ extends Error {constructor (e, t, r) { super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r }} const S_ = /\s/; const T_ = { newCue (n, e, t, r) { const i = []; let s, o, a, l, u; const c = self.VTTCue || self.TextTrackCue; for (let h = 0; h < r.rows.length; h++) if (s = r.rows[h], a = !0, l = 0, u = '', !s.isEmpty()) { var d; for (let m = 0; m < s.chars.length; m++)S_.test(s.chars[m].uchar) && a ? l++ : (u += s.chars[m].uchar, a = !1); s.cueStartTime = e, e === t && (t += 1e-4), l >= 16 ? l-- : l++; const f = zv(u.trim()); const p = Oh(e, t, f); n != null && (d = n.cues) != null && d.getCueById(p) || (o = new c(e, t, f), o.id = p, o.line = h + 1, o.align = 'left', o.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10), i.push(o)) } return n && i.length && (i.sort((h, f) => h.line === 'auto' || f.line === 'auto' ? 0 : h.line > 8 && f.line > 8 ? f.line - h.line : h.line - f.line), i.forEach(h => gv(n, h))), i } }; const x_ = { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null }; const iE = $e($e({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, ignoreDevicePixelRatio: !1, preferManagedMediaSource: !0, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, frontBufferFlushThreshold: 1 / 0, maxBufferSize: 60 * 1e3 * 1e3, maxBufferHole: 0.1, highBufferWatchdogPeriod: 2, nudgeOffset: 0.1, nudgeMaxRetry: 3, maxFragLookUpTolerance: 0.25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: !1, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: !0, workerPath: null, enableSoftwareAES: !0, startLevel: void 0, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: 0.2, appendErrorMaxRetry: 3, loader: rE, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: Jw, bufferController: nI, capLevelController: Fh, errorController: $w, fpsController: CI, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrEwmaDefaultEstimateMax: 5e6, abrBandWidthFactor: 0.95, abrBandWidthUpFactor: 0.7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, drmSystems: {}, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: nv, testBandwidth: !0, progressive: !1, lowLatencyMode: !0, cmcd: void 0, enableDateRangeMetadataCues: !0, enableEmsgMetadataCues: !0, enableID3MetadataCues: !0, useMediaCapabilities: !0, certLoadPolicy: { default: x_ }, keyLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: 'linear' }, errorRetry: { maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: 'linear' } } }, manifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1 / 0, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, playlistLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, fragLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 12e4, timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, steeringManifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3 }, L_()), {}, { subtitleStreamController: JC, subtitleTrackController: eI, timelineController: AI, audioStreamController: QC, audioTrackController: XC, emeController: Li, cmcdController: u_, contentSteeringController: d_ }); function L_ () { return { cueHandler: T_, enableWebVTT: !0, enableIMSC1: !0, enableCEA708Captions: !0, captionsTextTrack1Label: 'English', captionsTextTrack1LanguageCode: 'en', captionsTextTrack2Label: 'Spanish', captionsTextTrack2LanguageCode: 'es', captionsTextTrack3Label: 'Unknown CC', captionsTextTrack3LanguageCode: '', captionsTextTrack4Label: 'Unknown CC', captionsTextTrack4LanguageCode: '', renderTextTracksNatively: !0 } } function R_ (n, e) { if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'); if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'); const t = od(n); const r = ['manifest', 'level', 'frag']; const i = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout']; return r.forEach(s => { const o = `${s === 'level' ? 'playlist' : s}LoadPolicy`; const a = e[o] === void 0; const l = []; i.forEach(u => { const c = `${s}Loading${u}`; const d = e[c]; if (d !== void 0 && a) { l.push(c); const h = t[o].default; switch (e[o] = { default: h }, u) { case 'TimeOut':h.maxLoadTimeMs = d, h.maxTimeToFirstByteMs = d; break; case 'MaxRetry':h.errorRetry.maxNumRetry = d, h.timeoutRetry.maxNumRetry = d; break; case 'RetryDelay':h.errorRetry.retryDelayMs = d, h.timeoutRetry.retryDelayMs = d; break; case 'MaxRetryTimeout':h.errorRetry.maxRetryDelayMs = d, h.timeoutRetry.maxRetryDelayMs = d; break } } }), l.length && C.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${JSON.stringify(e[o])}`) }), $e($e({}, t), e) } function od (n) { return n && typeof n === 'object' ? Array.isArray(n) ? n.map(od) : Object.keys(n).reduce((e, t) => (e[t] = od(n[t]), e), {}) : n } function A_ (n) { const e = n.loader; e !== vm && e !== rE ? (C.log('[config]: Custom loader detected, cannot enable progressive streaming'), n.progressive = !1) : f_() && (n.loader = vm, n.progressive = !0, n.enableSoftwareAES = !0, C.log('[config]: Progressive streaming enabled, using FetchLoader')) } let Pu; class w_ extends Rh {constructor (e, t) { super(e, '[level-controller]'), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners() }_registerListeners () { const { hls: e } = this; e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(S.LEVEL_LOADED, this.onLevelLoaded, this), e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this), e.on(S.ERROR, this.onError, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(S.LEVEL_LOADED, this.onLevelLoaded, this), e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this), e.off(S.ERROR, this.onError, this) }destroy () { this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy() }stopLoad () { this._levels.forEach(t => { t.loadError = 0, t.fragmentError = 0 }), super.stopLoad() }resetLevels () { this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1 }onManifestLoading (e, t) { this.resetLevels() }onManifestLoaded (e, t) { const r = this.hls.config.preferManagedMediaSource; const i = []; const s = {}; const o = {}; let a = !1; let l = !1; let u = !1; t.levels.forEach(c => { let d, h; const f = c.attrs; let { audioCodec: p, videoCodec: m } = c; ((d = p) == null ? void 0 : d.indexOf('mp4a.40.34')) !== -1 && (Pu || (Pu = /chrome|firefox/i.test(navigator.userAgent)), Pu && (c.audioCodec = p = void 0)), p && (c.audioCodec = p = Ja(p, r)), ((h = m) == null ? void 0 : h.indexOf('avc1')) === 0 && (m = c.videoCodec = gw(m)); const { width: y, height: g, unknownCodecs: v } = c; if (a || (a = !!(y && g)), l || (l = !!m), u || (u = !!p), v != null && v.length || p && !yu(p, 'audio', r) || m && !yu(m, 'video', r)) return; const { CODECS: E, 'FRAME-RATE': x, 'HDCP-LEVEL': T, 'PATHWAY-ID': w, RESOLUTION: L, 'VIDEO-RANGE': A } = f; const _ = `${`${w || '.'}-`}${c.bitrate}-${L}-${x}-${E}-${A}-${T}`; if (s[_]) if (s[_].uri !== c.url && !c.attrs['PATHWAY-ID']) { const F = o[_] += 1; c.attrs['PATHWAY-ID'] = new Array(F + 1).join('.'); const $ = new Yi(c); s[_] = $, i.push($) } else s[_].addGroupId('audio', f.AUDIO), s[_].addGroupId('text', f.SUBTITLES); else { const F = new Yi(c); s[_] = F, o[_] = 1, i.push(F) } }), this.filterAndSortMediaOptions(i, t, a, l, u) }filterAndSortMediaOptions (e, t, r, i, s) { let o = []; let a = []; let l = e; if ((r || i) && s && (l = l.filter(({ videoCodec: p, videoRange: m, width: y, height: g }) => (!!p || !!(y && g)) && _w(m))), l.length === 0) { Promise.resolve().then(() => { if (this.hls) { t.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(t.levels[0].attrs)}`); const p = new Error('no level with compatible codecs found in manifest'); this.hls.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: t.url, error: p, reason: p.message }) } }); return } if (t.audioTracks) { const { preferManagedMediaSource: p } = this.hls.config; o = t.audioTracks.filter(m => !m.audioCodec || yu(m.audioCodec, 'audio', p)), Em(o) }t.subtitles && (a = t.subtitles, Em(a)); const u = l.slice(0); l.sort((p, m) => { if (p.attrs['HDCP-LEVEL'] !== m.attrs['HDCP-LEVEL']) return (p.attrs['HDCP-LEVEL'] || '') > (m.attrs['HDCP-LEVEL'] || '') ? 1 : -1; if (r && p.height !== m.height) return p.height - m.height; if (p.frameRate !== m.frameRate) return p.frameRate - m.frameRate; if (p.videoRange !== m.videoRange) return Za.indexOf(p.videoRange) - Za.indexOf(m.videoRange); if (p.videoCodec !== m.videoCodec) { const y = Lp(p.videoCodec); const g = Lp(m.videoCodec); if (y !== g) return g - y } if (p.uri === m.uri && p.codecSet !== m.codecSet) { const y = Xa(p.codecSet); const g = Xa(m.codecSet); if (y !== g) return g - y } return p.averageBitrate !== m.averageBitrate ? p.averageBitrate - m.averageBitrate : 0 }); let c = u[0]; if (this.steering && (l = this.steering.filterParsedLevels(l), l.length !== u.length)) { for (let p = 0; p < u.length; p++) if (u[p].pathwayId === l[0].pathwayId) { c = u[p]; break } } this._levels = l; for (let p = 0; p < l.length; p++) if (l[p] === c) { var d; this._firstLevel = p; const m = c.bitrate; const y = this.hls.bandwidthEstimate; if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${m}`), ((d = this.hls.userConfig) == null ? void 0 : d.abrEwmaDefaultEstimate) === void 0) { const g = Math.min(m, this.hls.config.abrEwmaDefaultEstimateMax); g > y && y === iE.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = g) } break } const h = s && !i; const f = { levels: l, audioTracks: o, subtitleTracks: a, sessionData: t.sessionData, sessionKeys: t.sessionKeys, firstLevel: this._firstLevel, stats: t.stats, audio: s, video: i, altAudio: !h && o.some(p => !!p.url) }; this.hls.trigger(S.MANIFEST_PARSED, f), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition) } get levels () { return this._levels.length === 0 ? null : this._levels } get level () { return this.currentLevelIndex } set level (e) { const t = this._levels; if (t.length === 0) return; if (e < 0 || e >= t.length) { const c = new Error('invalid level idx'); const d = e < 0; if (this.hls.trigger(S.ERROR, { type: J.OTHER_ERROR, details: D.LEVEL_SWITCH_ERROR, level: e, fatal: d, error: c, reason: c.message }), d) return; e = Math.min(e, t.length - 1) } const r = this.currentLevelIndex; const i = this.currentLevel; const s = i ? i.attrs['PATHWAY-ID'] : void 0; const o = t[e]; const a = o.attrs['PATHWAY-ID']; if (this.currentLevelIndex = e, this.currentLevel = o, r === e && o.details && i && s === a) return; this.log(`Switching to level ${e} (${o.height ? o.height + 'p ' : ''}${o.videoRange ? o.videoRange + ' ' : ''}${o.codecSet ? o.codecSet + ' ' : ''}@${o.bitrate})${a ? ' with Pathway ' + a : ''} from level ${r}${s ? ' with Pathway ' + s : ''}`); const l = { level: e, attrs: o.attrs, details: o.details, bitrate: o.bitrate, averageBitrate: o.averageBitrate, maxBitrate: o.maxBitrate, realBitrate: o.realBitrate, width: o.width, height: o.height, codecSet: o.codecSet, audioCodec: o.audioCodec, videoCodec: o.videoCodec, audioGroups: o.audioGroups, subtitleGroups: o.subtitleGroups, loaded: o.loaded, loadError: o.loadError, fragmentError: o.fragmentError, name: o.name, id: o.id, uri: o.uri, url: o.url, urlId: 0, audioGroupIds: o.audioGroupIds, textGroupIds: o.textGroupIds }; this.hls.trigger(S.LEVEL_SWITCHING, l); const u = o.details; if (!u || u.live) { const c = this.switchParams(o.uri, i == null ? void 0 : i.details, u); this.loadPlaylist(c) } } get manualLevel () { return this.manualLevelIndex } set manualLevel (e) { this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e) } get firstLevel () { return this._firstLevel } set firstLevel (e) { this._firstLevel = e } get startLevel () { if (this._startLevel === void 0) { const e = this.hls.config.startLevel; return e !== void 0 ? e : this.hls.firstAutoLevel } return this._startLevel } set startLevel (e) { this._startLevel = e }onError (e, t) { t.fatal || !t.context || t.context.type === se.LEVEL && t.context.level === this.level && this.checkRetry(t) }onFragBuffered (e, { frag: t }) { if (t !== void 0 && t.type === X.MAIN) { const r = t.elementaryStreams; if (!Object.keys(r).some(s => !!r[s])) return; const i = this._levels[t.level]; i != null && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0) } }onLevelLoaded (e, t) { let r; const { level: i, details: s } = t; const o = this._levels[i]; if (!o) { let a; this.warn(`Invalid level index ${i}`), (a = t.deliveryDirectives) != null && a.skip && (s.deltaUpdateFailed = !0); return }i === this.currentLevelIndex ? (o.fragmentError === 0 && (o.loadError = 0), this.playlistLoaded(i, t, o.details)) : (r = t.deliveryDirectives) != null && r.skip && (s.deltaUpdateFailed = !0) }loadPlaylist (e) { super.loadPlaylist(); const t = this.currentLevelIndex; const r = this.currentLevel; if (r && this.shouldLoadPlaylist(r)) { let i = r.uri; if (e) try { i = e.addDirectives(i) } catch (o) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`) } const s = r.attrs['PATHWAY-ID']; this.log(`Loading level index ${t}${(e == null ? void 0 : e.msn) !== void 0 ? ' at sn ' + e.msn + ' part ' + e.part : ''} with${s ? ' Pathway ' + s : ''} ${i}`), this.clearTimer(), this.hls.trigger(S.LEVEL_LOADING, { url: i, level: t, pathwayId: r.attrs['PATHWAY-ID'], id: 0, deliveryDirectives: e || null }) } } get nextLoadLevel () { return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel } set nextLoadLevel (e) { this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e) }removeLevel (e) { let t; const r = this._levels.filter((i, s) => s !== e ? !0 : (this.steering && this.steering.removeLevel(i), i === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, i.details && i.details.fragments.forEach(o => o.level = -1)), !1)); Sv(r), this._levels = r, this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(S.LEVELS_UPDATED, { levels: r }) }onLevelsUpdated (e, { levels: t }) { this._levels = t }checkMaxAutoUpdated () { const { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: r } = this.hls; this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(S.MAX_AUTO_LEVEL_UPDATED, { autoLevelCapping: e, levels: this.levels, maxAutoLevel: t, minAutoLevel: this.hls.minAutoLevel, maxHdcpLevel: r })) }} function Em (n) { const e = {}; n.forEach(t => { const r = t.groupId || ''; t.id = e[r] = e[r] || 0, e[r]++ }) } class C_ {constructor (e) { this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e }abort (e) { for (const r in this.keyUriToKeyInfo) { const i = this.keyUriToKeyInfo[r].loader; if (i) { var t; if (e && e !== ((t = i.context) == null ? void 0 : t.frag.type)) return; i.abort() } } }detach () { for (const e in this.keyUriToKeyInfo) { const t = this.keyUriToKeyInfo[e]; (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e] } }destroy () { this.detach(); for (const e in this.keyUriToKeyInfo) { const t = this.keyUriToKeyInfo[e].loader; t && t.destroy() } this.keyUriToKeyInfo = {} }createKeyLoadError (e, t = D.KEY_LOAD_ERROR, r, i, s) { return new En({ type: J.NETWORK_ERROR, details: t, fatal: !1, frag: e, response: s, error: r, networkDetails: i }) }loadClear (e, t) { if (this.emeController && this.config.emeEnabled) { const { sn: r, cc: i } = e; for (let s = 0; s < t.length; s++) { const o = t[s]; if (i <= o.cc && (r === 'initSegment' || o.sn === 'initSegment' || r < o.sn)) { this.emeController.selectKeySystemFormat(o).then(a => { o.setKeyFormat(a) }); break } } } }load (e) { return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e) }loadInternal (e, t) { let r, i; t && e.setKeyFormat(t); const s = e.decryptdata; if (!s) { const u = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : 'Missing decryption data on fragment in onKeyLoading'); return Promise.reject(this.createKeyLoadError(e, D.KEY_LOAD_ERROR, u)) } const o = s.uri; if (!o) return Promise.reject(this.createKeyLoadError(e, D.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${o}"`))); let a = this.keyUriToKeyInfo[o]; if ((r = a) != null && r.decryptdata.key) return s.key = a.decryptdata.key, Promise.resolve({ frag: e, keyInfo: a }); if ((i = a) != null && i.keyLoadPromise) { let l; switch ((l = a.mediaKeySessionContext) == null ? void 0 : l.keyStatus) { case void 0:case 'status-pending':case 'usable':case 'usable-in-future':return a.keyLoadPromise.then(u => (s.key = u.keyInfo.decryptdata.key, { frag: e, keyInfo: a })) } } switch (a = this.keyUriToKeyInfo[o] = { decryptdata: s, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }, s.method) { case 'ISO-23001-7':case 'SAMPLE-AES':case 'SAMPLE-AES-CENC':case 'SAMPLE-AES-CTR':return s.keyFormat === 'identity' ? this.loadKeyHTTP(a, e) : this.loadKeyEME(a, e); case 'AES-128':return this.loadKeyHTTP(a, e); default:return Promise.reject(this.createKeyLoadError(e, D.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`))) } }loadKeyEME (e, t) { const r = { frag: t, keyInfo: e }; if (this.emeController && this.config.emeEnabled) { const i = this.emeController.loadKey(r); if (i) return (e.keyLoadPromise = i.then(s => (e.mediaKeySessionContext = s, r))).catch(s => { throw e.keyLoadPromise = null, s }) } return Promise.resolve(r) }loadKeyHTTP (e, t) { const r = this.config; const i = r.loader; const s = new i(r); return t.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((o, a) => { const l = { keyInfo: e, frag: t, responseType: 'arraybuffer', url: e.decryptdata.uri }; const u = r.keyLoadPolicy.default; const c = { loadPolicy: u, timeout: u.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; const d = { onSuccess: (h, f, p, m) => { const { frag: y, keyInfo: g, url: v } = p; if (!y.decryptdata || g !== this.keyUriToKeyInfo[v]) return a(this.createKeyLoadError(y, D.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), m)); g.decryptdata.key = y.decryptdata.key = new Uint8Array(h.data), y.keyLoader = null, g.loader = null, o({ frag: y, keyInfo: g }) }, onError: (h, f, p, m) => { this.resetLoader(f), a(this.createKeyLoadError(t, D.KEY_LOAD_ERROR, new Error(`HTTP Error ${h.code} loading key ${h.text}`), p, $e({ url: l.url, data: void 0 }, h))) }, onTimeout: (h, f, p) => { this.resetLoader(f), a(this.createKeyLoadError(t, D.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), p)) }, onAbort: (h, f, p) => { this.resetLoader(f), a(this.createKeyLoadError(t, D.INTERNAL_ABORTED, new Error('key loading aborted'), p)) } }; s.load(l, c, d) }) }resetLoader (e) { const { frag: t, keyInfo: r, url: i } = e; const s = r.loader; t.keyLoader === s && (t.keyLoader = null, r.loader = null), delete this.keyUriToKeyInfo[i], s && s.destroy() }} function sE () { return self.SourceBuffer || self.WebKitSourceBuffer } function oE () { if (!$r()) return !1; const e = sE(); return !e || e.prototype && typeof e.prototype.appendBuffer === 'function' && typeof e.prototype.remove === 'function' } function I_ () { if (!oE()) return !1; const n = $r(); return typeof (n == null ? void 0 : n.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(e => n.isTypeSupported(to(e, 'video'))) || ['mp4a.40.2', 'fLaC'].some(e => n.isTypeSupported(to(e, 'audio')))) } function __ () { let n; const e = sE(); return typeof (e == null || (n = e.prototype) == null ? void 0 : n.changeType) === 'function' } const D_ = 250; const Sa = 2; const k_ = 0.1; const P_ = 0.05; class b_ {constructor (e, t, r, i) { this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i }destroy () { this.media = null, this.hls = this.fragmentTracker = null }poll (e, t) { const { config: r, media: i, stalled: s } = this; if (i === null) return; const { currentTime: o, seeking: a } = i; const l = this.seeking && !a; const u = !this.seeking && a; if (this.seeking = a, o !== e) { if (this.moved = !0, a || (this.nudgeRetry = 0), s !== null) { if (this.stallReported) { const y = self.performance.now() - s; C.warn(`playback not stuck anymore @${o}, after ${Math.round(y)}ms`), this.stallReported = !1 } this.stalled = null } return } if (u || l) { this.stalled = null; return } if (i.paused && !a || i.ended || i.playbackRate === 0 || !de.getBuffered(i).length) { this.nudgeRetry = 0; return } const c = de.bufferInfo(i, o, 0); const d = c.nextStart || 0; if (a) { const y = c.len > Sa; const g = !d || t && t.start <= o || d - o > Sa && !this.fragmentTracker.getPartialFragment(o); if (y || g) return; this.moved = !1 } if (!this.moved && this.stalled !== null) { let h; if (!(c.len > 0) && !d) return; const g = Math.max(d, c.start || 0) - o; const v = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null; const x = (v == null || (h = v.details) == null ? void 0 : h.live) ? v.details.targetduration * 2 : Sa; const T = this.fragmentTracker.getPartialFragment(o); if (g > 0 && (g <= x || T)) { i.paused || this._trySkipBufferHole(T); return } } const f = self.performance.now(); if (s === null) { this.stalled = f; return } const p = f - s; if (!a && p >= D_ && (this._reportStall(c), !this.media)) return; const m = de.bufferInfo(i, o, r.maxBufferHole); this._tryFixBufferStall(m, p) }_tryFixBufferStall (e, t) { const { config: r, fragmentTracker: i, media: s } = this; if (s === null) return; const o = s.currentTime; const a = i.getPartialFragment(o); a && (this._trySkipBufferHole(a) || !this.media) || (e.len > r.maxBufferHole || e.nextStart && e.nextStart - o < r.maxBufferHole) && t > r.highBufferWatchdogPeriod * 1e3 && (C.warn('Trying to nudge playhead over buffer-hole'), this.stalled = null, this._tryNudgeBuffer()) }_reportStall (e) { const { hls: t, media: r, stallReported: i } = this; if (!i && r) { this.stallReported = !0; const s = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${JSON.stringify(e)})`); C.warn(s.message), t.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_STALLED_ERROR, fatal: !1, error: s, buffer: e.len }) } }_trySkipBufferHole (e) { const { config: t, hls: r, media: i } = this; if (i === null) return 0; const s = i.currentTime; const o = de.bufferInfo(i, s, 0); const a = s < o.start ? o.start : o.nextStart; if (a) { const l = o.len <= t.maxBufferHole; const u = o.len > 0 && o.len < 1 && i.readyState < 3; const c = a - s; if (c > 0 && (l || u)) { if (c > t.maxBufferHole) { const { fragmentTracker: h } = this; let f = !1; if (s === 0) { const p = h.getAppendedFrag(0, X.MAIN); p && a < p.end && (f = !0) } if (!f) { const p = e || h.getAppendedFrag(s, X.MAIN); if (p) { let m = !1; let y = p.end; for (;y < a;) { const g = h.getPartialFragment(y); if (g)y += g.duration; else { m = !0; break } } if (m) return 0 } } } const d = Math.max(a + P_, s + k_); if (C.warn(`skipping hole, adjusting currentTime from ${s} to ${d}`), this.moved = !0, this.stalled = null, i.currentTime = d, e && !e.gap) { const h = new Error(`fragment loaded with buffer holes, seeking from ${s} to ${d}`); r.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: h, reason: h.message, frag: e }) } return d } } return 0 }_tryNudgeBuffer () { const { config: e, hls: t, media: r, nudgeRetry: i } = this; if (r === null) return; const s = r.currentTime; if (this.nudgeRetry++, i < e.nudgeMaxRetry) { const o = s + (i + 1) * e.nudgeOffset; const a = new Error(`Nudging 'currentTime' from ${s} to ${o}`); C.warn(a.message), r.currentTime = o, t.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_NUDGE_ON_STALL, error: a, fatal: !1 }) } else { const o = new Error(`Playhead still not moving while enough data buffered @${s} after ${e.nudgeMaxRetry} nudges`); C.error(o.message), t.trigger(S.ERROR, { type: J.MEDIA_ERROR, details: D.BUFFER_STALLED_ERROR, error: o, fatal: !0 }) } }} const O_ = 100; class F_ extends Ch {constructor (e, t, r) { super(e, t, r, '[stream-controller]', X.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners() }_registerListeners () { const { hls: e } = this; e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(S.MANIFEST_LOADING, this.onManifestLoading, this), e.on(S.MANIFEST_PARSED, this.onManifestParsed, this), e.on(S.LEVEL_LOADING, this.onLevelLoading, this), e.on(S.LEVEL_LOADED, this.onLevelLoaded, this), e.on(S.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(S.ERROR, this.onError, this), e.on(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(S.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(S.BUFFER_CREATED, this.onBufferCreated, this), e.on(S.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(S.FRAG_BUFFERED, this.onFragBuffered, this) }_unregisterListeners () { const { hls: e } = this; e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(S.MANIFEST_LOADING, this.onManifestLoading, this), e.off(S.MANIFEST_PARSED, this.onManifestParsed, this), e.off(S.LEVEL_LOADED, this.onLevelLoaded, this), e.off(S.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(S.ERROR, this.onError, this), e.off(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(S.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(S.BUFFER_CREATED, this.onBufferCreated, this), e.off(S.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(S.FRAG_BUFFERED, this.onFragBuffered, this) }onHandlerDestroying () { this._unregisterListeners(), super.onHandlerDestroying() }startLoad (e) { if (this.levels) { const { lastCurrentTime: t, hls: r } = this; if (this.stopLoad(), this.setInterval(O_), this.level = -1, !this.startFragRequested) { let i = r.startLevel; i === -1 && (r.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = r.firstAutoLevel), r.nextLoadLevel = i, this.level = r.loadLevel, this.loadedmetadata = !1 }t > 0 && e === -1 && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = O.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } else this._forceStartLoad = !0, this.state = O.STOPPED }stopLoad () { this._forceStartLoad = !1, super.stopLoad() }doTick () { switch (this.state) { case O.WAITING_LEVEL:{ const { levels: t, level: r } = this; const i = t == null ? void 0 : t[r]; const s = i == null ? void 0 : i.details; if (s && (!s.live || this.levelLastLoaded === i)) { if (this.waitForCdnTuneIn(s)) break; this.state = O.IDLE; break } else if (this.hls.nextLoadLevel !== this.level) { this.state = O.IDLE; break } break } case O.FRAG_LOADING_WAITING_RETRY:{ let e; const t = self.performance.now(); const r = this.retryDate; if (!r || t >= r || (e = this.media) != null && e.seeking) { const { levels: i, level: s } = this; const o = i == null ? void 0 : i[s]; this.resetStartWhenNotLoaded(o || null), this.state = O.IDLE } } break } this.state === O.IDLE && this.doTickIdle(), this.onTickEnd() }onTickEnd () { super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged() }doTickIdle () { const { hls: e, levelLastLoaded: t, levels: r, media: i } = this; if (t === null || !i && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return; const s = e.nextLoadLevel; if (!(r != null && r[s])) return; const o = r[s]; const a = this.getMainFwdBufferInfo(); if (a === null) return; const l = this.getLevelDetails(); if (l && this._streamEnded(a, l)) { const m = {}; this.altAudio && (m.type = 'video'), this.hls.trigger(S.BUFFER_EOS, m), this.state = O.ENDED; return }e.loadLevel !== s && e.manualLevel === -1 && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s; const u = o.details; if (!u || this.state === O.WAITING_LEVEL || u.live && this.levelLastLoaded !== o) { this.level = s, this.state = O.WAITING_LEVEL; return } const c = a.len; const d = this.getMaxBufferLength(o.maxBitrate); if (c >= d) return; this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null); const h = this.backtrackFragment ? this.backtrackFragment.start : a.end; let f = this.getNextFragment(h, u); if (this.couldBacktrack && !this.fragPrevious && f && f.sn !== 'initSegment' && this.fragmentTracker.getState(f) !== Ue.OK) { let p; const y = ((p = this.backtrackFragment) != null ? p : f).sn - u.startSN; const g = u.fragments[y - 1]; g && f.cc === g.cc && (f = g, this.fragmentTracker.removeFragment(g)) } else this.backtrackFragment && a.len && (this.backtrackFragment = null); if (f && this.isLoopLoading(f, h)) { if (!f.gap) { const y = this.audioOnly && !this.altAudio ? ae.AUDIO : ae.VIDEO; const g = (y === ae.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; g && this.afterBufferFlushed(g, y, X.MAIN) }f = this.getNextFragmentLoopLoading(f, u, a, X.MAIN, d) }f && (f.initSegment && !f.initSegment.data && !this.bitrateTest && (f = f.initSegment), this.loadFragment(f, o, h)) }loadFragment (e, t, r) { const i = this.fragmentTracker.getState(e); this.fragCurrent = e, i === Ue.NOT_LOADED || i === Ue.PARTIAL ? e.sn === 'initSegment' ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) : this.clearTrackerIfNeeded(e) }getBufferedFrag (e) { return this.fragmentTracker.getBufferedFrag(e, X.MAIN) }followingBufferedFrag (e) { return e ? this.getBufferedFrag(e.end + 0.5) : null }immediateLevelSwitch () { this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY) }nextLevelSwitch () { const { levels: e, media: t } = this; if (t != null && t.readyState) { let r; const i = this.getAppendedFrag(t.currentTime); i && i.start > 1 && this.flushMainBuffer(0, i.start - 1); const s = this.getLevelDetails(); if (s != null && s.live) { const a = this.getMainFwdBufferInfo(); if (!a || a.len < s.targetduration * 2) return } if (!t.paused && e) { const a = this.hls.nextLoadLevel; const l = e[a]; const u = this.fragLastKbps; u && this.fragCurrent ? r = this.fragCurrent.duration * l.maxBitrate / (1e3 * u) + 1 : r = 0 } else r = 0; const o = this.getBufferedFrag(t.currentTime + r); if (o) { const a = this.followingBufferedFrag(o); if (a) { this.abortCurrentFrag(); const l = a.maxStartPTS ? a.maxStartPTS : a.start; const u = a.duration; const c = Math.max(o.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, u * (this.couldBacktrack ? 0.5 : 0.125)), u * (this.couldBacktrack ? 0.75 : 0.25))); this.flushMainBuffer(c, Number.POSITIVE_INFINITY) } } } }abortCurrentFrag () { const e = this.fragCurrent; switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) { case O.KEY_LOADING:case O.FRAG_LOADING:case O.FRAG_LOADING_WAITING_RETRY:case O.PARSING:case O.PARSED:this.state = O.IDLE; break } this.nextLoadPosition = this.getLoadPosition() }flushMainBuffer (e, t) { super.flushMainBuffer(e, t, this.altAudio ? 'video' : null) }onMediaAttached (e, t) { super.onMediaAttached(e, t); const r = t.media; this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), r.addEventListener('playing', this.onvplaying), r.addEventListener('seeked', this.onvseeked), this.gapController = new b_(this.config, r, this.fragmentTracker, this.hls) }onMediaDetaching () { const { media: e } = this; e && this.onvplaying && this.onvseeked && (e.removeEventListener('playing', this.onvplaying), e.removeEventListener('seeked', this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching() }onMediaPlaying () { this.tick() }onMediaSeeked () { const e = this.media; const t = e ? e.currentTime : null; K(t) && this.log(`Media seeked to ${t.toFixed(3)}`); const r = this.getMainFwdBufferInfo(); if (r === null || r.len === 0) { this.warn(`Main forward buffer length on "seeked" event ${r ? r.len : 'empty'})`); return } this.tick() }onManifestLoading () { this.log('Trigger BUFFER_RESET'), this.hls.trigger(S.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1 }onManifestParsed (e, t) { let r = !1; let i = !1; t.levels.forEach(s => { const o = s.audioCodec; o && (r = r || o.indexOf('mp4a.40.2') !== -1, i = i || o.indexOf('mp4a.40.5') !== -1) }), this.audioCodecSwitch = r && i && !__(), this.audioCodecSwitch && this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC'), this.levels = t.levels, this.startFragRequested = !1 }onLevelLoading (e, t) { const { levels: r } = this; if (!r || this.state !== O.IDLE) return; const i = r[t.level]; (!i.details || i.details.live && this.levelLastLoaded !== i || this.waitForCdnTuneIn(i.details)) && (this.state = O.WAITING_LEVEL) }onLevelLoaded (e, t) { let r; const { levels: i } = this; const s = t.level; const o = t.details; const a = o.totalduration; if (!i) { this.warn(`Levels were reset while loading level ${s}`); return } this.log(`Level ${s} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ''}, cc [${o.startCC}, ${o.endCC}] duration:${a}`); const l = i[s]; const u = this.fragCurrent; u && (this.state === O.FRAG_LOADING || this.state === O.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag(); let c = 0; if (o.live || (r = l.details) != null && r.live) { let d; if (this.checkLiveUpdate(o), o.deltaUpdateFailed) return; c = this.alignPlaylists(o, l.details, (d = this.levelLastLoaded) == null ? void 0 : d.details) } if (l.details = o, this.levelLastLoaded = l, this.hls.trigger(S.LEVEL_UPDATED, { details: o, level: s }), this.state === O.WAITING_LEVEL) { if (this.waitForCdnTuneIn(o)) return; this.state = O.IDLE } this.startFragRequested ? o.live && this.synchronizeToLiveEdge(o) : this.setStartPosition(o, c), this.tick() }_handleFragmentLoadProgress (e) { let t; const { frag: r, part: i, payload: s } = e; const { levels: o } = this; if (!o) { this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`); return } const a = o[r.level]; const l = a.details; if (!l) { this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r); return } const u = a.videoCodec; const c = l.PTSKnown || !l.live; const d = (t = r.initSegment) == null ? void 0 : t.data; const h = this._getAudioCodec(a); const f = this.transmuxer = this.transmuxer || new $v(this.hls, X.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)); const p = i ? i.index : -1; const m = p !== -1; const y = new Ah(r.level, r.sn, r.stats.chunkCount, s.byteLength, p, m); const g = this.initPTS[r.cc]; f.push(s, d, h, u, r, i, l.totalduration, c, y, g) }onAudioTrackSwitching (e, t) { const r = this.altAudio; if (!t.url) { if (this.mediaBuffer !== this.media) { this.log('Switching on main audio, use media.buffered to schedule main fragment loading'), this.mediaBuffer = this.media; const o = this.fragCurrent; o && (this.log('Switching to main audio track, cancel main fragment load'), o.abortRequests(), this.fragmentTracker.removeFragment(o)), this.resetTransmuxer(), this.resetLoadingState() } else this.audioOnly && this.resetTransmuxer(); const s = this.hls; r && (s.trigger(S.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: null }), this.fragmentTracker.removeAllFragments()), s.trigger(S.AUDIO_TRACK_SWITCHED, t) } }onAudioTrackSwitched (e, t) { const r = t.id; const i = !!this.hls.audioTracks[r].url; if (i) { const s = this.videoBuffer; s && this.mediaBuffer !== s && (this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading'), this.mediaBuffer = s) } this.altAudio = i, this.tick() }onBufferCreated (e, t) { const r = t.tracks; let i; let s; let o = !1; for (const a in r) { const l = r[a]; if (l.id === 'main') { if (s = a, i = l, a === 'video') { const u = r[a]; u && (this.videoBuffer = u.buffer) } } else o = !0 }o && i ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media }onFragBuffered (e, t) { const { frag: r, part: i } = t; if (r && r.type !== X.MAIN) return; if (this.fragContextChanged(r)) { this.warn(`Fragment ${r.sn}${i ? ' p: ' + i.index : ''} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === O.PARSED && (this.state = O.IDLE); return } const s = i ? i.stats : r.stats; this.fragLastKbps = Math.round(8 * s.total / (s.buffering.end - s.loading.first)), r.sn !== 'initSegment' && (this.fragPrevious = r), this.fragBufferedComplete(r, i) }onError (e, t) { let r; if (t.fatal) { this.state = O.ERROR; return } switch (t.details) { case D.FRAG_GAP:case D.FRAG_PARSING_ERROR:case D.FRAG_DECRYPT_ERROR:case D.FRAG_LOAD_ERROR:case D.FRAG_LOAD_TIMEOUT:case D.KEY_LOAD_ERROR:case D.KEY_LOAD_TIMEOUT:this.onFragmentOrKeyLoadError(X.MAIN, t); break; case D.LEVEL_LOAD_ERROR:case D.LEVEL_LOAD_TIMEOUT:case D.LEVEL_PARSING_ERROR:!t.levelRetry && this.state === O.WAITING_LEVEL && ((r = t.context) == null ? void 0 : r.type) === se.LEVEL && (this.state = O.IDLE); break; case D.BUFFER_APPEND_ERROR:case D.BUFFER_FULL_ERROR:if (!t.parent || t.parent !== 'main') return; if (t.details === D.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY); break; case D.INTERNAL_EXCEPTION:this.recoverWorkerError(t); break } }checkBuffer () { const { media: e, gapController: t } = this; if (!(!e || !t || !e.readyState)) { if (this.loadedmetadata || !de.getBuffered(e).length) { const r = this.state !== O.IDLE ? this.fragCurrent : null; t.poll(this.lastCurrentTime, r) } this.lastCurrentTime = e.currentTime } }onFragLoadEmergencyAborted () { this.state = O.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate() }onBufferFlushed (e, { type: t }) { if (t !== ae.AUDIO || this.audioOnly && !this.altAudio) { const r = (t === ae.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; this.afterBufferFlushed(r, t, X.MAIN), this.tick() } }onLevelsUpdated (e, t) { this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = t.levels }swapAudioCodec () { this.audioCodecSwap = !this.audioCodecSwap }seekToStartPos () { const { media: e } = this; if (!e) return; const t = e.currentTime; let r = this.startPosition; if (r >= 0 && t < r) { if (e.seeking) { this.log(`could not seek to ${r}, already seeking at ${t}`); return } const i = de.getBuffered(e); const o = (i.length ? i.start(0) : 0) - r; o > 0 && (o < this.config.maxBufferHole || o < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${o} to match buffer start`), r += o, this.startPosition = r), this.log(`seek to target start position ${r} from current time ${t}`), e.currentTime = r } }_getAudioCodec (e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && t && (this.log('Swapping audio codec'), t.indexOf('mp4a.40.5') !== -1 ? t = 'mp4a.40.2' : t = 'mp4a.40.5'), t }_loadBitrateTestFrag (e, t) { e.bitrateTest = !0, this._doFragLoad(e, t).then(r => { const { hls: i } = this; if (!r || this.fragContextChanged(e)) return; t.fragmentError = 0, this.state = O.IDLE, this.startFragRequested = !1, this.bitrateTest = !1; const s = e.stats; s.parsing.start = s.parsing.end = s.buffering.start = s.buffering.end = self.performance.now(), i.trigger(S.FRAG_LOADED, r), e.bitrateTest = !1 }) }_handleTransmuxComplete (e) { let t; const r = 'main'; const { hls: i } = this; const { remuxResult: s, chunkMeta: o } = e; const a = this.getCurrentContext(o); if (!a) { this.resetWhenMissingContext(o); return } const { frag: l, part: u, level: c } = a; const { video: d, text: h, id3: f, initSegment: p } = s; const { details: m } = c; const y = this.altAudio ? void 0 : s.audio; if (this.fragContextChanged(l)) { this.fragmentTracker.removeFragment(l); return } if (this.state = O.PARSING, p) { if (p != null && p.tracks) { const E = l.initSegment || l; this._bufferInitSegment(c, p.tracks, E, o), i.trigger(S.FRAG_PARSING_INIT_SEGMENT, { frag: E, id: r, tracks: p.tracks }) } const g = p.initPTS; const v = p.timescale; K(g) && (this.initPTS[l.cc] = { baseTime: g, timescale: v }, i.trigger(S.INIT_PTS_FOUND, { frag: l, id: r, initPTS: g, timescale: v })) } if (d && m && l.sn !== 'initSegment') { const g = m.fragments[l.sn - 1 - m.startSN]; const v = l.sn === m.startSN; const E = !g || l.cc > g.cc; if (s.independent !== !1) { const { startPTS: x, endPTS: T, startDTS: w, endDTS: L } = d; if (u)u.elementaryStreams[d.type] = { startPTS: x, endPTS: T, startDTS: w, endDTS: L }; else if (d.firstKeyFrame && d.independent && o.id === 1 && !E && (this.couldBacktrack = !0), d.dropped && d.independent) { const A = this.getMainFwdBufferInfo(); const P = (A ? A.end : this.getLoadPosition()) + this.config.maxBufferHole; const _ = d.firstKeyFramePTS ? d.firstKeyFramePTS : x; if (!v && P < _ - this.config.maxBufferHole && !E) { this.backtrack(l); return } else E && (l.gap = !0); l.setElementaryStreamInfo(d.type, l.start, T, l.start, L, !0) } else v && x > Sa && (l.gap = !0); l.setElementaryStreamInfo(d.type, x, T, w, L), this.backtrackFragment && (this.backtrackFragment = l), this.bufferFragmentData(d, l, u, o, v || E) } else if (v || E)l.gap = !0; else { this.backtrack(l); return } } if (y) { const { startPTS: g, endPTS: v, startDTS: E, endDTS: x } = y; u && (u.elementaryStreams[ae.AUDIO] = { startPTS: g, endPTS: v, startDTS: E, endDTS: x }), l.setElementaryStreamInfo(ae.AUDIO, g, v, E, x), this.bufferFragmentData(y, l, u, o) } if (m && f != null && (t = f.samples) != null && t.length) { const g = { id: r, frag: l, details: m, samples: f.samples }; i.trigger(S.FRAG_PARSING_METADATA, g) } if (m && h) { const g = { id: r, frag: l, details: m, samples: h.samples }; i.trigger(S.FRAG_PARSING_USERDATA, g) } }_bufferInitSegment (e, t, r, i) { if (this.state !== O.PARSING) return; this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio; const { audio: s, video: o, audiovideo: a } = t; if (s) { let l = e.audioCodec; const u = navigator.userAgent.toLowerCase(); this.audioCodecSwitch && (l && (l.indexOf('mp4a.40.5') !== -1 ? l = 'mp4a.40.2' : l = 'mp4a.40.5'), s.metadata.channelCount !== 1 && u.indexOf('firefox') === -1 && (l = 'mp4a.40.5')), l && l.indexOf('mp4a.40.5') !== -1 && u.indexOf('android') !== -1 && s.container !== 'audio/mpeg' && (l = 'mp4a.40.2', this.log(`Android: force audio codec to ${l}`)), e.audioCodec && e.audioCodec !== l && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${l}"`), s.levelCodec = l, s.id = 'main', this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${l || ''}/${e.audioCodec || ''}/${s.codec}]`) }o && (o.levelCodec = e.videoCodec, o.id = 'main', this.log(`Init video buffer, container:${o.container}, codecs[level/parsed]=[${e.videoCodec || ''}/${o.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`), this.hls.trigger(S.BUFFER_CODECS, t), Object.keys(t).forEach(l => { const c = t[l].initSegment; c != null && c.byteLength && this.hls.trigger(S.BUFFER_APPENDING, { type: l, data: c, frag: r, part: null, chunkMeta: i, parent: r.type }) }), this.tickImmediate() }getMainFwdBufferInfo () { return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, X.MAIN) }backtrack (e) { this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = O.IDLE }checkFragmentChanged () { const e = this.media; let t = null; if (e && e.readyState > 1 && e.seeking === !1) { const r = e.currentTime; if (de.isBuffered(e, r) ? t = this.getAppendedFrag(r) : de.isBuffered(e, r + 0.1) && (t = this.getAppendedFrag(r + 0.1)), t) { this.backtrackFragment = null; const i = this.fragPlaying; const s = t.level; (!i || t.sn !== i.sn || i.level !== s) && (this.fragPlaying = t, this.hls.trigger(S.FRAG_CHANGED, { frag: t }), (!i || i.level !== s) && this.hls.trigger(S.LEVEL_SWITCHED, { level: s })) } } } get nextLevel () { const e = this.nextBufferedFrag; return e ? e.level : -1 } get currentFrag () { const e = this.media; return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null } get currentProgramDateTime () { const e = this.media; if (e) { const t = e.currentTime; const r = this.currentFrag; if (r && K(t) && K(r.programDateTime)) { const i = r.programDateTime + (t - r.start) * 1e3; return new Date(i) } } return null } get currentLevel () { const e = this.currentFrag; return e ? e.level : -1 } get nextBufferedFrag () { const e = this.currentFrag; return e ? this.followingBufferedFrag(e) : null } get forceStartLoad () { return this._forceStartLoad }} class pt {static get version () { return '1.5.8' } static isMSESupported () { return oE() } static isSupported () { return I_() } static getMediaSource () { return $r() } static get Events () { return S } static get ErrorTypes () { return J } static get ErrorDetails () { return D } static get DefaultConfig () { return pt.defaultConfig ? pt.defaultConfig : iE } static set DefaultConfig (e) { pt.defaultConfig = e }constructor (e = {}) { this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new Ph(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0, CA(e.debug || !1, 'Hls instance'); const t = this.config = R_(pt.DefaultConfig, e); this.userConfig = e, t.progressive && A_(t); const { abrController: r, bufferController: i, capLevelController: s, errorController: o, fpsController: a } = t; const l = new o(this); const u = this.abrController = new r(this); const c = this.bufferController = new i(this); const d = this.capLevelController = new s(this); const h = new a(this); const f = new Tw(this); const p = new ww(this); const m = t.contentSteeringController; const y = m ? new m(this) : null; const g = this.levelController = new w_(this, y); const v = new eC(this); const E = new C_(this.config); const x = this.streamController = new F_(this, v, E); d.setStreamController(x), h.setStreamController(x); const T = [f, g, x]; y && T.splice(1, 0, y), this.networkControllers = T; const w = [u, c, d, h, p, v]; this.audioTrackController = this.createController(t.audioTrackController, T); const L = t.audioStreamController; L && T.push(new L(this, v, E)), this.subtitleTrackController = this.createController(t.subtitleTrackController, T); const A = t.subtitleStreamController; A && T.push(new A(this, v, E)), this.createController(t.timelineController, w), E.emeController = this.emeController = this.createController(t.emeController, w), this.cmcdController = this.createController(t.cmcdController, w), this.latencyController = this.createController(Cw, w), this.coreComponents = w, T.push(l); const P = l.onErrorOut; typeof P === 'function' && this.on(S.ERROR, P, l) }createController (e, t) { if (e) { const r = new e(this); return t && t.push(r), r } return null }on (e, t, r = this) { this._emitter.on(e, t, r) }once (e, t, r = this) { this._emitter.once(e, t, r) }removeAllListeners (e) { this._emitter.removeAllListeners(e) }off (e, t, r = this, i) { this._emitter.off(e, t, r, i) }listeners (e) { return this._emitter.listeners(e) }emit (e, t, r) { return this._emitter.emit(e, t, r) }trigger (e, t) { if (this.config.debug) return this.emit(e, e, t); try { return this.emit(e, e, t) } catch (r) { if (C.error('An internal error happened while handling event ' + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), !this.triggeringException) { this.triggeringException = !0; const i = e === S.ERROR; this.trigger(S.ERROR, { type: J.OTHER_ERROR, details: D.INTERNAL_EXCEPTION, fatal: i, event: e, error: r }), this.triggeringException = !1 } } return !1 }listenerCount (e) { return this._emitter.listenerCount(e) }destroy () { C.log('destroy'), this.trigger(S.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(t => t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(t => t.destroy()), this.coreComponents.length = 0; const e = this.config; e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null }attachMedia (e) { C.log('attachMedia'), this._media = e, this.trigger(S.MEDIA_ATTACHING, { media: e }) }detachMedia () { C.log('detachMedia'), this.trigger(S.MEDIA_DETACHING, void 0), this._media = null }loadSource (e) { this.stopLoad(); const t = this.media; const r = this.url; const i = this.url = Eh.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }); this._autoLevelCapping = -1, this._maxHdcpLevel = null, C.log(`loadSource:${i}`), t && r && (r !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(S.MANIFEST_LOADING, { url: e }) }startLoad (e = -1) { C.log(`startLoad(${e})`), this.started = !0, this.networkControllers.forEach(t => { t.startLoad(e) }) }stopLoad () { C.log('stopLoad'), this.started = !1, this.networkControllers.forEach(e => { e.stopLoad() }) }resumeBuffering () { this.started && this.networkControllers.forEach(e => { 'fragmentLoader' in e && e.startLoad(-1) }) }pauseBuffering () { this.networkControllers.forEach(e => { 'fragmentLoader' in e && e.stopLoad() }) }swapAudioCodec () { C.log('swapAudioCodec'), this.streamController.swapAudioCodec() }recoverMediaError () { C.log('recoverMediaError'); const e = this._media; this.detachMedia(), e && this.attachMedia(e) }removeLevel (e) { this.levelController.removeLevel(e) } get levels () { const e = this.levelController.levels; return e || [] } get currentLevel () { return this.streamController.currentLevel } set currentLevel (e) { C.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch() } get nextLevel () { return this.streamController.nextLevel } set nextLevel (e) { C.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } get loadLevel () { return this.levelController.level } set loadLevel (e) { C.log(`set loadLevel:${e}`), this.levelController.manualLevel = e } get nextLoadLevel () { return this.levelController.nextLoadLevel } set nextLoadLevel (e) { this.levelController.nextLoadLevel = e } get firstLevel () { return Math.max(this.levelController.firstLevel, this.minAutoLevel) } set firstLevel (e) { C.log(`set firstLevel:${e}`), this.levelController.firstLevel = e } get startLevel () { const e = this.levelController.startLevel; return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e } set startLevel (e) { C.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } get capLevelToPlayerSize () { return this.config.capLevelToPlayerSize } set capLevelToPlayerSize (e) { const t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t) } get autoLevelCapping () { return this._autoLevelCapping } get bandwidthEstimate () { const { bwEstimator: e } = this.abrController; return e ? e.getEstimate() : NaN } set bandwidthEstimate (e) { this.abrController.resetEstimator(e) } get ttfbEstimate () { const { bwEstimator: e } = this.abrController; return e ? e.getEstimateTTFB() : NaN } set autoLevelCapping (e) { this._autoLevelCapping !== e && (C.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated()) } get maxHdcpLevel () { return this._maxHdcpLevel } set maxHdcpLevel (e) { Iw(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated()) } get autoLevelEnabled () { return this.levelController.manualLevel === -1 } get manualLevel () { return this.levelController.manualLevel } get minAutoLevel () { const { levels: e, config: { minAutoBitrate: t } } = this; if (!e) return 0; const r = e.length; for (let i = 0; i < r; i++) if (e[i].maxBitrate >= t) return i; return 0 } get maxAutoLevel () { const { levels: e, autoLevelCapping: t, maxHdcpLevel: r } = this; let i; if (t === -1 && e != null && e.length ? i = e.length - 1 : i = t, r) for (let s = i; s--;) { const o = e[s].attrs['HDCP-LEVEL']; if (o && o <= r) return s } return i } get firstAutoLevel () { return this.abrController.firstAutoLevel } get nextAutoLevel () { return this.abrController.nextAutoLevel } set nextAutoLevel (e) { this.abrController.nextAutoLevel = e } get playingDate () { return this.streamController.currentProgramDateTime } get mainForwardBufferInfo () { return this.streamController.getMainFwdBufferInfo() }setAudioOption (e) { let t; return (t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e) }setSubtitleOption (e) { let t; return (t = this.subtitleTrackController) == null || t.setSubtitleOption(e), null } get allAudioTracks () { const e = this.audioTrackController; return e ? e.allAudioTracks : [] } get audioTracks () { const e = this.audioTrackController; return e ? e.audioTracks : [] } get audioTrack () { const e = this.audioTrackController; return e ? e.audioTrack : -1 } set audioTrack (e) { const t = this.audioTrackController; t && (t.audioTrack = e) } get allSubtitleTracks () { const e = this.subtitleTrackController; return e ? e.allSubtitleTracks : [] } get subtitleTracks () { const e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } get subtitleTrack () { const e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 } get media () { return this._media } set subtitleTrack (e) { const t = this.subtitleTrackController; t && (t.subtitleTrack = e) } get subtitleDisplay () { const e = this.subtitleTrackController; return e ? e.subtitleDisplay : !1 } set subtitleDisplay (e) { const t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } get lowLatencyMode () { return this.config.lowLatencyMode } set lowLatencyMode (e) { this.config.lowLatencyMode = e } get liveSyncPosition () { return this.latencyController.liveSyncPosition } get latency () { return this.latencyController.latency } get maxLatency () { return this.latencyController.maxLatency } get targetLatency () { return this.latencyController.targetLatency } get drift () { return this.latencyController.drift } get forceStartLoad () { return this.streamController.forceStartLoad }}pt.defaultConfig = void 0; const M_ = ({ url: n, className: e }) => { const t = k.useRef(null); const r = k.useRef(null); return k.useEffect(() => { if (pt.isSupported() && t.current != null) { r.current !== null && r.current.destroy(); const i = new pt(); r.current = i, i.attachMedia(t.current), i.on(pt.Events.MEDIA_ATTACHED, () => { console.log('video and hls.js are now bound together !') }), i.on(pt.Events.MANIFEST_PARSED, () => { console.log('manifest-parsed: ') }), i.on(pt.Events.MANIFEST_LOADED, (s, o) => { console.log(' :', o.levels[0]) }), i.on(pt.Events.ERROR, (s, o) => { if (o.fatal) switch (o.type) { case pt.ErrorTypes.MEDIA_ERROR:console.log('fatal media error encountered, try to recover'), i.recoverMediaError(); break; case pt.ErrorTypes.NETWORK_ERROR:console.error('fatal network error encountered', o), i.recoverMediaError(); break; default:console.log('error hls destroy'), i.destroy(); break } }), i.loadSource(n) } }, [n]), k.useEffect(() => () => { r.current !== null && (r.current.detachMedia(), r.current.destroy()) }, []), B.jsx('video', { ref: t, className: e, autoPlay: !0, controls: !0 }) }; const N_ = () => { const [n, e] = k.useState(''); const t = o => { console.log(o), e(o.url) }; const { refetch: r } = hA(); const [i, s] = k.useState(); return B.jsxs('div', { className: pr.container, children: [B.jsxs('header', { className: pr.header, children: [B.jsx('h4', { children: 'Tv Streaming' }), B.jsxs('div', { className: pr.buttons, children: [B.jsx('button', { onClick: () => s(jc.ru), children: 'RU Channels' }), B.jsx('button', { onClick: () => s(jc.noname), children: 'Noname Channels' }), B.jsx('button', { className: pr.buttonUpdate, onClick: async () => await r(), children: 'Update tv streams' })] })] }), B.jsxs('main', { className: pr.main, children: [B.jsx(dA, { className: pr.playlist, handleChannel: t, list: i }), B.jsx(M_, { className: pr.player, url: n })] })] }) }; const U_ = '_container_jrycp_1'; const B_ = '_header_jrycp_6'; const $_ = '_main_jrycp_12'; const G_ = '_controls_jrycp_17'; const V_ = '_video_jrycp_21'; const H_ = '_input_jrycp_30'; const K_ = '_buttons_jrycp_38'; const j_ = '_disabled_jrycp_56'; const z_ = '_filters_jrycp_61'; const W_ = '_item_jrycp_70'; const Y_ = '_item_active_jrycp_78'; const q_ = '_result_jrycp_82'; const xt = { container: U_, header: B_, main: $_, controls: G_, video: V_, input: H_, buttons: K_, disabled: j_, filters: z_, item: W_, item_active: Y_, result: q_ }; const Q_ = (n, e) => { const { data: t, refetch: r, isLoading: i } = hh({ queryKey: [`${Js.GetScanSearchMovie}/${e}/${n}`], queryFn: async () => await PL(n, e), refetchOnWindowFocus: !1, enabled: !1 }); return k.useMemo(() => ({ searchMovieData: t, getSearchMovie: r, isLoading: i }), [t, i, r]) }; const X_ = () => { const { mutate: n, data: e, isPending: t, reset: r } = yL({ mutationFn: bL }); return { mutate: n, magnet: e == null ? void 0 : e.link, isPending: t, reset: r } }; const J_ = [{ id: 1, label: ' ' }, { id: 5, label: ' ' }, { id: 7, label: '' }, { id: 10, label: '' }, { id: 4, label: ' ' }, { id: 16, label: ' ' }]; const Jo = n => console.error(n); const Z_ = 'http://localhost:8000/api'; const eD = () => { const [n, e] = k.useState(''); const [t, r] = k.useState(''); const [i, s] = k.useState(null); const [o, a] = k.useState(1); const [l, u] = k.useState(''); const [c, d] = k.useState({ list: [], link: '' }); const { addMagnet: h, stopStream: f } = dy(); const { mutate: p, magnet: m, isPending: y, reset: g } = X_(); const { searchMovieData: v, getSearchMovie: E, isLoading: x } = Q_(n, o); const T = hy({ setData: s, infoHash: m }); const w = () => { try { c.link !== '' && l && (r(''), kL(c.link, l).catch(Jo)) } catch ($) { console.error($) } }; const L = k.useCallback(() => { T == null || T.close(), m != null && (f(m).catch(Jo), g()), r(''), u(''), s(null), d({ list: [], link: '' }) }, [T, m, g, f]); const A = () => { L(), e(''), u(''), d({ list: [], link: '' }) }; const P = () => { E().catch(Jo) }; const _ = $ => { m != null && (T == null || T.close(), f(m).catch(Jo), r(''), u(''), s(null), d({ list: [], link: '' })), p($, { onSuccess: G => { console.log(G), G.link !== '' && h(G.link).then(({ files: W }) => { console.log(W), d({ list: W, link: G.link }), W.length === 1 && u(W[0].name) }).catch(W => { console.error('Error adding magnet:', W) }) } }) }; const F = $ => { u($), r(`${Z_}/video/stream/${c.link}/${$}`) }; return k.useEffect(() => () => { T == null || T.close() }, [T]), k.useEffect(() => (L(), () => { L() }), []), B.jsxs('div', { className: xt.container, children: [B.jsx('h4', { className: xt.header, children: 'Video Stream' }), B.jsx('ul', { className: xt.filters, children: J_.map($ => B.jsx('li', { className: `${xt.item} ${o === $.id ? xt.item_active : ''}`, onClick: () => a($.id), children: $.label }, $.id)) }), B.jsxs('div', { className: xt.main, children: [B.jsxs('div', { className: xt.controls, children: [B.jsx('input', { className: xt.input, type: 'text', value: n, placeholder: 'Past magnet', onChange: $ => e($.target.value) }), B.jsxs('div', { className: xt.buttons, children: [B.jsx('button', { onClick: P, children: 'Search' }), B.jsx('button', { onClick: w, className: Ti({ [xt.disabled]: !(c.link && l) }), disabled: !(c.link && l), children: 'Play' }), B.jsx('button', { onClick: L, children: 'Stop' }), B.jsx('button', { onClick: A, children: 'Cancel' })] }), i != null && B.jsxs('div', { children: [B.jsxs('p', { children: ['Download speed: ', (i.speed / 1048576).toFixed(2), ' mb/s'] }), B.jsxs('p', { children: ['Progress: ', (i.progress * 100).toFixed(1), ' %'] }), B.jsxs('p', { children: ['Ratio: ', i.ratio] })] }), c.list.length === 1 ? B.jsx('p', { style: { cursor: 'pointer' }, onClick: () => F(c.list[0].name), children: c.list[0].name }) : c.list.length > 0 ? B.jsx('select', { onClick: $ => F($.currentTarget.value), children: c.list.map($ => B.jsx('option', { value: $.name, children: $.name }, $.name)) }) : null] }), t !== '' ? B.jsx('div', { className: xt.videoWrapper, children: B.jsx(Xy, { className: xt.video, url: t, controls: !0, playing: !0, muted: !1, type: 'video/mp4' }) }) : (y || x) && B.jsx('div', { children: '...Loading' })] }), B.jsx('div', { className: xt.result, children: v != null && B.jsxs(B.Fragment, { children: [B.jsx('h5', { children: 'Result' }), B.jsx('ul', { children: v.map($ => B.jsxs('li', { onClick: () => _(($ == null ? void 0 : $.urlTorrent) != null ? $.urlTorrent : $ == null ? void 0 : $.magnet), children: [B.jsx('p', { children: $.dateTorrent }), B.jsx('p', { children: $.nameTorrent }), B.jsx('p', { children: $.gbTorrent })] }, $.urlTorrent)) })] }) })] }) }; const tD = () => B.jsx(Cx, { children: B.jsxs(ei, { path: '/', element: B.jsx(AL, {}), children: [B.jsx(ei, { index: !0, element: B.jsx(Rx, { to: '/stream', replace: !0 }) }), B.jsx(ei, { path: '/stream', element: B.jsx(eD, {}) }), B.jsx(ei, { path: '/tv', element: B.jsx(N_, {}) }), B.jsx(ei, { path: '/torrent', element: B.jsx(oA, {}) })] }) }); function nD () { const n = new Zx(); return B.jsx(iL, { client: n, children: B.jsx(Ox, { children: B.jsx(tD, {}) }) }) }bu.createRoot(document.getElementById('root')).render(B.jsx($m.StrictMode, { children: B.jsx(nD, {}) })); export { ct as _, ad as g, NR as p, k as r, Rl as u }
